/*
 * Interface wrapper code.
 *
 * Generated by SIP 6.7.9
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_richtext.h"
        #include <wx/richtext/richtextctrl.h>
        #include <wx/window.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/validate.h>
        #include <wx/textcompleter.h>
        #include <wx/window.h>
        #include <wx/event.h>
        #include <wx/timer.h>
        #include <wx/gdicmn.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/event.h>
        #include <wx/richtext/richtextbuffer.h>
    #include <wx/longlong.h>
        #include <wx/cmdproc.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/dc.h>
        #include <wx/font.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include "arrayholder.h"
        #include <wx/menu.h>
        #include <wx/richtext/richtextstyles.h>
        #include <wx/richtext/richtextstyles.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/image.h>
        #include <wx/colour.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/datetime.h>
        #include <wx/cursor.h>
        #include <wx/bitmap.h>
        #include <wx/richtext/richtextbuffer.h>
        #include <wx/richtext/richtextstyles.h>
        #include <wx/textctrl.h>
        #include <wx/richtext/richtextctrl.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/caret.h>
        #include <wx/layout.h>
        #include <wx/sizer.h>
        #include <wx/dnd.h>
        #include <wx/access.h>
        #include <wx/accel.h>
        #include <wx/tooltip.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/palette.h>
        #include <wx/region.h>
        #include <wx/eventfilter.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>


class sipwxRichTextCtrl : public  ::wxRichTextCtrl
{
public:
    sipwxRichTextCtrl();
    sipwxRichTextCtrl( ::wxWindow*, ::wxWindowID,const  ::wxString&,const  ::wxPoint&,const  ::wxSize&,long,const  ::wxValidator&,const  ::wxString&);
    virtual ~sipwxRichTextCtrl();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    void sipProtect_SendDestroyEvent();
    bool sipProtectVirt_ProcessEvent(bool, ::wxEvent&);
    void sipProtectVirt_DoEnable(bool,bool);
    void sipProtectVirt_DoGetPosition(bool,int*,int*) const;
    void sipProtectVirt_DoGetSize(bool,int*,int*) const;
    void sipProtectVirt_DoGetClientSize(bool,int*,int*) const;
     ::wxSize sipProtectVirt_DoGetBestClientSize(bool) const;
    void sipProtectVirt_DoSetSize(bool,int,int,int,int,int);
    void sipProtectVirt_DoSetClientSize(bool,int,int);
    void sipProtectVirt_DoSetSizeHints(bool,int,int,int,int,int,int);
    void sipProtectVirt_DoMoveWindow(bool,int,int,int,int);
    void sipProtectVirt_DoSetWindowVariant(bool, ::wxWindowVariant);
     ::wxBorder sipProtectVirt_GetDefaultBorder(bool) const;
     ::wxBorder sipProtectVirt_GetDefaultBorderForControl(bool) const;
    void sipProtectVirt_DoFreeze(bool);
    bool sipProtectVirt_HasTransparentBackground(bool);
    bool sipProtectVirt_TryBefore(bool, ::wxEvent&);
    bool sipProtectVirt_TryAfter(bool, ::wxEvent&);
     ::wxSize sipProtectVirt_DoGetBestSize(bool) const;
    void sipProtectVirt_DoThaw(bool);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool CanRedo() const SIP_OVERRIDE;
    bool CanUndo() const SIP_OVERRIDE;
    void Redo() SIP_OVERRIDE;
    void Undo() SIP_OVERRIDE;
    bool CanPaste() const SIP_OVERRIDE;
    bool CanCut() const SIP_OVERRIDE;
    bool CanCopy() const SIP_OVERRIDE;
    void Paste() SIP_OVERRIDE;
    void Cut() SIP_OVERRIDE;
    void Copy() SIP_OVERRIDE;
     ::wxSize DoGetBestClientSize() const SIP_OVERRIDE;
     ::wxSize DoGetBestSize() const SIP_OVERRIDE;
    void DoThaw() SIP_OVERRIDE;
    void DoFreeze() SIP_OVERRIDE;
     ::wxBorder GetDefaultBorderForControl() const SIP_OVERRIDE;
     ::wxBorder GetDefaultBorder() const SIP_OVERRIDE;
    void DoSetWindowVariant( ::wxWindowVariant) SIP_OVERRIDE;
    void DoMoveWindow(int,int,int,int) SIP_OVERRIDE;
    void DoSetSizeHints(int,int,int,int,int,int) SIP_OVERRIDE;
    void DoSetClientSize(int,int) SIP_OVERRIDE;
    void DoSetSize(int,int,int,int,int) SIP_OVERRIDE;
    void DoGetClientSize(int*,int*) const SIP_OVERRIDE;
    void DoGetSize(int*,int*) const SIP_OVERRIDE;
    void DoGetPosition(int*,int*) const SIP_OVERRIDE;
    void DoEnable(bool) SIP_OVERRIDE;
     ::wxWindow* GetMainWindowOfCompositeControl() SIP_OVERRIDE;
    void OnInternalIdle() SIP_OVERRIDE;
    void InitDialog() SIP_OVERRIDE;
    void InheritAttributes() SIP_OVERRIDE;
    bool Destroy() SIP_OVERRIDE;
    bool Validate() SIP_OVERRIDE;
    bool TransferDataToWindow() SIP_OVERRIDE;
    bool TransferDataFromWindow() SIP_OVERRIDE;
    void SetValidator(const  ::wxValidator&) SIP_OVERRIDE;
     ::wxValidator* GetValidator() SIP_OVERRIDE;
    bool ShouldInheritColours() const SIP_OVERRIDE;
    bool HasTransparentBackground() SIP_OVERRIDE;
     ::wxPoint GetClientAreaOrigin() const SIP_OVERRIDE;
    bool InformFirstDirection(int,int,int) SIP_OVERRIDE;
    void EnableVisibleFocus(bool) SIP_OVERRIDE;
    void SetCanFocus(bool) SIP_OVERRIDE;
    bool AcceptsFocusRecursively() const SIP_OVERRIDE;
    bool AcceptsFocusFromKeyboard() const SIP_OVERRIDE;
    bool AcceptsFocus() const SIP_OVERRIDE;
    bool TryAfter( ::wxEvent&) SIP_OVERRIDE;
    bool TryBefore( ::wxEvent&) SIP_OVERRIDE;
    bool ProcessEvent( ::wxEvent&) SIP_OVERRIDE;
    void AddChild( ::wxWindowBase*) SIP_OVERRIDE;
    void RemoveChild( ::wxWindowBase*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxRichTextCtrl(const sipwxRichTextCtrl &);
    sipwxRichTextCtrl &operator = (const sipwxRichTextCtrl &);

    char sipPyMethods[49];
};

sipwxRichTextCtrl::sipwxRichTextCtrl():  ::wxRichTextCtrl(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxRichTextCtrl::sipwxRichTextCtrl( ::wxWindow*parent, ::wxWindowID id,const  ::wxString& value,const  ::wxPoint& pos,const  ::wxSize& size,long style,const  ::wxValidator& validator,const  ::wxString& name):  ::wxRichTextCtrl(parent,id,value,pos,size,style,validator,name), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxRichTextCtrl::~sipwxRichTextCtrl()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipwxRichTextCtrl::CanRedo() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[0]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanRedo);

    if (!sipMeth)
        return  ::wxRichTextCtrl::CanRedo();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::CanUndo() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[1]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanUndo);

    if (!sipMeth)
        return  ::wxRichTextCtrl::CanUndo();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::Redo()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[2], &sipPySelf, SIP_NULLPTR, sipName_Redo);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::Redo();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::Undo()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[3], &sipPySelf, SIP_NULLPTR, sipName_Undo);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::Undo();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::CanPaste() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[4]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanPaste);

    if (!sipMeth)
        return  ::wxRichTextCtrl::CanPaste();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::CanCut() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[5]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanCut);

    if (!sipMeth)
        return  ::wxRichTextCtrl::CanCut();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::CanCopy() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[6]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanCopy);

    if (!sipMeth)
        return  ::wxRichTextCtrl::CanCopy();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::Paste()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[7], &sipPySelf, SIP_NULLPTR, sipName_Paste);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::Paste();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::Cut()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[8], &sipPySelf, SIP_NULLPTR, sipName_Cut);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::Cut();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::Copy()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[9], &sipPySelf, SIP_NULLPTR, sipName_Copy);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::Copy();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxSize sipwxRichTextCtrl::DoGetBestClientSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[10]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetBestClientSize);

    if (!sipMeth)
        return  ::wxRichTextCtrl::DoGetBestClientSize();

    extern  ::wxSize sipVH__richtext_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_4(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxSize sipwxRichTextCtrl::DoGetBestSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[11]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetBestSize);

    if (!sipMeth)
        return  ::wxRichTextCtrl::DoGetBestSize();

    extern  ::wxSize sipVH__richtext_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_4(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::DoThaw()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[12], &sipPySelf, SIP_NULLPTR, sipName_DoThaw);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoThaw();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::DoFreeze()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[13], &sipPySelf, SIP_NULLPTR, sipName_DoFreeze);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoFreeze();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxRichTextCtrl::GetDefaultBorderForControl() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[14]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetDefaultBorderForControl);

    if (!sipMeth)
        return  ::wxRichTextCtrl::GetDefaultBorderForControl();

    extern  ::wxBorder sipVH__richtext_140(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_140(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxRichTextCtrl::GetDefaultBorder() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[15]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetDefaultBorder);

    if (!sipMeth)
        return  ::wxRichTextCtrl::GetDefaultBorder();

    extern  ::wxBorder sipVH__richtext_140(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_140(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::DoSetWindowVariant( ::wxWindowVariant variant)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[16], &sipPySelf, SIP_NULLPTR, sipName_DoSetWindowVariant);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoSetWindowVariant(variant);
        return;
    }

    extern void sipVH__richtext_139(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowVariant);

    sipVH__richtext_139(sipGILState, 0, sipPySelf, sipMeth, variant);
}

void sipwxRichTextCtrl::DoMoveWindow(int x,int y,int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[17], &sipPySelf, SIP_NULLPTR, sipName_DoMoveWindow);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoMoveWindow(x,y,width,height);
        return;
    }

    extern void sipVH__richtext_29(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int);

    sipVH__richtext_29(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height);
}

void sipwxRichTextCtrl::DoSetSizeHints(int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[18], &sipPySelf, SIP_NULLPTR, sipName_DoSetSizeHints);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH);
        return;
    }

    extern void sipVH__richtext_138(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int,int);

    sipVH__richtext_138(sipGILState, 0, sipPySelf, sipMeth, minW, minH, maxW, maxH, incW, incH);
}

void sipwxRichTextCtrl::DoSetClientSize(int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[19], &sipPySelf, SIP_NULLPTR, sipName_DoSetClientSize);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoSetClientSize(width,height);
        return;
    }

    extern void sipVH__richtext_137(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int);

    sipVH__richtext_137(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxRichTextCtrl::DoSetSize(int x,int y,int width,int height,int sizeFlags)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[20], &sipPySelf, SIP_NULLPTR, sipName_DoSetSize);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoSetSize(x,y,width,height,sizeFlags);
        return;
    }

    extern void sipVH__richtext_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int);

    sipVH__richtext_136(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height, sizeFlags);
}

void sipwxRichTextCtrl::DoGetClientSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[21]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetClientSize);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoGetClientSize(width,height);
        return;
    }

    extern void sipVH__richtext_135(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__richtext_135(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxRichTextCtrl::DoGetSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[22]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetSize);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoGetSize(width,height);
        return;
    }

    extern void sipVH__richtext_135(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__richtext_135(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxRichTextCtrl::DoGetPosition(int*x,int*y) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[23]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetPosition);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoGetPosition(x,y);
        return;
    }

    extern void sipVH__richtext_135(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__richtext_135(sipGILState, 0, sipPySelf, sipMeth, x, y);
}

void sipwxRichTextCtrl::DoEnable(bool enable)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[24], &sipPySelf, SIP_NULLPTR, sipName_DoEnable);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::DoEnable(enable);
        return;
    }

    extern void sipVH__richtext_33(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__richtext_33(sipGILState, 0, sipPySelf, sipMeth, enable);
}

 ::wxWindow* sipwxRichTextCtrl::GetMainWindowOfCompositeControl()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[25], &sipPySelf, SIP_NULLPTR, sipName_GetMainWindowOfCompositeControl);

    if (!sipMeth)
        return  ::wxRichTextCtrl::GetMainWindowOfCompositeControl();

    extern  ::wxWindow* sipVH__richtext_134(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_134(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::OnInternalIdle()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[26], &sipPySelf, SIP_NULLPTR, sipName_OnInternalIdle);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::OnInternalIdle();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::InitDialog()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[27], &sipPySelf, SIP_NULLPTR, sipName_InitDialog);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::InitDialog();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::InheritAttributes()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[28], &sipPySelf, SIP_NULLPTR, sipName_InheritAttributes);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::InheritAttributes();
        return;
    }

    extern void sipVH__richtext_40(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__richtext_40(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::Destroy()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[29], &sipPySelf, SIP_NULLPTR, sipName_Destroy);

    if (!sipMeth)
        return  ::wxRichTextCtrl::Destroy();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::Validate()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[30], &sipPySelf, SIP_NULLPTR, sipName_Validate);

    if (!sipMeth)
        return  ::wxRichTextCtrl::Validate();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::TransferDataToWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[31], &sipPySelf, SIP_NULLPTR, sipName_TransferDataToWindow);

    if (!sipMeth)
        return  ::wxRichTextCtrl::TransferDataToWindow();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::TransferDataFromWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[32], &sipPySelf, SIP_NULLPTR, sipName_TransferDataFromWindow);

    if (!sipMeth)
        return  ::wxRichTextCtrl::TransferDataFromWindow();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxRichTextCtrl::SetValidator(const  ::wxValidator& validator)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[33], &sipPySelf, SIP_NULLPTR, sipName_SetValidator);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::SetValidator(validator);
        return;
    }

    extern void sipVH__richtext_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxValidator&);

    sipVH__richtext_133(sipGILState, 0, sipPySelf, sipMeth, validator);
}

 ::wxValidator* sipwxRichTextCtrl::GetValidator()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[34], &sipPySelf, SIP_NULLPTR, sipName_GetValidator);

    if (!sipMeth)
        return  ::wxRichTextCtrl::GetValidator();

    extern  ::wxValidator* sipVH__richtext_132(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_132(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::ShouldInheritColours() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[35]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_ShouldInheritColours);

    if (!sipMeth)
        return  ::wxRichTextCtrl::ShouldInheritColours();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::HasTransparentBackground()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[36], &sipPySelf, SIP_NULLPTR, sipName_HasTransparentBackground);

    if (!sipMeth)
        return  ::wxRichTextCtrl::HasTransparentBackground();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxPoint sipwxRichTextCtrl::GetClientAreaOrigin() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[37]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetClientAreaOrigin);

    if (!sipMeth)
        return  ::wxRichTextCtrl::GetClientAreaOrigin();

    extern  ::wxPoint sipVH__richtext_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_22(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::InformFirstDirection(int direction,int size,int availableOtherDir)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[38], &sipPySelf, SIP_NULLPTR, sipName_InformFirstDirection);

    if (!sipMeth)
        return  ::wxRichTextCtrl::InformFirstDirection(direction,size,availableOtherDir);

    extern bool sipVH__richtext_131(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int);

    return sipVH__richtext_131(sipGILState, 0, sipPySelf, sipMeth, direction, size, availableOtherDir);
}

void sipwxRichTextCtrl::EnableVisibleFocus(bool enabled)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[39], &sipPySelf, SIP_NULLPTR, sipName_EnableVisibleFocus);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::EnableVisibleFocus(enabled);
        return;
    }

    extern void sipVH__richtext_33(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__richtext_33(sipGILState, 0, sipPySelf, sipMeth, enabled);
}

void sipwxRichTextCtrl::SetCanFocus(bool canFocus)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[40], &sipPySelf, SIP_NULLPTR, sipName_SetCanFocus);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::SetCanFocus(canFocus);
        return;
    }

    extern void sipVH__richtext_33(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__richtext_33(sipGILState, 0, sipPySelf, sipMeth, canFocus);
}

bool sipwxRichTextCtrl::AcceptsFocusRecursively() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[41]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocusRecursively);

    if (!sipMeth)
        return  ::wxRichTextCtrl::AcceptsFocusRecursively();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::AcceptsFocusFromKeyboard() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[42]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocusFromKeyboard);

    if (!sipMeth)
        return  ::wxRichTextCtrl::AcceptsFocusFromKeyboard();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::AcceptsFocus() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[43]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocus);

    if (!sipMeth)
        return  ::wxRichTextCtrl::AcceptsFocus();

    extern bool sipVH__richtext_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__richtext_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxRichTextCtrl::TryAfter( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[44], &sipPySelf, SIP_NULLPTR, sipName_TryAfter);

    if (!sipMeth)
        return  ::wxRichTextCtrl::TryAfter(event);

    extern bool sipVH__richtext_130(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__richtext_130(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxRichTextCtrl::TryBefore( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[45], &sipPySelf, SIP_NULLPTR, sipName_TryBefore);

    if (!sipMeth)
        return  ::wxRichTextCtrl::TryBefore(event);

    extern bool sipVH__richtext_130(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__richtext_130(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxRichTextCtrl::ProcessEvent( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[46], &sipPySelf, SIP_NULLPTR, sipName_ProcessEvent);

    if (!sipMeth)
        return  ::wxRichTextCtrl::ProcessEvent(event);

    extern bool sipVH__richtext_130(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__richtext_130(sipGILState, 0, sipPySelf, sipMeth, event);
}

void sipwxRichTextCtrl::AddChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[47], &sipPySelf, SIP_NULLPTR, sipName_AddChild);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::AddChild(child);
        return;
    }

    extern void sipVH__richtext_129(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__richtext_129(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxRichTextCtrl::RemoveChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[48], &sipPySelf, SIP_NULLPTR, sipName_RemoveChild);

    if (!sipMeth)
    {
         ::wxRichTextCtrl::RemoveChild(child);
        return;
    }

    extern void sipVH__richtext_129(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__richtext_129(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxRichTextCtrl::sipProtect_SendDestroyEvent()
{
     ::wxWindow::SendDestroyEvent();
}

bool sipwxRichTextCtrl::sipProtectVirt_ProcessEvent(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxRichTextCtrl::ProcessEvent(event) : ProcessEvent(event));
}

void sipwxRichTextCtrl::sipProtectVirt_DoEnable(bool sipSelfWasArg,bool enable)
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoEnable(enable) : DoEnable(enable));
}

void sipwxRichTextCtrl::sipProtectVirt_DoGetPosition(bool sipSelfWasArg,int*x,int*y) const
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoGetPosition(x,y) : DoGetPosition(x,y));
}

void sipwxRichTextCtrl::sipProtectVirt_DoGetSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoGetSize(width,height) : DoGetSize(width,height));
}

void sipwxRichTextCtrl::sipProtectVirt_DoGetClientSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoGetClientSize(width,height) : DoGetClientSize(width,height));
}

 ::wxSize sipwxRichTextCtrl::sipProtectVirt_DoGetBestClientSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxRichTextCtrl::DoGetBestClientSize() : DoGetBestClientSize());
}

void sipwxRichTextCtrl::sipProtectVirt_DoSetSize(bool sipSelfWasArg,int x,int y,int width,int height,int sizeFlags)
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoSetSize(x,y,width,height,sizeFlags) : DoSetSize(x,y,width,height,sizeFlags));
}

void sipwxRichTextCtrl::sipProtectVirt_DoSetClientSize(bool sipSelfWasArg,int width,int height)
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoSetClientSize(width,height) : DoSetClientSize(width,height));
}

void sipwxRichTextCtrl::sipProtectVirt_DoSetSizeHints(bool sipSelfWasArg,int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH) : DoSetSizeHints(minW,minH,maxW,maxH,incW,incH));
}

void sipwxRichTextCtrl::sipProtectVirt_DoMoveWindow(bool sipSelfWasArg,int x,int y,int width,int height)
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoMoveWindow(x,y,width,height) : DoMoveWindow(x,y,width,height));
}

void sipwxRichTextCtrl::sipProtectVirt_DoSetWindowVariant(bool sipSelfWasArg, ::wxWindowVariant variant)
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoSetWindowVariant(variant) : DoSetWindowVariant(variant));
}

 ::wxBorder sipwxRichTextCtrl::sipProtectVirt_GetDefaultBorder(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxRichTextCtrl::GetDefaultBorder() : GetDefaultBorder());
}

 ::wxBorder sipwxRichTextCtrl::sipProtectVirt_GetDefaultBorderForControl(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxRichTextCtrl::GetDefaultBorderForControl() : GetDefaultBorderForControl());
}

void sipwxRichTextCtrl::sipProtectVirt_DoFreeze(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoFreeze() : DoFreeze());
}

bool sipwxRichTextCtrl::sipProtectVirt_HasTransparentBackground(bool sipSelfWasArg)
{
    return (sipSelfWasArg ?  ::wxRichTextCtrl::HasTransparentBackground() : HasTransparentBackground());
}

bool sipwxRichTextCtrl::sipProtectVirt_TryBefore(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxRichTextCtrl::TryBefore(event) : TryBefore(event));
}

bool sipwxRichTextCtrl::sipProtectVirt_TryAfter(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxRichTextCtrl::TryAfter(event) : TryAfter(event));
}

 ::wxSize sipwxRichTextCtrl::sipProtectVirt_DoGetBestSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxRichTextCtrl::DoGetBestSize() : DoGetBestSize());
}

void sipwxRichTextCtrl::sipProtectVirt_DoThaw(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxRichTextCtrl::DoThaw() : DoThaw());
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SendDestroyEvent, "SendDestroyEvent()\n"
"\n"
"Generate wxWindowDestroyEvent for this window.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SendDestroyEvent(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SendDestroyEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        sipwxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtect_SendDestroyEvent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SendDestroyEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetSelection, "GetSelection() -> RichTextSelection\n"
"\n"
"Returns the range of the current selection.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextSelection*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->GetSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextSelection,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetContextMenuPropertiesInfo, "GetContextMenuPropertiesInfo() -> RichTextContextMenuPropertiesInfo\n"
"\n"
"Returns an object that stores information about context menu property\n"
"item(s), in order to communicate between the context menu event\n"
"handler and the code that responds to it.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetContextMenuPropertiesInfo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetContextMenuPropertiesInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextContextMenuPropertiesInfo*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->GetContextMenuPropertiesInfo();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextContextMenuPropertiesInfo,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetContextMenuPropertiesInfo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetStyle, "GetStyle(position, style) -> bool\n"
"GetStyle(position, style) -> bool\n"
"GetStyle(position, style, container) -> bool\n"
"\n"
"Gets the attributes at the given position.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long position;
         ::wxTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BlJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, sipType_wxTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyle(position,*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        long position;
         ::wxRichTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BlJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyle(position,*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        long position;
         ::wxRichTextAttr* style;
         ::wxRichTextParagraphLayoutBox* container;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_style,
            sipName_container,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BlJ9J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, sipType_wxRichTextAttr, &style, sipType_wxRichTextParagraphLayoutBox, &container))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyle(position,*style,container);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetStyle, "SetStyle(start, end, style) -> bool\n"
"SetStyle(start, end, style) -> bool\n"
"SetStyle(range, style) -> bool\n"
"SetStyle(range, style) -> bool\n"
"SetStyle(obj, textAttr, flags=RICHTEXT_SETSTYLE_WITH_UNDO)\n"
"\n"
"Sets the attributes for the given range.\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long start;
        long end;
        const  ::wxTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BllJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &start, &end, sipType_wxTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetStyle(start,end,*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        long start;
        long end;
        const  ::wxRichTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BllJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &start, &end, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetStyle(start,end,*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetStyle(*range,*style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxRichTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetStyle(*range,*style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxRichTextObject* obj;
        const  ::wxRichTextAttr* textAttr;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_obj,
            sipName_textAttr,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J9|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextObject, &obj, sipType_wxRichTextAttr, &textAttr, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetStyle(obj,*textAttr,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetStyleForRange, "GetStyleForRange(range, style) -> bool\n"
"GetStyleForRange(range, style) -> bool\n"
"GetStyleForRange(range, style, container) -> bool\n"
"\n"
"Gets the attributes common to the specified range.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetStyleForRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetStyleForRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyleForRange(*range,*style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxRichTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyleForRange(*range,*style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxRichTextAttr* style;
         ::wxRichTextParagraphLayoutBox* container;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_style,
            sipName_container,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextAttr, &style, sipType_wxRichTextParagraphLayoutBox, &container))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyleForRange(*range,*style,container);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetStyleForRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetUncombinedStyle, "GetUncombinedStyle(position, style) -> bool\n"
"GetUncombinedStyle(position, style, container) -> bool\n"
"\n"
"Gets the attributes at the given position.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetUncombinedStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetUncombinedStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long position;
         ::wxRichTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BlJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetUncombinedStyle(position,*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        long position;
         ::wxRichTextAttr* style;
         ::wxRichTextParagraphLayoutBox* container;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_style,
            sipName_container,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BlJ9J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, sipType_wxRichTextAttr, &style, sipType_wxRichTextParagraphLayoutBox, &container))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetUncombinedStyle(position,*style,container);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetUncombinedStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDefaultStyle, "SetDefaultStyle(style) -> bool\n"
"SetDefaultStyle(style) -> bool\n"
"\n"
"Sets the current default style, which can be used to change how\n"
"subsequently inserted text is displayed.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDefaultStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDefaultStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetDefaultStyle(*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRichTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetDefaultStyle(*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDefaultStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetListStyle, "SetListStyle(range, styleDef, flags=RICHTEXT_SETSTYLE_WITH_UNDO, startFrom=1, specifiedLevel=-1) -> bool\n"
"SetListStyle(range, defName, flags=RICHTEXT_SETSTYLE_WITH_UNDO, startFrom=1, specifiedLevel=-1) -> bool\n"
"\n"
"Sets the list attributes for the given range, passing flags to\n"
"determine how the attributes are set.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetListStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetListStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxRichTextListStyleDefinition* styleDef;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
        int startFrom = 1;
        int specifiedLevel = -1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_styleDef,
            sipName_flags,
            sipName_startFrom,
            sipName_specifiedLevel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J8|iii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextListStyleDefinition, &styleDef, &flags, &startFrom, &specifiedLevel))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetListStyle(*range,styleDef,flags,startFrom,specifiedLevel);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxString* defName;
        int defNameState = 0;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
        int startFrom = 1;
        int specifiedLevel = -1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_defName,
            sipName_flags,
            sipName_startFrom,
            sipName_specifiedLevel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1|iii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxString, &defName, &defNameState, &flags, &startFrom, &specifiedLevel))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetListStyle(*range,*defName,flags,startFrom,specifiedLevel);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);
            sipReleaseType(const_cast< ::wxString *>(defName), sipType_wxString, defNameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetListStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_NumberList, "NumberList(range, def=None, flags=RICHTEXT_SETSTYLE_WITH_UNDO, startFrom=1, specifiedLevel=-1) -> bool\n"
"NumberList(range, defName, flags=RICHTEXT_SETSTYLE_WITH_UNDO, startFrom=1, specifiedLevel=-1) -> bool\n"
"\n"
"Numbers the paragraphs in the given range.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_NumberList(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_NumberList(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxRichTextListStyleDefinition* def = 0;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
        int startFrom = 1;
        int specifiedLevel = -1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_def,
            sipName_flags,
            sipName_startFrom,
            sipName_specifiedLevel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|J8iii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextListStyleDefinition, &def, &flags, &startFrom, &specifiedLevel))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->NumberList(*range,def,flags,startFrom,specifiedLevel);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxString* defName;
        int defNameState = 0;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
        int startFrom = 1;
        int specifiedLevel = -1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_defName,
            sipName_flags,
            sipName_startFrom,
            sipName_specifiedLevel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1|iii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxString, &defName, &defNameState, &flags, &startFrom, &specifiedLevel))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->NumberList(*range,*defName,flags,startFrom,specifiedLevel);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);
            sipReleaseType(const_cast< ::wxString *>(defName), sipType_wxString, defNameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_NumberList, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PromoteList, "PromoteList(promoteBy, range, def=None, flags=RICHTEXT_SETSTYLE_WITH_UNDO, specifiedLevel=-1) -> bool\n"
"PromoteList(promoteBy, range, defName, flags=RICHTEXT_SETSTYLE_WITH_UNDO, specifiedLevel=-1) -> bool\n"
"\n"
"Promotes or demotes the paragraphs in the given range.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_PromoteList(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PromoteList(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int promoteBy;
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxRichTextListStyleDefinition* def = 0;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
        int specifiedLevel = -1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_promoteBy,
            sipName_range,
            sipName_def,
            sipName_flags,
            sipName_specifiedLevel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1|J8ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &promoteBy, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextListStyleDefinition, &def, &flags, &specifiedLevel))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PromoteList(promoteBy,*range,def,flags,specifiedLevel);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        int promoteBy;
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxString* defName;
        int defNameState = 0;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
        int specifiedLevel = -1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_promoteBy,
            sipName_range,
            sipName_defName,
            sipName_flags,
            sipName_specifiedLevel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1J1|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &promoteBy, sipType_wxRichTextRange, &range, &rangeState, sipType_wxString, &defName, &defNameState, &flags, &specifiedLevel))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PromoteList(promoteBy,*range,*defName,flags,specifiedLevel);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);
            sipReleaseType(const_cast< ::wxString *>(defName), sipType_wxString, defNameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PromoteList, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_HitTest, "HitTest(pt) -> (TextCtrlHitTestResult, pos)\n"
"\n"
"Finds the character at the given position in pixels.");

extern "C" {static PyObject *meth_wxRichTextCtrl_HitTest(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_HitTest(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        long pos;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxTextCtrlHitTestResult sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HitTest(*pt,&pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(Fl)",sipRes,sipType_wxTextCtrlHitTestResult,pos);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_HitTest, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_HitTestXY, "HitTestXY(pt) -> (TextCtrlHitTestResult, col, row)\n"
"\n"
"Finds the character at the given position in pixels.");

extern "C" {static PyObject *meth_wxRichTextCtrl_HitTestXY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_HitTestXY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
         ::wxTextCoord col;
         ::wxTextCoord row;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxTextCtrlHitTestResult sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HitTest(*pt,&col,&row);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(Fll)",sipRes,sipType_wxTextCtrlHitTestResult,col,row);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_HitTestXY, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_FindContainerAtPoint, "FindContainerAtPoint(pt, position, hit, hitObj, flags=0) -> RichTextParagraphLayoutBox\n"
"\n"
"Finds the container at the given point, which is assumed to be in\n"
"client coordinates.");

extern "C" {static PyObject *meth_wxRichTextCtrl_FindContainerAtPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_FindContainerAtPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        long position;
        int hit;
         ::wxRichTextObject* hitObj;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_hitObj,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J8|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState, sipType_wxRichTextObject, &hitObj, &flags))
        {
             ::wxRichTextParagraphLayoutBox*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindContainerAtPoint(*pt,position,hit,hitObj,flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            PyObject *sipResObj = sipConvertFromType(sipRes,sipType_wxRichTextParagraphLayoutBox,SIP_NULLPTR);
            return sipBuildResult(0,"(Rli)",sipResObj,position,hit);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_FindContainerAtPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetSelection, "SetSelection(from_, to_)\n"
"SetSelection(sel)\n"
"\n"
"Sets the selection to the given range.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long from_;
        long to_;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bll", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &from_, &to_))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelection(from_,to_);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxRichTextSelection* sel;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextSelection, &sel))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelection(*sel);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_WriteImage, "WriteImage(image, bitmapType=wx.BITMAP_TYPE_PNG, textAttr=RichTextAttr()) -> bool\n"
"WriteImage(bitmap, bitmapType=wx.BITMAP_TYPE_PNG, textAttr=RichTextAttr()) -> bool\n"
"WriteImage(filename, bitmapType, textAttr=RichTextAttr()) -> bool\n"
"WriteImage(imageBlock, textAttr=RichTextAttr()) -> bool\n"
"\n"
"Write a bitmap or image at the current insertion point.\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_WriteImage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_WriteImage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxImage* image;
         ::wxBitmapType bitmapType = wxBITMAP_TYPE_PNG;
        const  ::wxRichTextAttr& textAttrdef = wxRichTextAttr();
        const  ::wxRichTextAttr* textAttr = &textAttrdef;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_image,
            sipName_bitmapType,
            sipName_textAttr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9|EJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxImage, &image, sipType_wxBitmapType, &bitmapType, sipType_wxRichTextAttr, &textAttr))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WriteImage(*image,bitmapType,*textAttr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxBitmap* bitmap;
         ::wxBitmapType bitmapType = wxBITMAP_TYPE_PNG;
        const  ::wxRichTextAttr& textAttrdef = wxRichTextAttr();
        const  ::wxRichTextAttr* textAttr = &textAttrdef;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bitmap,
            sipName_bitmapType,
            sipName_textAttr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9|EJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxBitmap, &bitmap, sipType_wxBitmapType, &bitmapType, sipType_wxRichTextAttr, &textAttr))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WriteImage(*bitmap,bitmapType,*textAttr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxString* filename;
        int filenameState = 0;
         ::wxBitmapType bitmapType;
        const  ::wxRichTextAttr& textAttrdef = wxRichTextAttr();
        const  ::wxRichTextAttr* textAttr = &textAttrdef;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_filename,
            sipName_bitmapType,
            sipName_textAttr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1E|J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &filename, &filenameState, sipType_wxBitmapType, &bitmapType, sipType_wxRichTextAttr, &textAttr))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WriteImage(*filename,bitmapType,*textAttr);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(filename), sipType_wxString, filenameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRichTextImageBlock* imageBlock;
        const  ::wxRichTextAttr& textAttrdef = wxRichTextAttr();
        const  ::wxRichTextAttr* textAttr = &textAttrdef;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_imageBlock,
            sipName_textAttr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9|J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextImageBlock, &imageBlock, sipType_wxRichTextAttr, &textAttr))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WriteImage(*imageBlock,*textAttr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_WriteImage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetBuffer, "GetBuffer() -> RichTextBuffer\n"
"\n"
"Returns the buffer associated with the control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetBuffer(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetBuffer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextBuffer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->GetBuffer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextBuffer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetBuffer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Create, "Create(parent, id=-1, value=wx.EmptyString, pos=wx.DefaultPosition, size=wx.DefaultSize, style=RE_MULTILINE, validator=wx.DefaultValidator, name=wx.TextCtrlNameStr) -> bool\n"
"\n"
"Creates the underlying window.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Create(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Create(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* parent;
         ::wxWindowID id = -1;
        const  ::wxString& valuedef = wxEmptyString;
        const  ::wxString* value = &valuedef;
        int valueState = 0;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        long style = wxRE_MULTILINE;
        const  ::wxValidator& validatordef = wxDefaultValidator;
        const  ::wxValidator* validator = &validatordef;
        const  ::wxString& namedef = wxTextCtrlNameStr;
        const  ::wxString* name = &namedef;
        int nameState = 0;
        sipWrapper *sipOwner = SIP_NULLPTR;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_parent,
            sipName_id,
            sipName_value,
            sipName_pos,
            sipName_size,
            sipName_style,
            sipName_validator,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJH|iJ1J1J1lJ9J1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxWindow, &parent, &sipOwner, &id, sipType_wxString, &value, &valueState, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, &style, sipType_wxValidator, &validator, sipType_wxString, &name, &nameState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Create(parent,id,*value,*pos,*size,style,*validator,*name);
            Py_END_ALLOW_THREADS

            if (sipOwner)
                sipTransferTo(sipSelf, (PyObject *)sipOwner);
            else
                sipTransferBack(sipSelf);
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Create, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Init, "Init()\n"
"\n"
"Initialises the members of the control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Init(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Init(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Init();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Init, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetRange, "GetRange(from_, to_) -> String\n"
"\n"
"Gets the text for the given range.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long from_;
        long to_;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bll", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &from_, &to_))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetRange(from_,to_));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetLineLength, "GetLineLength(lineNo) -> int\n"
"\n"
"Returns the length of the specified line in characters.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetLineLength(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetLineLength(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long lineNo;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineNo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &lineNo))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineLength(lineNo);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetLineLength, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetLineText, "GetLineText(lineNo) -> String\n"
"\n"
"Returns the text for the given line.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetLineText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetLineText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long lineNo;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineNo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &lineNo))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLineText(lineNo));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetLineText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetNumberOfLines, "GetNumberOfLines() -> int\n"
"\n"
"Returns the number of lines in the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetNumberOfLines(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetNumberOfLines(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetNumberOfLines();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetNumberOfLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsModified, "IsModified() -> bool\n"
"\n"
"Returns true if the buffer has been modified.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsModified(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsModified(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsModified();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsModified, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsEditable, "IsEditable() -> bool\n"
"\n"
"Returns true if the control is editable.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsEditable(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsEditable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEditable();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsEditable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsSingleLine, "IsSingleLine() -> bool\n"
"\n"
"Returns true if the control is single-line.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsSingleLine(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsSingleLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsSingleLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsSingleLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsMultiLine, "IsMultiLine() -> bool\n"
"\n"
"Returns true if the control is multiline.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsMultiLine(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsMultiLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsMultiLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsMultiLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetStringSelection, "GetStringSelection() -> String\n"
"\n"
"Returns the text within the current selection range, if any.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetStringSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetStringSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetStringSelection());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetStringSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetFilename, "GetFilename() -> String\n"
"\n"
"Gets the current filename associated with the control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetFilename(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetFilename(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetFilename());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetFilename, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetFilename, "SetFilename(filename)\n"
"\n"
"Sets the current filename.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetFilename(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetFilename(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* filename;
        int filenameState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_filename,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &filename, &filenameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFilename(*filename);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(filename), sipType_wxString, filenameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetFilename, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDelayedLayoutThreshold, "SetDelayedLayoutThreshold(threshold)\n"
"\n"
"Sets the size of the buffer beyond which layout is delayed during\n"
"resizing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDelayedLayoutThreshold(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDelayedLayoutThreshold(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long threshold;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_threshold,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &threshold))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDelayedLayoutThreshold(threshold);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDelayedLayoutThreshold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDelayedLayoutThreshold, "GetDelayedLayoutThreshold() -> long\n"
"\n"
"Gets the size of the buffer beyond which layout is delayed during\n"
"resizing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDelayedLayoutThreshold(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDelayedLayoutThreshold(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDelayedLayoutThreshold();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDelayedLayoutThreshold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetFullLayoutRequired, "GetFullLayoutRequired() -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetFullLayoutRequired(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetFullLayoutRequired(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFullLayoutRequired();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetFullLayoutRequired, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetFullLayoutRequired, "SetFullLayoutRequired(b)");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetFullLayoutRequired(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetFullLayoutRequired(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool b;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_b,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &b))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFullLayoutRequired(b);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetFullLayoutRequired, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetFullLayoutTime, "GetFullLayoutTime() -> LongLong");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetFullLayoutTime(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetFullLayoutTime(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxLongLong*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxLongLong(sipCpp->GetFullLayoutTime());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxLongLong,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetFullLayoutTime, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetFullLayoutTime, "SetFullLayoutTime(t)");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetFullLayoutTime(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetFullLayoutTime(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxLongLong* t;
        int tState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_t,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxLongLong, &t, &tState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFullLayoutTime(*t);
            Py_END_ALLOW_THREADS
            sipReleaseType(t, sipType_wxLongLong, tState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetFullLayoutTime, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetFullLayoutSavedPosition, "GetFullLayoutSavedPosition() -> long");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetFullLayoutSavedPosition(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetFullLayoutSavedPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFullLayoutSavedPosition();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetFullLayoutSavedPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetFullLayoutSavedPosition, "SetFullLayoutSavedPosition(p)");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetFullLayoutSavedPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetFullLayoutSavedPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long p;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_p,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &p))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFullLayoutSavedPosition(p);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetFullLayoutSavedPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ForceDelayedLayout, "ForceDelayedLayout()");

extern "C" {static PyObject *meth_wxRichTextCtrl_ForceDelayedLayout(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ForceDelayedLayout(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ForceDelayedLayout();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ForceDelayedLayout, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetTextCursor, "SetTextCursor(cursor)\n"
"\n"
"Sets the text (normal) cursor.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetTextCursor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetTextCursor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxCursor* cursor;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cursor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCursor, &cursor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTextCursor(*cursor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetTextCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetTextCursor, "GetTextCursor() -> wx.Cursor\n"
"\n"
"Returns the text (normal) cursor.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetTextCursor(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetTextCursor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxCursor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCursor(sipCpp->GetTextCursor());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxCursor,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetTextCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetURLCursor, "SetURLCursor(cursor)\n"
"\n"
"Sets the cursor to be used over URLs.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetURLCursor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetURLCursor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxCursor* cursor;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cursor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCursor, &cursor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetURLCursor(*cursor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetURLCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetURLCursor, "GetURLCursor() -> wx.Cursor\n"
"\n"
"Returns the cursor to be used over URLs.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetURLCursor(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetURLCursor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxCursor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCursor(sipCpp->GetURLCursor());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxCursor,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetURLCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetCaretAtLineStart, "GetCaretAtLineStart() -> bool\n"
"\n"
"Returns true if we are showing the caret position at the start of a\n"
"line instead of at the end of the previous one.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetCaretAtLineStart(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetCaretAtLineStart(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretAtLineStart();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetCaretAtLineStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetCaretAtLineStart, "SetCaretAtLineStart(atStart)\n"
"\n"
"Sets a flag to remember that we are showing the caret position at the\n"
"start of a line instead of at the end of the previous one.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetCaretAtLineStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetCaretAtLineStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool atStart;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_atStart,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &atStart))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretAtLineStart(atStart);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetCaretAtLineStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDragging, "GetDragging() -> bool\n"
"\n"
"Returns true if we are extending a selection.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDragging(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDragging(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDragging();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDragging, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDragging, "SetDragging(dragging)\n"
"\n"
"Sets a flag to remember if we are extending a selection.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDragging(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDragging(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool dragging;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dragging,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &dragging))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDragging(dragging);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDragging, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetPreDrag, "GetPreDrag() -> bool\n"
"\n"
"Are we trying to start Drag'n'Drop?");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetPreDrag(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetPreDrag(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPreDrag();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetPreDrag, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetPreDrag, "SetPreDrag(pd)\n"
"\n"
"Set if we're trying to start Drag'n'Drop.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetPreDrag(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetPreDrag(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool pd;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pd,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pd))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPreDrag(pd);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetPreDrag, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDragStartPoint, "GetDragStartPoint() -> wx.Point\n"
"\n"
"Get the possible Drag'n'Drop start point.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDragStartPoint(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDragStartPoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetDragStartPoint());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDragStartPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDragStartPoint, "SetDragStartPoint(sp)\n"
"\n"
"Set the possible Drag'n'Drop start point.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDragStartPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDragStartPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxPoint* sp;
        int spState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sp,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &sp, &spState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDragStartPoint(*sp);
            Py_END_ALLOW_THREADS
            sipReleaseType(sp, sipType_wxPoint, spState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDragStartPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDragStartTime, "GetDragStartTime() -> wx.DateTime\n"
"\n"
"Get the possible Drag'n'Drop start time.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDragStartTime(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDragStartTime(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxDateTime*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateTime(sipCpp->GetDragStartTime());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateTime,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDragStartTime, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDragStartTime, "SetDragStartTime(st)\n"
"\n"
"Set the possible Drag'n'Drop start time.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDragStartTime(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDragStartTime(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDateTime* st;
        int stState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_st,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxDateTime, &st, &stState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDragStartTime(*st);
            Py_END_ALLOW_THREADS
            sipReleaseType(st, sipType_wxDateTime, stState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDragStartTime, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetContextMenu, "GetContextMenu() -> wx.Menu\n"
"\n"
"Returns the current context menu.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetContextMenu(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetContextMenu(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxMenu*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetContextMenu();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenu,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetContextMenu, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetContextMenu, "SetContextMenu(menu)\n"
"\n"
"Sets the current context menu.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetContextMenu(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetContextMenu(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMenu* menu;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menu,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMenu, &menu))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetContextMenu(menu);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetContextMenu, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetSelectionAnchor, "GetSelectionAnchor() -> long\n"
"\n"
"Returns an anchor so we know how to extend the selection.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetSelectionAnchor(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetSelectionAnchor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionAnchor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetSelectionAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetSelectionAnchor, "SetSelectionAnchor(anchor)\n"
"\n"
"Sets an anchor so we know how to extend the selection.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetSelectionAnchor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetSelectionAnchor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long anchor;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_anchor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &anchor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionAnchor(anchor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetSelectionAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetSelectionAnchorObject, "GetSelectionAnchorObject() -> RichTextObject\n"
"\n"
"Returns the anchor object if selecting multiple containers.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetSelectionAnchorObject(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetSelectionAnchorObject(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextObject*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionAnchorObject();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextObject,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetSelectionAnchorObject, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetSelectionAnchorObject, "SetSelectionAnchorObject(anchor)\n"
"\n"
"Sets the anchor object if selecting multiple containers.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetSelectionAnchorObject(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetSelectionAnchorObject(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextObject* anchor;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_anchor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextObject, &anchor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionAnchorObject(anchor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetSelectionAnchorObject, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetFocusObject, "GetFocusObject() -> RichTextParagraphLayoutBox\n"
"\n"
"Returns the wxRichTextObject object that currently has the editing\n"
"focus.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetFocusObject(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetFocusObject(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextParagraphLayoutBox*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFocusObject();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextParagraphLayoutBox,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetFocusObject, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_StoreFocusObject, "StoreFocusObject(obj)\n"
"\n"
"Setter for m_focusObject.");

extern "C" {static PyObject *meth_wxRichTextCtrl_StoreFocusObject(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_StoreFocusObject(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextParagraphLayoutBox* obj;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_obj,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextParagraphLayoutBox, &obj))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StoreFocusObject(obj);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_StoreFocusObject, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetFocusObject, "SetFocusObject(obj, setCaretPosition=True) -> bool\n"
"\n"
"Sets the wxRichTextObject object that currently has the editing focus.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetFocusObject(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetFocusObject(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextParagraphLayoutBox* obj;
        bool setCaretPosition = 1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_obj,
            sipName_setCaretPosition,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextParagraphLayoutBox, &obj, &setCaretPosition))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetFocusObject(obj,setCaretPosition);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetFocusObject, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Invalidate, "Invalidate()\n"
"\n"
"Invalidates the whole buffer to trigger painting later.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Invalidate(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Invalidate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Invalidate();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Invalidate, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Clear, "Clear()\n"
"\n"
"Clears the buffer content, leaving a single empty paragraph.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Clear(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Clear(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Clear();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Clear, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Replace, "Replace(from_, to_, value)\n"
"\n"
"Replaces the content in the specified range with the string specified\n"
"by value.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Replace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Replace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long from_;
        long to_;
        const  ::wxString* value;
        int valueState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BllJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &from_, &to_, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Replace(from_,to_,*value);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Replace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Remove, "Remove(from_, to_)\n"
"\n"
"Removes the content in the specified range.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Remove(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Remove(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long from_;
        long to_;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bll", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &from_, &to_))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Remove(from_,to_);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Remove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_LoadFile, "LoadFile(file, type=RICHTEXT_TYPE_ANY) -> bool\n"
"\n"
"Loads content into the control's buffer using the given type.");

extern "C" {static PyObject *meth_wxRichTextCtrl_LoadFile(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_LoadFile(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* file;
        int fileState = 0;
        int type = wxRICHTEXT_TYPE_ANY;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_file,
            sipName_type,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &file, &fileState, &type))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LoadFile(*file,type);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(file), sipType_wxString, fileState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_LoadFile, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoLoadFile, "DoLoadFile(file, fileType) -> bool\n"
"\n"
"Helper function for LoadFile().");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoLoadFile(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoLoadFile(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* file;
        int fileState = 0;
        int fileType;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_file,
            sipName_fileType,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &file, &fileState, &fileType))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DoLoadFile(*file,fileType);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(file), sipType_wxString, fileState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoLoadFile, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SaveFile, "SaveFile(file=wx.EmptyString, type=RICHTEXT_TYPE_ANY) -> bool\n"
"\n"
"Saves the buffer content using the given type.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SaveFile(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SaveFile(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString& filedef = wxEmptyString;
        const  ::wxString* file = &filedef;
        int fileState = 0;
        int type = wxRICHTEXT_TYPE_ANY;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_file,
            sipName_type,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J1i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &file, &fileState, &type))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SaveFile(*file,type);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(file), sipType_wxString, fileState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SaveFile, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoSaveFile, "DoSaveFile(file=wx.EmptyString, fileType=RICHTEXT_TYPE_ANY) -> bool\n"
"\n"
"Helper function for SaveFile().");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoSaveFile(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoSaveFile(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString& filedef = wxEmptyString;
        const  ::wxString* file = &filedef;
        int fileState = 0;
        int fileType = wxRICHTEXT_TYPE_ANY;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_file,
            sipName_fileType,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J1i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &file, &fileState, &fileType))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DoSaveFile(*file,fileType);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(file), sipType_wxString, fileState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoSaveFile, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetHandlerFlags, "SetHandlerFlags(flags)\n"
"\n"
"Sets flags that change the behaviour of loading or saving.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetHandlerFlags(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetHandlerFlags(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHandlerFlags(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetHandlerFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetHandlerFlags, "GetHandlerFlags() -> int\n"
"\n"
"Returns flags that change the behaviour of loading or saving.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetHandlerFlags(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetHandlerFlags(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetHandlerFlags();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetHandlerFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MarkDirty, "MarkDirty()\n"
"\n"
"Marks the buffer as modified.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MarkDirty(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MarkDirty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkDirty();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MarkDirty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DiscardEdits, "DiscardEdits()\n"
"\n"
"Sets the buffer's modified status to false, and clears the buffer's\n"
"command history.");

extern "C" {static PyObject *meth_wxRichTextCtrl_DiscardEdits(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DiscardEdits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DiscardEdits();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DiscardEdits, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetModified, "SetModified(modified)");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetModified(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetModified(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool modified;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_modified,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &modified))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetModified(modified);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetModified, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetMaxLength, "SetMaxLength(len)\n"
"\n"
"Sets the maximum number of characters that may be entered in a single\n"
"line text control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetMaxLength(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetMaxLength(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        unsigned long len;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_len,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bm", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &len))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMaxLength(len);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetMaxLength, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_WriteText, "WriteText(text)\n"
"\n"
"Writes text at the current position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_WriteText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_WriteText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WriteText(*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_WriteText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AppendText, "AppendText(text)\n"
"\n"
"Sets the insertion point to the end of the buffer and writes the text.");

extern "C" {static PyObject *meth_wxRichTextCtrl_AppendText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AppendText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AppendText(*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AppendText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetStyleEx, "SetStyleEx(range, style, flags=RICHTEXT_SETSTYLE_WITH_UNDO) -> bool\n"
"\n"
"Sets the attributes for the given range, passing flags to determine\n"
"how the attributes are set.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetStyleEx(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetStyleEx(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxRichTextAttr* style;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_style,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextAttr, &style, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetStyleEx(*range,*style,flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetStyleEx, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDefaultStyleEx, "GetDefaultStyleEx() -> RichTextAttr\n"
"\n"
"Returns the current default style, which can be used to change how\n"
"subsequently inserted text is displayed.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDefaultStyleEx(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDefaultStyleEx(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextAttr*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRichTextAttr(sipCpp->GetDefaultStyleEx());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRichTextAttr,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDefaultStyleEx, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ClearListStyle, "ClearListStyle(range, flags=RICHTEXT_SETSTYLE_WITH_UNDO) -> bool\n"
"\n"
"Clears the list style from the given range, clearing list-related\n"
"attributes and applying any named paragraph style associated with each\n"
"paragraph.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ClearListStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ClearListStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        int flags = wxRICHTEXT_SETSTYLE_WITH_UNDO;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ClearListStyle(*range,flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ClearListStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetProperties, "SetProperties(range, properties, flags=RICHTEXT_SETPROPERTIES_WITH_UNDO) -> bool\n"
"\n"
"Sets the properties for the given range, passing flags to determine\n"
"how the attributes are set.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetProperties(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetProperties(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxRichTextProperties* properties;
        int flags = wxRICHTEXT_SETPROPERTIES_WITH_UNDO;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_properties,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextProperties, &properties, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetProperties(*range,*properties,flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetProperties, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Delete, "Delete(range) -> bool\n"
"\n"
"Deletes the content within the given range.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Delete(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Delete(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Delete(*range);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Delete, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_XYToPosition, "XYToPosition(x, y) -> long\n"
"\n"
"Translates from column and line number to position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_XYToPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_XYToPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long x;
        long y;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bll", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &x, &y))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->XYToPosition(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_XYToPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PositionToXY, "PositionToXY(pos) -> (bool, x, y)\n"
"\n"
"Converts a text position to zero-based column and line numbers.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PositionToXY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PositionToXY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long pos;
        long x;
        long y;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pos))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PositionToXY(pos,&x,&y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(bll)",sipRes,x,y);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PositionToXY, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ShowPosition, "ShowPosition(pos)\n"
"\n"
"Scrolls the buffer so that the given position is in view.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ShowPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ShowPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long pos;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pos))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ShowPosition(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ShowPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Copy, "Copy()\n"
"\n"
"Copies the selected content (if any) to the clipboard.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Copy(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Copy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::Copy() : sipCpp->Copy());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Copy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Cut, "Cut()\n"
"\n"
"Copies the selected content (if any) to the clipboard and deletes the\n"
"selection.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Cut(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Cut(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::Cut() : sipCpp->Cut());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Cut, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Paste, "Paste()\n"
"\n"
"Pastes content from the clipboard to the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Paste(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Paste(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::Paste() : sipCpp->Paste());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Paste, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DeleteSelection, "DeleteSelection()\n"
"\n"
"Deletes the content in the selection, if any.");

extern "C" {static PyObject *meth_wxRichTextCtrl_DeleteSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DeleteSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DeleteSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DeleteSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanCopy, "CanCopy() -> bool\n"
"\n"
"Returns true if selected content can be copied to the clipboard.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanCopy(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanCopy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::CanCopy() : sipCpp->CanCopy());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanCopy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanCut, "CanCut() -> bool\n"
"\n"
"Returns true if selected content can be copied to the clipboard and\n"
"deleted.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanCut(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanCut(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::CanCut() : sipCpp->CanCut());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanCut, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanPaste, "CanPaste() -> bool\n"
"\n"
"Returns true if the clipboard content can be pasted to the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanPaste(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanPaste(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::CanPaste() : sipCpp->CanPaste());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanPaste, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanDeleteSelection, "CanDeleteSelection() -> bool\n"
"\n"
"Returns true if selected content can be deleted.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanDeleteSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanDeleteSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDeleteSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanDeleteSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Undo, "Undo()\n"
"\n"
"Undoes the command at the top of the command history, if there is one.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Undo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Undo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::Undo() : sipCpp->Undo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Undo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Redo, "Redo()\n"
"\n"
"Redoes the current command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Redo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Redo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::Redo() : sipCpp->Redo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Redo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanUndo, "CanUndo() -> bool\n"
"\n"
"Returns true if there is a command in the command history that can be\n"
"undone.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanUndo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanUndo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::CanUndo() : sipCpp->CanUndo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanRedo, "CanRedo() -> bool\n"
"\n"
"Returns true if there is a command in the command history that can be\n"
"redone.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanRedo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanRedo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::CanRedo() : sipCpp->CanRedo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanRedo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetInsertionPoint, "SetInsertionPoint(pos)\n"
"\n"
"Sets the insertion point and causes the current editing style to be\n"
"taken from the new position (unlike wxRichTextCtrl::SetCaretPosition).");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetInsertionPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetInsertionPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long pos;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pos))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetInsertionPoint(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetInsertionPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetInsertionPointEnd, "SetInsertionPointEnd()\n"
"\n"
"Sets the insertion point to the end of the text control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetInsertionPointEnd(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetInsertionPointEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetInsertionPointEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetInsertionPointEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetInsertionPoint, "GetInsertionPoint() -> long\n"
"\n"
"Returns the current insertion point.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetInsertionPoint(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetInsertionPoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetInsertionPoint();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetInsertionPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetLastPosition, "GetLastPosition() -> TextPos\n"
"\n"
"Returns the last position in the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetLastPosition(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetLastPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxTextPos sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLastPosition();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetLastPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SelectAll, "SelectAll()\n"
"\n"
"Selects all the text in the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SelectAll(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SelectAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SelectAll();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SelectAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetEditable, "SetEditable(editable)\n"
"\n"
"Makes the control editable, or not.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetEditable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetEditable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool editable;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_editable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &editable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetEditable(editable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetEditable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_HasSelection, "HasSelection() -> bool\n"
"\n"
"Returns true if there is a selection and the object containing the\n"
"selection was the same as the current focus object.");

extern "C" {static PyObject *meth_wxRichTextCtrl_HasSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_HasSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_HasSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_HasUnfocusedSelection, "HasUnfocusedSelection() -> bool\n"
"\n"
"Returns true if there was a selection, whether or not the current\n"
"focus object is the same as the selection's container object.");

extern "C" {static PyObject *meth_wxRichTextCtrl_HasUnfocusedSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_HasUnfocusedSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasUnfocusedSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_HasUnfocusedSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_WriteTextBox, "WriteTextBox(textAttr=RichTextAttr()) -> RichTextBox\n"
"\n"
"Write a text box at the current insertion point, returning the text\n"
"box.");

extern "C" {static PyObject *meth_wxRichTextCtrl_WriteTextBox(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_WriteTextBox(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextAttr& textAttrdef = wxRichTextAttr();
        const  ::wxRichTextAttr* textAttr = &textAttrdef;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_textAttr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextAttr, &textAttr))
        {
             ::wxRichTextBox*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WriteTextBox(*textAttr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextBox,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_WriteTextBox, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_WriteField, "WriteField(fieldType, properties, textAttr=RichTextAttr()) -> RichTextField\n"
"\n"
"Writes a field at the current insertion point.");

extern "C" {static PyObject *meth_wxRichTextCtrl_WriteField(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_WriteField(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* fieldType;
        int fieldTypeState = 0;
        const  ::wxRichTextProperties* properties;
        const  ::wxRichTextAttr& textAttrdef = wxRichTextAttr();
        const  ::wxRichTextAttr* textAttr = &textAttrdef;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fieldType,
            sipName_properties,
            sipName_textAttr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9|J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &fieldType, &fieldTypeState, sipType_wxRichTextProperties, &properties, sipType_wxRichTextAttr, &textAttr))
        {
             ::wxRichTextField*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WriteField(*fieldType,*properties,*textAttr);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(fieldType), sipType_wxString, fieldTypeState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextField,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_WriteField, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_WriteTable, "WriteTable(rows, cols, tableAttr=RichTextAttr(), cellAttr=RichTextAttr()) -> RichTextTable\n"
"\n"
"Write a table at the current insertion point, returning the table.");

extern "C" {static PyObject *meth_wxRichTextCtrl_WriteTable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_WriteTable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int rows;
        int cols;
        const  ::wxRichTextAttr& tableAttrdef = wxRichTextAttr();
        const  ::wxRichTextAttr* tableAttr = &tableAttrdef;
        const  ::wxRichTextAttr& cellAttrdef = wxRichTextAttr();
        const  ::wxRichTextAttr* cellAttr = &cellAttrdef;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rows,
            sipName_cols,
            sipName_tableAttr,
            sipName_cellAttr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|J9J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &rows, &cols, sipType_wxRichTextAttr, &tableAttr, sipType_wxRichTextAttr, &cellAttr))
        {
             ::wxRichTextTable*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WriteTable(rows,cols,*tableAttr,*cellAttr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextTable,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_WriteTable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Newline, "Newline() -> bool\n"
"\n"
"Inserts a new paragraph at the current insertion point.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Newline(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Newline(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Newline();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Newline, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_LineBreak, "LineBreak() -> bool\n"
"\n"
"Inserts a line break at the current insertion point.");

extern "C" {static PyObject *meth_wxRichTextCtrl_LineBreak(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_LineBreak(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LineBreak();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_LineBreak, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetBasicStyle, "SetBasicStyle(style)\n"
"\n"
"Sets the basic (overall) style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetBasicStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetBasicStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextAttr, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetBasicStyle(*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetBasicStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetBasicStyle, "GetBasicStyle() -> RichTextAttr\n"
"\n"
"Gets the basic (overall) style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetBasicStyle(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetBasicStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextAttr*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRichTextAttr(sipCpp->GetBasicStyle());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRichTextAttr,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetBasicStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginStyle, "BeginStyle(style) -> bool\n"
"\n"
"Begins applying a style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextAttr* style;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginStyle(*style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndStyle, "EndStyle() -> bool\n"
"\n"
"Ends the current style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndStyle(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndAllStyles, "EndAllStyles() -> bool\n"
"\n"
"Ends application of all styles in the current style stack.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndAllStyles(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndAllStyles(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndAllStyles();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndAllStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginBold, "BeginBold() -> bool\n"
"\n"
"Begins using bold.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginBold(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginBold(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginBold();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginBold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndBold, "EndBold() -> bool\n"
"\n"
"Ends using bold.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndBold(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndBold(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndBold();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndBold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginItalic, "BeginItalic() -> bool\n"
"\n"
"Begins using italic.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginItalic(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginItalic(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginItalic();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginItalic, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndItalic, "EndItalic() -> bool\n"
"\n"
"Ends using italic.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndItalic(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndItalic(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndItalic();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndItalic, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginUnderline, "BeginUnderline() -> bool\n"
"\n"
"Begins using underlining.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginUnderline(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginUnderline(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginUnderline();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginUnderline, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndUnderline, "EndUnderline() -> bool\n"
"\n"
"End applying underlining.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndUnderline(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndUnderline(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndUnderline();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndUnderline, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginFontSize, "BeginFontSize(pointSize) -> bool\n"
"\n"
"Begins using the given point size.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginFontSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginFontSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pointSize;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pointSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pointSize))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginFontSize(pointSize);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginFontSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndFontSize, "EndFontSize() -> bool\n"
"\n"
"Ends using a point size.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndFontSize(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndFontSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndFontSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndFontSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginFont, "BeginFont(font) -> bool\n"
"\n"
"Begins using this font.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxFont* font;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxFont, &font))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginFont(*font);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndFont, "EndFont() -> bool\n"
"\n"
"Ends using a font.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndFont(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndFont(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndFont();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginTextColour, "BeginTextColour(colour) -> bool\n"
"\n"
"Begins using this colour.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginTextColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginTextColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginTextColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginTextColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndTextColour, "EndTextColour() -> bool\n"
"\n"
"Ends applying a text colour.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndTextColour(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndTextColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndTextColour();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndTextColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginAlignment, "BeginAlignment(alignment) -> bool\n"
"\n"
"Begins using alignment.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxTextAttrAlignment alignment;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alignment,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxTextAttrAlignment, &alignment))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginAlignment(alignment);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndAlignment, "EndAlignment() -> bool\n"
"\n"
"Ends alignment.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndAlignment(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndAlignment(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndAlignment();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginLeftIndent, "BeginLeftIndent(leftIndent, leftSubIndent=0) -> bool\n"
"\n"
"Begins applying a left indent and subindent in tenths of a millimetre.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginLeftIndent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginLeftIndent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int leftIndent;
        int leftSubIndent = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_leftIndent,
            sipName_leftSubIndent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &leftIndent, &leftSubIndent))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginLeftIndent(leftIndent,leftSubIndent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginLeftIndent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndLeftIndent, "EndLeftIndent() -> bool\n"
"\n"
"Ends left indent.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndLeftIndent(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndLeftIndent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndLeftIndent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndLeftIndent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginRightIndent, "BeginRightIndent(rightIndent) -> bool\n"
"\n"
"Begins a right indent, specified in tenths of a millimetre.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginRightIndent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginRightIndent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int rightIndent;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rightIndent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &rightIndent))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginRightIndent(rightIndent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginRightIndent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndRightIndent, "EndRightIndent() -> bool\n"
"\n"
"Ends right indent.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndRightIndent(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndRightIndent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndRightIndent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndRightIndent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginParagraphSpacing, "BeginParagraphSpacing(before, after) -> bool\n"
"\n"
"Begins paragraph spacing; pass the before-paragraph and after-\n"
"paragraph spacing in tenths of a millimetre.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginParagraphSpacing(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginParagraphSpacing(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int before;
        int after;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_before,
            sipName_after,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &before, &after))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginParagraphSpacing(before,after);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginParagraphSpacing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndParagraphSpacing, "EndParagraphSpacing() -> bool\n"
"\n"
"Ends paragraph spacing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndParagraphSpacing(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndParagraphSpacing(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndParagraphSpacing();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndParagraphSpacing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginLineSpacing, "BeginLineSpacing(lineSpacing) -> bool\n"
"\n"
"Begins applying line spacing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginLineSpacing(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginLineSpacing(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lineSpacing;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineSpacing,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &lineSpacing))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginLineSpacing(lineSpacing);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginLineSpacing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndLineSpacing, "EndLineSpacing() -> bool\n"
"\n"
"Ends line spacing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndLineSpacing(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndLineSpacing(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndLineSpacing();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndLineSpacing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginNumberedBullet, "BeginNumberedBullet(bulletNumber, leftIndent, leftSubIndent, bulletStyle=wx.TEXT_ATTR_BULLET_STYLE_ARABIC|wx.TEXT_ATTR_BULLET_STYLE_PERIOD) -> bool\n"
"\n"
"Begins a numbered bullet.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginNumberedBullet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginNumberedBullet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int bulletNumber;
        int leftIndent;
        int leftSubIndent;
        int bulletStyle = wxTEXT_ATTR_BULLET_STYLE_ARABIC|wxTEXT_ATTR_BULLET_STYLE_PERIOD;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bulletNumber,
            sipName_leftIndent,
            sipName_leftSubIndent,
            sipName_bulletStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biii|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &bulletNumber, &leftIndent, &leftSubIndent, &bulletStyle))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginNumberedBullet(bulletNumber,leftIndent,leftSubIndent,bulletStyle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginNumberedBullet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndNumberedBullet, "EndNumberedBullet() -> bool\n"
"\n"
"Ends application of a numbered bullet.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndNumberedBullet(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndNumberedBullet(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndNumberedBullet();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndNumberedBullet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginSymbolBullet, "BeginSymbolBullet(symbol, leftIndent, leftSubIndent, bulletStyle=wx.TEXT_ATTR_BULLET_STYLE_SYMBOL) -> bool\n"
"\n"
"Begins applying a symbol bullet, using a character from the current\n"
"font.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginSymbolBullet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginSymbolBullet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* symbol;
        int symbolState = 0;
        int leftIndent;
        int leftSubIndent;
        int bulletStyle = wxTEXT_ATTR_BULLET_STYLE_SYMBOL;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_symbol,
            sipName_leftIndent,
            sipName_leftSubIndent,
            sipName_bulletStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1ii|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &symbol, &symbolState, &leftIndent, &leftSubIndent, &bulletStyle))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginSymbolBullet(*symbol,leftIndent,leftSubIndent,bulletStyle);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(symbol), sipType_wxString, symbolState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginSymbolBullet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndSymbolBullet, "EndSymbolBullet() -> bool\n"
"\n"
"Ends applying a symbol bullet.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndSymbolBullet(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndSymbolBullet(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndSymbolBullet();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndSymbolBullet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginStandardBullet, "BeginStandardBullet(bulletName, leftIndent, leftSubIndent, bulletStyle=wx.TEXT_ATTR_BULLET_STYLE_STANDARD) -> bool\n"
"\n"
"Begins applying a symbol bullet.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginStandardBullet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginStandardBullet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* bulletName;
        int bulletNameState = 0;
        int leftIndent;
        int leftSubIndent;
        int bulletStyle = wxTEXT_ATTR_BULLET_STYLE_STANDARD;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bulletName,
            sipName_leftIndent,
            sipName_leftSubIndent,
            sipName_bulletStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1ii|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &bulletName, &bulletNameState, &leftIndent, &leftSubIndent, &bulletStyle))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginStandardBullet(*bulletName,leftIndent,leftSubIndent,bulletStyle);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(bulletName), sipType_wxString, bulletNameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginStandardBullet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndStandardBullet, "EndStandardBullet() -> bool\n"
"\n"
"Begins applying a standard bullet.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndStandardBullet(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndStandardBullet(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndStandardBullet();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndStandardBullet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginCharacterStyle, "BeginCharacterStyle(characterStyle) -> bool\n"
"\n"
"Begins using the named character style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginCharacterStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginCharacterStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* characterStyle;
        int characterStyleState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_characterStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &characterStyle, &characterStyleState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginCharacterStyle(*characterStyle);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(characterStyle), sipType_wxString, characterStyleState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginCharacterStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndCharacterStyle, "EndCharacterStyle() -> bool\n"
"\n"
"Ends application of a named character style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndCharacterStyle(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndCharacterStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndCharacterStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndCharacterStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginParagraphStyle, "BeginParagraphStyle(paragraphStyle) -> bool\n"
"\n"
"Begins applying the named paragraph style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginParagraphStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginParagraphStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* paragraphStyle;
        int paragraphStyleState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_paragraphStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &paragraphStyle, &paragraphStyleState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginParagraphStyle(*paragraphStyle);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(paragraphStyle), sipType_wxString, paragraphStyleState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginParagraphStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndParagraphStyle, "EndParagraphStyle() -> bool\n"
"\n"
"Ends application of a named paragraph style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndParagraphStyle(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndParagraphStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndParagraphStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndParagraphStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginListStyle, "BeginListStyle(listStyle, level=1, number=1) -> bool\n"
"\n"
"Begins using a specified list style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginListStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginListStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* listStyle;
        int listStyleState = 0;
        int level = 1;
        int number = 1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_listStyle,
            sipName_level,
            sipName_number,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &listStyle, &listStyleState, &level, &number))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginListStyle(*listStyle,level,number);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(listStyle), sipType_wxString, listStyleState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginListStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndListStyle, "EndListStyle() -> bool\n"
"\n"
"Ends using a specified list style.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndListStyle(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndListStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndListStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndListStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginURL, "BeginURL(url, characterStyle=wx.EmptyString) -> bool\n"
"\n"
"Begins applying wxTEXT_ATTR_URL to the content.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginURL(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginURL(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* url;
        int urlState = 0;
        const  ::wxString& characterStyledef = wxEmptyString;
        const  ::wxString* characterStyle = &characterStyledef;
        int characterStyleState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_url,
            sipName_characterStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|J1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &url, &urlState, sipType_wxString, &characterStyle, &characterStyleState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginURL(*url,*characterStyle);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(url), sipType_wxString, urlState);
            sipReleaseType(const_cast< ::wxString *>(characterStyle), sipType_wxString, characterStyleState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginURL, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndURL, "EndURL() -> bool\n"
"\n"
"Ends applying a URL.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndURL(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndURL(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndURL();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndURL, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDefaultStyleToCursorStyle, "SetDefaultStyleToCursorStyle() -> bool\n"
"\n"
"Sets the default style to the style under the cursor.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDefaultStyleToCursorStyle(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDefaultStyleToCursorStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetDefaultStyleToCursorStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDefaultStyleToCursorStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SelectNone, "SelectNone()\n"
"\n"
"Cancels any selection.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SelectNone(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SelectNone(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SelectNone();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SelectNone, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SelectWord, "SelectWord(position) -> bool\n"
"\n"
"Selects the word at the given character position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SelectWord(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SelectWord(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long position;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SelectWord(position);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SelectWord, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetSelectionRange, "GetSelectionRange() -> RichTextRange\n"
"\n"
"Returns the selection range in character positions.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetSelectionRange(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetSelectionRange(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextRange*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRichTextRange(sipCpp->GetSelectionRange());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRichTextRange,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetSelectionRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetSelectionRange, "SetSelectionRange(range)\n"
"\n"
"Sets the selection to the given range.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetSelectionRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetSelectionRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionRange(*range);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetSelectionRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetInternalSelectionRange, "GetInternalSelectionRange() -> RichTextRange\n"
"\n"
"Returns the selection range in character positions.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetInternalSelectionRange(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetInternalSelectionRange(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextRange*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRichTextRange(sipCpp->GetInternalSelectionRange());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRichTextRange,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetInternalSelectionRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetInternalSelectionRange, "SetInternalSelectionRange(range)\n"
"\n"
"Sets the selection range in character positions.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetInternalSelectionRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetInternalSelectionRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetInternalSelectionRange(*range);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetInternalSelectionRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AddParagraph, "AddParagraph(text) -> RichTextRange\n"
"\n"
"Adds a new paragraph of text to the end of the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_AddParagraph(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AddParagraph(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
             ::wxRichTextRange*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRichTextRange(sipCpp->AddParagraph(*text));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRichTextRange,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AddParagraph, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AddImage, "AddImage(image) -> RichTextRange\n"
"\n"
"Adds an image to the control's buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_AddImage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AddImage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxImage* image;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_image,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxImage, &image))
        {
             ::wxRichTextRange*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRichTextRange(sipCpp->AddImage(*image));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRichTextRange,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AddImage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_LayoutContent, "LayoutContent(onlyVisibleRect=False) -> bool\n"
"\n"
"Lays out the buffer, which must be done before certain operations,\n"
"such as setting the caret position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_LayoutContent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_LayoutContent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool onlyVisibleRect = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_onlyVisibleRect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &onlyVisibleRect))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LayoutContent(onlyVisibleRect);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_LayoutContent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoLayoutBuffer, "DoLayoutBuffer(buffer, dc, context, rect, parentRect, flags)\n"
"\n"
"Implements layout.");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoLayoutBuffer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoLayoutBuffer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextBuffer* buffer;
         ::wxDC* dc;
         ::wxRichTextDrawingContext* context;
        const  ::wxRect* rect;
        int rectState = 0;
        const  ::wxRect* parentRect;
        int parentRectState = 0;
        int flags;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_buffer,
            sipName_dc,
            sipName_context,
            sipName_rect,
            sipName_parentRect,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9J9J1J1i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextBuffer, &buffer, sipType_wxDC, &dc, sipType_wxRichTextDrawingContext, &context, sipType_wxRect, &rect, &rectState, sipType_wxRect, &parentRect, &parentRectState, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DoLayoutBuffer(*buffer,*dc,*context,*rect,*parentRect,flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);
            sipReleaseType(const_cast< ::wxRect *>(parentRect), sipType_wxRect, parentRectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoLayoutBuffer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveCaret, "MoveCaret(pos, showAtLineStart=False, container=None) -> bool\n"
"\n"
"Move the caret to the given character position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveCaret(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveCaret(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long pos;
        bool showAtLineStart = 0;
         ::wxRichTextParagraphLayoutBox* container = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_showAtLineStart,
            sipName_container,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl|bJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pos, &showAtLineStart, sipType_wxRichTextParagraphLayoutBox, &container))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCaret(pos,showAtLineStart,container);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveRight, "MoveRight(noPositions=1, flags=0) -> bool\n"
"\n"
"Moves right.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveRight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveRight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int noPositions = 1;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_noPositions,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &noPositions, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveRight(noPositions,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveLeft, "MoveLeft(noPositions=1, flags=0) -> bool\n"
"\n"
"Moves left.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveLeft(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveLeft(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int noPositions = 1;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_noPositions,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &noPositions, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveLeft(noPositions,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveUp, "MoveUp(noLines=1, flags=0) -> bool\n"
"\n"
"Moves to the start of the paragraph.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveUp(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveUp(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int noLines = 1;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_noLines,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &noLines, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveUp(noLines,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveDown, "MoveDown(noLines=1, flags=0) -> bool\n"
"\n"
"Moves the caret down.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveDown(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveDown(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int noLines = 1;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_noLines,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &noLines, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveDown(noLines,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveToLineEnd, "MoveToLineEnd(flags=0) -> bool\n"
"\n"
"Moves to the end of the line.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveToLineEnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveToLineEnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveToLineEnd(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveToLineEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveToLineStart, "MoveToLineStart(flags=0) -> bool\n"
"\n"
"Moves to the start of the line.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveToLineStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveToLineStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveToLineStart(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveToLineStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveToParagraphEnd, "MoveToParagraphEnd(flags=0) -> bool\n"
"\n"
"Moves to the end of the paragraph.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveToParagraphEnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveToParagraphEnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveToParagraphEnd(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveToParagraphEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveToParagraphStart, "MoveToParagraphStart(flags=0) -> bool\n"
"\n"
"Moves to the start of the paragraph.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveToParagraphStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveToParagraphStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveToParagraphStart(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveToParagraphStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveHome, "MoveHome(flags=0) -> bool\n"
"\n"
"Moves to the start of the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveHome(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveHome(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveHome(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveHome, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveEnd, "MoveEnd(flags=0) -> bool\n"
"\n"
"Moves to the end of the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveEnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveEnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveEnd(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PageUp, "PageUp(noPages=1, flags=0) -> bool\n"
"\n"
"Moves one or more pages up.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PageUp(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PageUp(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int noPages = 1;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_noPages,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &noPages, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PageUp(noPages,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PageUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PageDown, "PageDown(noPages=1, flags=0) -> bool\n"
"\n"
"Moves one or more pages down.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PageDown(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PageDown(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int noPages = 1;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_noPages,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &noPages, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PageDown(noPages,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PageDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_WordLeft, "WordLeft(noPages=1, flags=0) -> bool\n"
"\n"
"Moves a number of words to the left.");

extern "C" {static PyObject *meth_wxRichTextCtrl_WordLeft(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_WordLeft(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int noPages = 1;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_noPages,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &noPages, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WordLeft(noPages,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_WordLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_WordRight, "WordRight(noPages=1, flags=0) -> bool\n"
"\n"
"Move a number of words to the right.");

extern "C" {static PyObject *meth_wxRichTextCtrl_WordRight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_WordRight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int noPages = 1;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_noPages,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &noPages, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WordRight(noPages,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_WordRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginBatchUndo, "BeginBatchUndo(cmdName) -> bool\n"
"\n"
"Starts batching undo history for commands.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginBatchUndo(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginBatchUndo(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* cmdName;
        int cmdNameState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cmdName,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &cmdName, &cmdNameState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginBatchUndo(*cmdName);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(cmdName), sipType_wxString, cmdNameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginBatchUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndBatchUndo, "EndBatchUndo() -> bool\n"
"\n"
"Ends batching undo command history.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndBatchUndo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndBatchUndo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndBatchUndo();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndBatchUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BatchingUndo, "BatchingUndo() -> bool\n"
"\n"
"Returns true if undo commands are being batched.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BatchingUndo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BatchingUndo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BatchingUndo();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BatchingUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_BeginSuppressUndo, "BeginSuppressUndo() -> bool\n"
"\n"
"Starts suppressing undo history for commands.");

extern "C" {static PyObject *meth_wxRichTextCtrl_BeginSuppressUndo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_BeginSuppressUndo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginSuppressUndo();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_BeginSuppressUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EndSuppressUndo, "EndSuppressUndo() -> bool\n"
"\n"
"Ends suppressing undo command history.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EndSuppressUndo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EndSuppressUndo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EndSuppressUndo();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EndSuppressUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SuppressingUndo, "SuppressingUndo() -> bool\n"
"\n"
"Returns true if undo history suppression is on.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SuppressingUndo(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SuppressingUndo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SuppressingUndo();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SuppressingUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_HasCharacterAttributes, "HasCharacterAttributes(range, style) -> bool\n"
"\n"
"Test if this whole range has character attributes of the specified\n"
"kind.");

extern "C" {static PyObject *meth_wxRichTextCtrl_HasCharacterAttributes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_HasCharacterAttributes(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxRichTextAttr* style;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasCharacterAttributes(*range,*style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_HasCharacterAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_HasParagraphAttributes, "HasParagraphAttributes(range, style) -> bool\n"
"\n"
"Test if this whole range has paragraph attributes of the specified\n"
"kind.");

extern "C" {static PyObject *meth_wxRichTextCtrl_HasParagraphAttributes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_HasParagraphAttributes(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxRichTextAttr* style;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_range,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextRange, &range, &rangeState, sipType_wxRichTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasParagraphAttributes(*range,*style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_HasParagraphAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsSelectionBold, "IsSelectionBold() -> bool\n"
"\n"
"Returns true if all of the selection, or the content at the caret\n"
"position, is bold.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsSelectionBold(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsSelectionBold(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsSelectionBold();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsSelectionBold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsSelectionItalics, "IsSelectionItalics() -> bool\n"
"\n"
"Returns true if all of the selection, or the content at the caret\n"
"position, is italic.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsSelectionItalics(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsSelectionItalics(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsSelectionItalics();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsSelectionItalics, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsSelectionUnderlined, "IsSelectionUnderlined() -> bool\n"
"\n"
"Returns true if all of the selection, or the content at the caret\n"
"position, is underlined.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsSelectionUnderlined(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsSelectionUnderlined(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsSelectionUnderlined();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsSelectionUnderlined, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoesSelectionHaveTextEffectFlag, "DoesSelectionHaveTextEffectFlag(flag) -> bool\n"
"\n"
"Returns true if all of the selection, or the content at the current\n"
"caret position, has the supplied wxTextAttrEffects flag(s).");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoesSelectionHaveTextEffectFlag(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoesSelectionHaveTextEffectFlag(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flag;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flag,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flag))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DoesSelectionHaveTextEffectFlag(flag);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoesSelectionHaveTextEffectFlag, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsSelectionAligned, "IsSelectionAligned(alignment) -> bool\n"
"\n"
"Returns true if all of the selection is aligned according to the\n"
"specified flag.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsSelectionAligned(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsSelectionAligned(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxTextAttrAlignment alignment;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alignment,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxTextAttrAlignment, &alignment))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsSelectionAligned(alignment);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsSelectionAligned, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ApplyBoldToSelection, "ApplyBoldToSelection() -> bool\n"
"\n"
"Apples bold to the selection or the default style (undoable).");

extern "C" {static PyObject *meth_wxRichTextCtrl_ApplyBoldToSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ApplyBoldToSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ApplyBoldToSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ApplyBoldToSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ApplyItalicToSelection, "ApplyItalicToSelection() -> bool\n"
"\n"
"Applies italic to the selection or the default style (undoable).");

extern "C" {static PyObject *meth_wxRichTextCtrl_ApplyItalicToSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ApplyItalicToSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ApplyItalicToSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ApplyItalicToSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ApplyUnderlineToSelection, "ApplyUnderlineToSelection() -> bool\n"
"\n"
"Applies underline to the selection or the default style (undoable).");

extern "C" {static PyObject *meth_wxRichTextCtrl_ApplyUnderlineToSelection(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ApplyUnderlineToSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ApplyUnderlineToSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ApplyUnderlineToSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ApplyTextEffectToSelection, "ApplyTextEffectToSelection(flags) -> bool\n"
"\n"
"Applies one or more wxTextAttrEffects flags to the selection\n"
"(undoable).");

extern "C" {static PyObject *meth_wxRichTextCtrl_ApplyTextEffectToSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ApplyTextEffectToSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ApplyTextEffectToSelection(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ApplyTextEffectToSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ApplyAlignmentToSelection, "ApplyAlignmentToSelection(alignment) -> bool\n"
"\n"
"Applies the given alignment to the selection or the default style\n"
"(undoable).");

extern "C" {static PyObject *meth_wxRichTextCtrl_ApplyAlignmentToSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ApplyAlignmentToSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxTextAttrAlignment alignment;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alignment,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxTextAttrAlignment, &alignment))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ApplyAlignmentToSelection(alignment);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ApplyAlignmentToSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ApplyStyle, "ApplyStyle(styleDef) -> bool\n"
"\n"
"Applies the style sheet to the buffer, matching paragraph styles in\n"
"the sheet against named styles in the buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ApplyStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ApplyStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextStyleDefinition* styleDef;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleDef,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextStyleDefinition, &styleDef))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ApplyStyle(styleDef);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ApplyStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetStyleSheet, "SetStyleSheet(styleSheet)\n"
"\n"
"Sets the style sheet associated with the control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetStyleSheet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetStyleSheet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextStyleSheet* styleSheet;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleSheet,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextStyleSheet, &styleSheet))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetStyleSheet(styleSheet);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetStyleSheet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetStyleSheet, "GetStyleSheet() -> RichTextStyleSheet\n"
"\n"
"Returns the style sheet associated with the control, if any.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetStyleSheet(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetStyleSheet(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextStyleSheet*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyleSheet();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextStyleSheet,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetStyleSheet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PushStyleSheet, "PushStyleSheet(styleSheet) -> bool\n"
"\n"
"Push the style sheet to top of stack.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PushStyleSheet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PushStyleSheet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextStyleSheet* styleSheet;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleSheet,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextStyleSheet, &styleSheet))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PushStyleSheet(styleSheet);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PushStyleSheet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PopStyleSheet, "PopStyleSheet() -> RichTextStyleSheet\n"
"\n"
"Pops the style sheet from top of stack.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PopStyleSheet(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PopStyleSheet(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxRichTextStyleSheet*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PopStyleSheet();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextStyleSheet,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PopStyleSheet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ApplyStyleSheet, "ApplyStyleSheet(styleSheet=None) -> bool\n"
"\n"
"Applies the style sheet to the buffer, for example if the styles have\n"
"changed.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ApplyStyleSheet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ApplyStyleSheet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextStyleSheet* styleSheet = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleSheet,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextStyleSheet, &styleSheet))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ApplyStyleSheet(styleSheet);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ApplyStyleSheet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ShowContextMenu, "ShowContextMenu(menu, pt, addPropertyCommands) -> bool\n"
"\n"
"Shows the given context menu, optionally adding appropriate property-\n"
"editing commands for the current position in the object hierarchy.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ShowContextMenu(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ShowContextMenu(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMenu* menu;
        const  ::wxPoint* pt;
        int ptState = 0;
        bool addPropertyCommands;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menu,
            sipName_pt,
            sipName_addPropertyCommands,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J1b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMenu, &menu, sipType_wxPoint, &pt, &ptState, &addPropertyCommands))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ShowContextMenu(menu,*pt,addPropertyCommands);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ShowContextMenu, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PrepareContextMenu, "PrepareContextMenu(menu, pt, addPropertyCommands) -> int\n"
"\n"
"Prepares the context menu, optionally adding appropriate property-\n"
"editing commands.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PrepareContextMenu(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PrepareContextMenu(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMenu* menu;
        const  ::wxPoint* pt;
        int ptState = 0;
        bool addPropertyCommands;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menu,
            sipName_pt,
            sipName_addPropertyCommands,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J1b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMenu, &menu, sipType_wxPoint, &pt, &ptState, &addPropertyCommands))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrepareContextMenu(menu,*pt,addPropertyCommands);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PrepareContextMenu, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanEditProperties, "CanEditProperties(obj) -> bool\n"
"\n"
"Returns true if we can edit the object's properties via a GUI.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanEditProperties(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanEditProperties(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextObject* obj;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_obj,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextObject, &obj))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanEditProperties(obj);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanEditProperties, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EditProperties, "EditProperties(obj, parent) -> bool\n"
"\n"
"Edits the object's properties via a GUI.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EditProperties(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EditProperties(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextObject* obj;
         ::wxWindow* parent;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_obj,
            sipName_parent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextObject, &obj, sipType_wxWindow, &parent))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EditProperties(obj,parent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EditProperties, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetPropertiesMenuLabel, "GetPropertiesMenuLabel(obj) -> String\n"
"\n"
"Gets the object's properties menu label.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetPropertiesMenuLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetPropertiesMenuLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextObject* obj;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_obj,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextObject, &obj))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetPropertiesMenuLabel(obj));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetPropertiesMenuLabel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PrepareContent, "PrepareContent(container)\n"
"\n"
"Prepares the content just before insertion (or after buffer reset).");

extern "C" {static PyObject *meth_wxRichTextCtrl_PrepareContent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PrepareContent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextParagraphLayoutBox* container;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_container,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextParagraphLayoutBox, &container))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PrepareContent(*container);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PrepareContent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanDeleteRange, "CanDeleteRange(container, range) -> bool\n"
"\n"
"Can we delete this range? Sends an event to the control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanDeleteRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanDeleteRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextParagraphLayoutBox* container;
        const  ::wxRichTextRange* range;
        int rangeState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_container,
            sipName_range,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextParagraphLayoutBox, &container, sipType_wxRichTextRange, &range, &rangeState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDeleteRange(*container,*range);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRichTextRange *>(range), sipType_wxRichTextRange, rangeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanDeleteRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_CanInsertContent, "CanInsertContent(container, pos) -> bool\n"
"\n"
"Can we insert content at this position? Sends an event to the control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_CanInsertContent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_CanInsertContent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextParagraphLayoutBox* container;
        long pos;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_container,
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9l", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextParagraphLayoutBox, &container, &pos))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanInsertContent(*container,pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_CanInsertContent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EnableVerticalScrollbar, "EnableVerticalScrollbar(enable)\n"
"\n"
"Enable or disable the vertical scrollbar.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EnableVerticalScrollbar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EnableVerticalScrollbar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableVerticalScrollbar(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EnableVerticalScrollbar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetVerticalScrollbarEnabled, "GetVerticalScrollbarEnabled() -> bool\n"
"\n"
"Returns true if the vertical scrollbar is enabled.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetVerticalScrollbarEnabled(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetVerticalScrollbarEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetVerticalScrollbarEnabled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetVerticalScrollbarEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetFontScale, "SetFontScale(fontScale, refresh=False)\n"
"\n"
"Sets the scale factor for displaying fonts, for example for more\n"
"comfortable editing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetFontScale(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetFontScale(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        double fontScale;
        bool refresh = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fontScale,
            sipName_refresh,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bd|b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &fontScale, &refresh))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFontScale(fontScale,refresh);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetFontScale, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetFontScale, "GetFontScale() -> double\n"
"\n"
"Returns the scale factor for displaying fonts, for example for more\n"
"comfortable editing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetFontScale(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetFontScale(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            double sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFontScale();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyFloat_FromDouble(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetFontScale, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDimensionScale, "SetDimensionScale(dimScale, refresh=False)\n"
"\n"
"Sets the scale factor for displaying certain dimensions such as\n"
"indentation and inter-paragraph spacing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDimensionScale(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDimensionScale(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        double dimScale;
        bool refresh = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dimScale,
            sipName_refresh,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bd|b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &dimScale, &refresh))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDimensionScale(dimScale,refresh);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDimensionScale, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDimensionScale, "GetDimensionScale() -> double\n"
"\n"
"Returns the scale factor for displaying certain dimensions such as\n"
"indentation and inter-paragraph spacing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDimensionScale(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDimensionScale(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            double sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDimensionScale();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyFloat_FromDouble(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDimensionScale, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetScale, "SetScale(scale, refresh=False)\n"
"\n"
"Sets an overall scale factor for displaying and editing the content.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetScale(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetScale(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        double scale;
        bool refresh = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_scale,
            sipName_refresh,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bd|b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &scale, &refresh))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetScale(scale,refresh);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetScale, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetScale, "GetScale() -> double\n"
"\n"
"Returns an overall scale factor for displaying and editing the\n"
"content.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetScale(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetScale(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            double sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetScale();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyFloat_FromDouble(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetScale, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetUnscaledPoint, "GetUnscaledPoint(pt) -> wx.Point\n"
"\n"
"Returns an unscaled point.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetUnscaledPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetUnscaledPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetUnscaledPoint(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetUnscaledPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetScaledPoint, "GetScaledPoint(pt) -> wx.Point\n"
"\n"
"Returns a scaled point.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetScaledPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetScaledPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetScaledPoint(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetScaledPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetUnscaledSize, "GetUnscaledSize(sz) -> wx.Size\n"
"\n"
"Returns an unscaled size.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetUnscaledSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetUnscaledSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxSize, &sz, &szState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetUnscaledSize(*sz));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetUnscaledSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetScaledSize, "GetScaledSize(sz) -> wx.Size\n"
"\n"
"Returns a scaled size.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetScaledSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetScaledSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxSize, &sz, &szState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetScaledSize(*sz));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetScaledSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetUnscaledRect, "GetUnscaledRect(rect) -> wx.Rect\n"
"\n"
"Returns an unscaled rectangle.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetUnscaledRect(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetUnscaledRect(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRect* rect;
        int rectState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRect, &rect, &rectState))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->GetUnscaledRect(*rect));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetUnscaledRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetScaledRect, "GetScaledRect(rect) -> wx.Rect\n"
"\n"
"Returns a scaled rectangle.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetScaledRect(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetScaledRect(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRect* rect;
        int rectState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRect, &rect, &rectState))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->GetScaledRect(*rect));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetScaledRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetVirtualAttributesEnabled, "GetVirtualAttributesEnabled() -> bool\n"
"\n"
"Returns true if this control can use virtual attributes and virtual\n"
"text.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetVirtualAttributesEnabled(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetVirtualAttributesEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetVirtualAttributesEnabled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetVirtualAttributesEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EnableVirtualAttributes, "EnableVirtualAttributes(b)\n"
"\n"
"Pass true to let the control use virtual attributes.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EnableVirtualAttributes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EnableVirtualAttributes(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool b;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_b,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &b))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableVirtualAttributes(b);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EnableVirtualAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Command, "Command(event)\n"
"\n"
"Sends the event to the control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_Command(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Command(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Command(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Command, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnDropFiles, "OnDropFiles(event)\n"
"\n"
"Loads the first dropped file.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnDropFiles(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnDropFiles(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDropFilesEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxDropFilesEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnDropFiles(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnDropFiles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnCaptureLost, "OnCaptureLost(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnCaptureLost(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnCaptureLost(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMouseCaptureLostEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMouseCaptureLostEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnCaptureLost(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnCaptureLost, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnSysColourChanged, "OnSysColourChanged(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnSysColourChanged(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnSysColourChanged(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSysColourChangedEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxSysColourChangedEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnSysColourChanged(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnSysColourChanged, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnCut, "OnCut(event)\n"
"\n"
"Standard handler for the wxID_CUT command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnCut(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnCut(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnCut(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnCut, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnCopy, "OnCopy(event)\n"
"\n"
"Standard handler for the wxID_COPY command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnCopy(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnCopy(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnCopy(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnCopy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnPaste, "OnPaste(event)\n"
"\n"
"Standard handler for the wxID_PASTE command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnPaste(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnPaste(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnPaste(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnPaste, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUndo, "OnUndo(event)\n"
"\n"
"Standard handler for the wxID_UNDO command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUndo(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUndo(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUndo(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnRedo, "OnRedo(event)\n"
"\n"
"Standard handler for the wxID_REDO command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnRedo(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnRedo(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnRedo(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnRedo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnSelectAll, "OnSelectAll(event)\n"
"\n"
"Standard handler for the wxID_SELECTALL command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnSelectAll(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnSelectAll(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnSelectAll(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnSelectAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnProperties, "OnProperties(event)\n"
"\n"
"Standard handler for property commands.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnProperties(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnProperties(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnProperties(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnProperties, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnClear, "OnClear(event)\n"
"\n"
"Standard handler for the wxID_CLEAR command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnClear(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnClear(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCommandEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxCommandEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnClear(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnClear, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUpdateCut, "OnUpdateCut(event)\n"
"\n"
"Standard update handler for the wxID_CUT command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUpdateCut(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUpdateCut(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUpdateCut(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUpdateCut, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUpdateCopy, "OnUpdateCopy(event)\n"
"\n"
"Standard update handler for the wxID_COPY command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUpdateCopy(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUpdateCopy(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUpdateCopy(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUpdateCopy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUpdatePaste, "OnUpdatePaste(event)\n"
"\n"
"Standard update handler for the wxID_PASTE command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUpdatePaste(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUpdatePaste(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUpdatePaste(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUpdatePaste, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUpdateUndo, "OnUpdateUndo(event)\n"
"\n"
"Standard update handler for the wxID_UNDO command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUpdateUndo(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUpdateUndo(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUpdateUndo(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUpdateUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUpdateRedo, "OnUpdateRedo(event)\n"
"\n"
"Standard update handler for the wxID_REDO command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUpdateRedo(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUpdateRedo(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUpdateRedo(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUpdateRedo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUpdateSelectAll, "OnUpdateSelectAll(event)\n"
"\n"
"Standard update handler for the wxID_SELECTALL command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUpdateSelectAll(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUpdateSelectAll(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUpdateSelectAll(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUpdateSelectAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUpdateProperties, "OnUpdateProperties(event)\n"
"\n"
"Standard update handler for property commands.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUpdateProperties(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUpdateProperties(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUpdateProperties(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUpdateProperties, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnUpdateClear, "OnUpdateClear(event)\n"
"\n"
"Standard update handler for the wxID_CLEAR command.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnUpdateClear(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnUpdateClear(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnUpdateClear(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnUpdateClear, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnContextMenu, "OnContextMenu(event)\n"
"\n"
"Shows a standard context menu with undo, redo, cut, copy, paste,\n"
"clear, and select all commands.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnContextMenu(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnContextMenu(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxContextMenuEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxContextMenuEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnContextMenu(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnContextMenu, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnPaint, "OnPaint(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnPaint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnPaint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxPaintEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPaintEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnPaint(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnPaint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnEraseBackground, "OnEraseBackground(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnEraseBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnEraseBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEraseEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxEraseEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnEraseBackground(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnEraseBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnLeftClick, "OnLeftClick(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnLeftClick(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnLeftClick(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMouseEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMouseEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnLeftClick(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnLeftClick, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnLeftUp, "OnLeftUp(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnLeftUp(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnLeftUp(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMouseEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMouseEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnLeftUp(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnLeftUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnMoveMouse, "OnMoveMouse(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnMoveMouse(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnMoveMouse(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMouseEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMouseEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnMoveMouse(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnMoveMouse, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnLeftDClick, "OnLeftDClick(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnLeftDClick(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnLeftDClick(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMouseEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMouseEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnLeftDClick(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnLeftDClick, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnMiddleClick, "OnMiddleClick(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnMiddleClick(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnMiddleClick(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMouseEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMouseEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnMiddleClick(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnMiddleClick, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnRightClick, "OnRightClick(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnRightClick(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnRightClick(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMouseEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxMouseEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnRightClick(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnRightClick, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnChar, "OnChar(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnChar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnChar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxKeyEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxKeyEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnChar(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnChar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnSize, "OnSize(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSizeEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxSizeEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnSize(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnSetFocus, "OnSetFocus(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnSetFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnSetFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFocusEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxFocusEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnSetFocus(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnSetFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnKillFocus, "OnKillFocus(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnKillFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnKillFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFocusEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxFocusEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnKillFocus(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnKillFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnIdle, "OnIdle(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnIdle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnIdle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxIdleEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxIdleEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnIdle(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnIdle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnScroll, "OnScroll(event)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnScroll(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnScroll(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxScrollWinEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxScrollWinEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnScroll(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnScroll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetFont, "SetFont(font) -> bool\n"
"\n"
"Sets the font, and also the basic and default attributes (see\n"
"wxRichTextCtrl::SetDefaultStyle).");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxFont* font;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxFont, &font))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetFont(*font);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetupScrollbars, "SetupScrollbars(atTop=False)\n"
"\n"
"A helper function setting up scrollbars, for example after a resize.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetupScrollbars(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetupScrollbars(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool atTop = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_atTop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &atTop))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetupScrollbars(atTop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetupScrollbars, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_KeyboardNavigate, "KeyboardNavigate(keyCode, flags) -> bool\n"
"\n"
"Helper function implementing keyboard navigation.");

extern "C" {static PyObject *meth_wxRichTextCtrl_KeyboardNavigate(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_KeyboardNavigate(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int keyCode;
        int flags;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_keyCode,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &keyCode, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->KeyboardNavigate(keyCode,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_KeyboardNavigate, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PaintBackground, "PaintBackground(dc)\n"
"\n"
"Paints the background.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PaintBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PaintBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxDC, &dc))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PaintBackground(*dc);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PaintBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PaintAboveContent, "PaintAboveContent(WXUNUSED)\n"
"\n"
"Other user defined painting after everything else (i.e. all text) is\n"
"painted.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PaintAboveContent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PaintAboveContent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* WXUNUSED;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_WXUNUSED,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxDC, &WXUNUSED))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PaintAboveContent(*WXUNUSED);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PaintAboveContent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoWriteText, "DoWriteText(value, flags=0)");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoWriteText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoWriteText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* value;
        int valueState = 0;
        int flags = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_value,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &value, &valueState, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DoWriteText(*value,flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoWriteText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ShouldInheritColours, "ShouldInheritColours() -> bool\n"
"\n"
"Return true from here to allow the colours of this window to be\n"
"changed by InheritAttributes().");

extern "C" {static PyObject *meth_wxRichTextCtrl_ShouldInheritColours(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ShouldInheritColours(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::ShouldInheritColours() : sipCpp->ShouldInheritColours());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ShouldInheritColours, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_PositionCaret, "PositionCaret(container=None)\n"
"\n"
"Internal function to position the visible caret according to the\n"
"current caret position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_PositionCaret(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_PositionCaret(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextParagraphLayoutBox* container = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_container,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextParagraphLayoutBox, &container))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PositionCaret(container);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_PositionCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ExtendSelection, "ExtendSelection(oldPosition, newPosition, flags) -> bool\n"
"\n"
"Helper function for extending the selection, returning true if the\n"
"selection was changed.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ExtendSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ExtendSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long oldPosition;
        long newPosition;
        int flags;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_oldPosition,
            sipName_newPosition,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Blli", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &oldPosition, &newPosition, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ExtendSelection(oldPosition,newPosition,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ExtendSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ExtendCellSelection, "ExtendCellSelection(table, noRowSteps, noColSteps) -> bool\n"
"\n"
"Extends a table selection in the given direction.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ExtendCellSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ExtendCellSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextTable* table;
        int noRowSteps;
        int noColSteps;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_table,
            sipName_noRowSteps,
            sipName_noColSteps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8ii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextTable, &table, &noRowSteps, &noColSteps))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ExtendCellSelection(table,noRowSteps,noColSteps);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ExtendCellSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_StartCellSelection, "StartCellSelection(table, newCell) -> bool\n"
"\n"
"Starts selecting table cells.");

extern "C" {static PyObject *meth_wxRichTextCtrl_StartCellSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_StartCellSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextTable* table;
         ::wxRichTextParagraphLayoutBox* newCell;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_table,
            sipName_newCell,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextTable, &table, sipType_wxRichTextParagraphLayoutBox, &newCell))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StartCellSelection(table,newCell);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_StartCellSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ScrollIntoView, "ScrollIntoView(position, keyCode) -> bool\n"
"\n"
"Scrolls position into view.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ScrollIntoView(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ScrollIntoView(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long position;
        int keyCode;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_keyCode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bli", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, &keyCode))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ScrollIntoView(position,keyCode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ScrollIntoView, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_RefreshForSelectionChange, "RefreshForSelectionChange(oldSelection, newSelection) -> bool\n"
"\n"
"Refreshes the area affected by a selection change.");

extern "C" {static PyObject *meth_wxRichTextCtrl_RefreshForSelectionChange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_RefreshForSelectionChange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextSelection* oldSelection;
        const  ::wxRichTextSelection* newSelection;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_oldSelection,
            sipName_newSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextSelection, &oldSelection, sipType_wxRichTextSelection, &newSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->RefreshForSelectionChange(*oldSelection,*newSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_RefreshForSelectionChange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetCaretPosition, "SetCaretPosition(position, showAtLineStart=False)\n"
"\n"
"Sets the caret position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetCaretPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetCaretPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long position;
        bool showAtLineStart = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_showAtLineStart,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl|b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, &showAtLineStart))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretPosition(position,showAtLineStart);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetCaretPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetCaretPosition, "GetCaretPosition() -> long\n"
"\n"
"Returns the current caret position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetCaretPosition(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetCaretPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretPosition();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetCaretPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetAdjustedCaretPosition, "GetAdjustedCaretPosition(caretPos) -> long\n"
"\n"
"The adjusted caret position is the character position adjusted to take\n"
"into account whether we're at the start of a paragraph, in which case\n"
"style information should be taken from the next position, not current\n"
"one.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetAdjustedCaretPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetAdjustedCaretPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long caretPos;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caretPos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &caretPos))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAdjustedCaretPosition(caretPos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetAdjustedCaretPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveCaretForward, "MoveCaretForward(oldPosition)\n"
"\n"
"Move the caret one visual step forward: this may mean setting a flag\n"
"and keeping the same position if we're going from the end of one line\n"
"to the start of the next, which may be the exact same caret position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveCaretForward(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveCaretForward(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long oldPosition;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_oldPosition,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &oldPosition))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MoveCaretForward(oldPosition);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveCaretForward, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_MoveCaretBack, "MoveCaretBack(oldPosition)\n"
"\n"
"Move the caret one visual step forward: this may mean setting a flag\n"
"and keeping the same position if we're going from the end of one line\n"
"to the start of the next, which may be the exact same caret position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_MoveCaretBack(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_MoveCaretBack(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long oldPosition;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_oldPosition,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &oldPosition))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MoveCaretBack(oldPosition);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_MoveCaretBack, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetCaretPositionForIndex, "GetCaretPositionForIndex(position, rect, container=None) -> bool\n"
"\n"
"Returns the caret height and position for the given character\n"
"position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetCaretPositionForIndex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetCaretPositionForIndex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long position;
         ::wxRect* rect;
        int rectState = 0;
         ::wxRichTextParagraphLayoutBox* container = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_rect,
            sipName_container,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BlJ1|J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, sipType_wxRect, &rect, &rectState, sipType_wxRichTextParagraphLayoutBox, &container))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretPositionForIndex(position,*rect,container);
            Py_END_ALLOW_THREADS
            sipReleaseType(rect, sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetCaretPositionForIndex, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetVisibleLineForCaretPosition, "GetVisibleLineForCaretPosition(caretPosition) -> RichTextLine\n"
"\n"
"Internal helper function returning the line for the visible caret\n"
"position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetVisibleLineForCaretPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetVisibleLineForCaretPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long caretPosition;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caretPosition,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &caretPosition))
        {
             ::wxRichTextLine*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetVisibleLineForCaretPosition(caretPosition);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxRichTextLine,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetVisibleLineForCaretPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetCommandProcessor, "GetCommandProcessor() -> wx.CommandProcessor\n"
"\n"
"Gets the command processor associated with the control's buffer.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetCommandProcessor(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetCommandProcessor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxCommandProcessor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCommandProcessor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxCommandProcessor,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetCommandProcessor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DeleteSelectedContent, "DeleteSelectedContent(newPos=None) -> bool\n"
"\n"
"Deletes content if there is a selection, e.g.");

extern "C" {static PyObject *meth_wxRichTextCtrl_DeleteSelectedContent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DeleteSelectedContent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long newPos;
         ::wxRichTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DeleteSelectedContent(&newPos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(bl)",sipRes,newPos);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DeleteSelectedContent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetPhysicalPoint, "GetPhysicalPoint(ptLogical) -> wx.Point\n"
"\n"
"Transforms logical (unscrolled) position to physical window position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetPhysicalPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetPhysicalPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* ptLogical;
        int ptLogicalState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_ptLogical,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &ptLogical, &ptLogicalState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetPhysicalPoint(*ptLogical));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(ptLogical), sipType_wxPoint, ptLogicalState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetPhysicalPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetLogicalPoint, "GetLogicalPoint(ptPhysical) -> wx.Point\n"
"\n"
"Transforms physical window position to logical (unscrolled) position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetLogicalPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetLogicalPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* ptPhysical;
        int ptPhysicalState = 0;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_ptPhysical,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &ptPhysical, &ptPhysicalState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetLogicalPoint(*ptPhysical));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(ptPhysical), sipType_wxPoint, ptPhysicalState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetLogicalPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_FindNextWordPosition, "FindNextWordPosition(direction=1) -> long\n"
"\n"
"Helper function for finding the caret position for the next word.");

extern "C" {static PyObject *meth_wxRichTextCtrl_FindNextWordPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_FindNextWordPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int direction = 1;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_direction,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &direction))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindNextWordPosition(direction);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_FindNextWordPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsPositionVisible, "IsPositionVisible(pos) -> bool\n"
"\n"
"Returns true if the given position is visible on the screen.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsPositionVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsPositionVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long pos;
        const  ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pos))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsPositionVisible(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsPositionVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetFirstVisiblePosition, "GetFirstVisiblePosition() -> long\n"
"\n"
"Returns the first visible position in the current view.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetFirstVisiblePosition(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetFirstVisiblePosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFirstVisiblePosition();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetFirstVisiblePosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EnableImages, "EnableImages(b)\n"
"\n"
"Enable or disable images.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EnableImages(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EnableImages(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool b;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_b,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &b))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableImages(b);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EnableImages, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetImagesEnabled, "GetImagesEnabled() -> bool\n"
"\n"
"Returns true if images are enabled.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetImagesEnabled(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetImagesEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetImagesEnabled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetImagesEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EnableDelayedImageLoading, "EnableDelayedImageLoading(b)\n"
"\n"
"Enable or disable delayed image loading.");

extern "C" {static PyObject *meth_wxRichTextCtrl_EnableDelayedImageLoading(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EnableDelayedImageLoading(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool b;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_b,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &b))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableDelayedImageLoading(b);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EnableDelayedImageLoading, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDelayedImageLoading, "GetDelayedImageLoading() -> bool\n"
"\n"
"Returns true if delayed image loading is enabled.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDelayedImageLoading(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDelayedImageLoading(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDelayedImageLoading();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDelayedImageLoading, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDelayedImageProcessingRequired, "GetDelayedImageProcessingRequired() -> bool\n"
"\n"
"Gets the flag indicating that delayed image processing is required.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDelayedImageProcessingRequired(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDelayedImageProcessingRequired(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDelayedImageProcessingRequired();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDelayedImageProcessingRequired, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDelayedImageProcessingRequired, "SetDelayedImageProcessingRequired(b)\n"
"\n"
"Sets the flag indicating that delayed image processing is required.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDelayedImageProcessingRequired(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDelayedImageProcessingRequired(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool b;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_b,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &b))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDelayedImageProcessingRequired(b);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDelayedImageProcessingRequired, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDelayedImageProcessingTime, "GetDelayedImageProcessingTime() -> LongLong\n"
"\n"
"Returns the last time delayed image processing was performed.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDelayedImageProcessingTime(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDelayedImageProcessingTime(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxLongLong*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxLongLong(sipCpp->GetDelayedImageProcessingTime());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxLongLong,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDelayedImageProcessingTime, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetDelayedImageProcessingTime, "SetDelayedImageProcessingTime(t)\n"
"\n"
"Sets the last time delayed image processing was performed.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetDelayedImageProcessingTime(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetDelayedImageProcessingTime(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxLongLong* t;
        int tState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_t,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxLongLong, &t, &tState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDelayedImageProcessingTime(*t);
            Py_END_ALLOW_THREADS
            sipReleaseType(t, sipType_wxLongLong, tState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetDelayedImageProcessingTime, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetCaretPositionForDefaultStyle, "GetCaretPositionForDefaultStyle() -> long\n"
"\n"
"Returns the caret position since the default formatting was changed.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetCaretPositionForDefaultStyle(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetCaretPositionForDefaultStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretPositionForDefaultStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetCaretPositionForDefaultStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetCaretPositionForDefaultStyle, "SetCaretPositionForDefaultStyle(pos)\n"
"\n"
"Set the caret position for the default style that the user is\n"
"selecting.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetCaretPositionForDefaultStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetCaretPositionForDefaultStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long pos;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pos))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretPositionForDefaultStyle(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetCaretPositionForDefaultStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsDefaultStyleShowing, "IsDefaultStyleShowing() -> bool\n"
"\n"
"Returns true if the user has recently set the default style without\n"
"moving the caret, and therefore the UI needs to reflect the default\n"
"style and not the style at the caret.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsDefaultStyleShowing(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsDefaultStyleShowing(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsDefaultStyleShowing();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsDefaultStyleShowing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetAndShowDefaultStyle, "SetAndShowDefaultStyle(attr)\n"
"\n"
"Sets attr as the default style and tells the control that the UI\n"
"should reflect this attribute until the user moves the caret.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetAndShowDefaultStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetAndShowDefaultStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextAttr* attr;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_attr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextAttr, &attr))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAndShowDefaultStyle(*attr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetAndShowDefaultStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetFirstVisiblePoint, "GetFirstVisiblePoint() -> wx.Point\n"
"\n"
"Returns the first visible point in the window.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetFirstVisiblePoint(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetFirstVisiblePoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetFirstVisiblePoint());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetFirstVisiblePoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetValue, "GetValue() -> String\n"
"\n"
"Returns the content of the entire control as a string.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetValue(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetValue());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetValue, "SetValue(value)\n"
"\n"
"Replaces existing content with the given text.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* value;
        int valueState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetValue(*value);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ProcessBackKey, "ProcessBackKey(event, flags) -> bool\n"
"\n"
"Processes the back key.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ProcessBackKey(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ProcessBackKey(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxKeyEvent* event;
        int flags;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxKeyEvent, &event, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ProcessBackKey(*event,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ProcessBackKey, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_FindRangeForList, "FindRangeForList(pos, isNumberedList) -> RichTextRange\n"
"\n"
"Given a character position at which there is a list style, find the\n"
"range encompassing the same list style by looking backwards and\n"
"forwards.");

extern "C" {static PyObject *meth_wxRichTextCtrl_FindRangeForList(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_FindRangeForList(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long pos;
        bool isNumberedList;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &pos))
        {
             ::wxRichTextRange*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRichTextRange(sipCpp->FindRangeForList(pos,isNumberedList));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            PyObject *sipResObj = sipConvertFromNewType(sipRes,sipType_wxRichTextRange,SIP_NULLPTR);
            return sipBuildResult(0,"(Rb)",sipResObj,isNumberedList);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_FindRangeForList, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetCaretPositionAfterClick, "SetCaretPositionAfterClick(container, position, hitTestFlags, extendSelection=False) -> bool\n"
"\n"
"Sets up the caret for the given position and container, after a mouse\n"
"click.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetCaretPositionAfterClick(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetCaretPositionAfterClick(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextParagraphLayoutBox* container;
        long position;
        int hitTestFlags;
        bool extendSelection = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_container,
            sipName_position,
            sipName_hitTestFlags,
            sipName_extendSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8li|b", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextParagraphLayoutBox, &container, &position, &hitTestFlags, &extendSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetCaretPositionAfterClick(container,position,hitTestFlags,extendSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetCaretPositionAfterClick, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_FindCaretPositionForCharacterPosition, "FindCaretPositionForCharacterPosition(position, hitTestFlags, container, caretLineStart) -> long\n"
"\n"
"Find the caret position for the combination of hit-test flags and\n"
"character position.");

extern "C" {static PyObject *meth_wxRichTextCtrl_FindCaretPositionForCharacterPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_FindCaretPositionForCharacterPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long position;
        int hitTestFlags;
         ::wxRichTextParagraphLayoutBox* container;
        bool caretLineStart;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_hitTestFlags,
            sipName_container,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BliJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &position, &hitTestFlags, sipType_wxRichTextParagraphLayoutBox, &container))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindCaretPositionForCharacterPosition(position,hitTestFlags,container,caretLineStart);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(lb)",sipRes,caretLineStart);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_FindCaretPositionForCharacterPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ProcessMouseMovement, "ProcessMouseMovement(container, obj, position, pos) -> bool\n"
"\n"
"Processes mouse movement in order to change the cursor.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ProcessMouseMovement(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ProcessMouseMovement(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextParagraphLayoutBox* container;
         ::wxRichTextObject* obj;
        long position;
        const  ::wxPoint* pos;
        int posState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_container,
            sipName_obj,
            sipName_position,
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J8lJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRichTextParagraphLayoutBox, &container, sipType_wxRichTextObject, &obj, &position, sipType_wxPoint, &pos, &posState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ProcessMouseMovement(container,obj,position,*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ProcessMouseMovement, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoGetValue, "DoGetValue() -> String");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoGetValue(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoGetValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->DoGetValue());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoGetValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ProcessDelayedImageLoading, "ProcessDelayedImageLoading(refresh) -> bool\n"
"ProcessDelayedImageLoading(screenRect, box, loadCount) -> bool\n"
"\n"
"Do delayed image loading and garbage-collect other images.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_ProcessDelayedImageLoading(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ProcessDelayedImageLoading(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool refresh;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_refresh,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &refresh))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ProcessDelayedImageLoading(refresh);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxRect* screenRect;
        int screenRectState = 0;
         ::wxRichTextParagraphLayoutBox* box;
        int loadCount;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_screenRect,
            sipName_box,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxRect, &screenRect, &screenRectState, sipType_wxRichTextParagraphLayoutBox, &box))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ProcessDelayedImageLoading(*screenRect,box,loadCount);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(screenRect), sipType_wxRect, screenRectState);

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(bi)",sipRes,loadCount);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ProcessDelayedImageLoading, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_RequestDelayedImageProcessing, "RequestDelayedImageProcessing()\n"
"\n"
"Request delayed image processing.");

extern "C" {static PyObject *meth_wxRichTextCtrl_RequestDelayedImageProcessing(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_RequestDelayedImageProcessing(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RequestDelayedImageProcessing();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_RequestDelayedImageProcessing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnTimer, "OnTimer(event)\n"
"\n"
"Respond to timer events.");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnTimer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnTimer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxTimerEvent* event;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxTimerEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->OnTimer(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnTimer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetAvailableFontNames, "GetAvailableFontNames() -> ArrayString\n"
"\n"
"Font names take a long time to retrieve, so cache them (on demand).");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetAvailableFontNames(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetAvailableFontNames(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxArrayString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxArrayString( ::wxRichTextCtrl::GetAvailableFontNames());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxArrayString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetAvailableFontNames, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ClearAvailableFontNames, "ClearAvailableFontNames()\n"
"\n"
"Clears the cache of available font names.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ClearAvailableFontNames(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ClearAvailableFontNames(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
             ::wxRichTextCtrl::ClearAvailableFontNames();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ClearAvailableFontNames, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetClientAreaOrigin, "GetClientAreaOrigin(self) -> Point");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetClientAreaOrigin(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetClientAreaOrigin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint((sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::GetClientAreaOrigin() : sipCpp->GetClientAreaOrigin()));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetClientAreaOrigin, doc_wxRichTextCtrl_GetClientAreaOrigin);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Validate, "Validate(self) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_Validate(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Validate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::Validate() : sipCpp->Validate());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Validate, doc_wxRichTextCtrl_Validate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_TransferDataToWindow, "TransferDataToWindow(self) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_TransferDataToWindow(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_TransferDataToWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::TransferDataToWindow() : sipCpp->TransferDataToWindow());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_TransferDataToWindow, doc_wxRichTextCtrl_TransferDataToWindow);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_TransferDataFromWindow, "TransferDataFromWindow(self) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_TransferDataFromWindow(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_TransferDataFromWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::TransferDataFromWindow() : sipCpp->TransferDataFromWindow());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_TransferDataFromWindow, doc_wxRichTextCtrl_TransferDataFromWindow);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_InitDialog, "InitDialog(self)");

extern "C" {static PyObject *meth_wxRichTextCtrl_InitDialog(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_InitDialog(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::InitDialog() : sipCpp->InitDialog());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_InitDialog, doc_wxRichTextCtrl_InitDialog);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AcceptsFocus, "AcceptsFocus(self) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_AcceptsFocus(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AcceptsFocus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::AcceptsFocus() : sipCpp->AcceptsFocus());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AcceptsFocus, doc_wxRichTextCtrl_AcceptsFocus);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AcceptsFocusRecursively, "AcceptsFocusRecursively(self) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_AcceptsFocusRecursively(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AcceptsFocusRecursively(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::AcceptsFocusRecursively() : sipCpp->AcceptsFocusRecursively());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AcceptsFocusRecursively, doc_wxRichTextCtrl_AcceptsFocusRecursively);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AcceptsFocusFromKeyboard, "AcceptsFocusFromKeyboard(self) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_AcceptsFocusFromKeyboard(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AcceptsFocusFromKeyboard(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::AcceptsFocusFromKeyboard() : sipCpp->AcceptsFocusFromKeyboard());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AcceptsFocusFromKeyboard, doc_wxRichTextCtrl_AcceptsFocusFromKeyboard);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AddChild, "AddChild(self, child: WindowBase)");

extern "C" {static PyObject *meth_wxRichTextCtrl_AddChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AddChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowBase* child;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_child,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxWindowBase, &child))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::AddChild(child) : sipCpp->AddChild(child));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AddChild, doc_wxRichTextCtrl_AddChild);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_RemoveChild, "RemoveChild(self, child: WindowBase)");

extern "C" {static PyObject *meth_wxRichTextCtrl_RemoveChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_RemoveChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowBase* child;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_child,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxWindowBase, &child))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::RemoveChild(child) : sipCpp->RemoveChild(child));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_RemoveChild, doc_wxRichTextCtrl_RemoveChild);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_InheritAttributes, "InheritAttributes(self)");

extern "C" {static PyObject *meth_wxRichTextCtrl_InheritAttributes(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_InheritAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::InheritAttributes() : sipCpp->InheritAttributes());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_InheritAttributes, doc_wxRichTextCtrl_InheritAttributes);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_OnInternalIdle, "OnInternalIdle(self)");

extern "C" {static PyObject *meth_wxRichTextCtrl_OnInternalIdle(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_OnInternalIdle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::OnInternalIdle() : sipCpp->OnInternalIdle());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_OnInternalIdle, doc_wxRichTextCtrl_OnInternalIdle);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetMainWindowOfCompositeControl, "GetMainWindowOfCompositeControl(self) -> Window");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetMainWindowOfCompositeControl(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetMainWindowOfCompositeControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::GetMainWindowOfCompositeControl() : sipCpp->GetMainWindowOfCompositeControl());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetMainWindowOfCompositeControl, doc_wxRichTextCtrl_GetMainWindowOfCompositeControl);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_InformFirstDirection, "InformFirstDirection(self, direction: int, size: int, availableOtherDir: int) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_InformFirstDirection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_InformFirstDirection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int direction;
        int size;
        int availableOtherDir;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_direction,
            sipName_size,
            sipName_availableOtherDir,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &direction, &size, &availableOtherDir))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::InformFirstDirection(direction,size,availableOtherDir) : sipCpp->InformFirstDirection(direction,size,availableOtherDir));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_InformFirstDirection, doc_wxRichTextCtrl_InformFirstDirection);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetCanFocus, "SetCanFocus(self, canFocus: bool)");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetCanFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetCanFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool canFocus;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_canFocus,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &canFocus))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::SetCanFocus(canFocus) : sipCpp->SetCanFocus(canFocus));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetCanFocus, doc_wxRichTextCtrl_SetCanFocus);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_Destroy, "Destroy(self) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_Destroy(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_Destroy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::Destroy() : sipCpp->Destroy());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_Destroy, doc_wxRichTextCtrl_Destroy);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetValidator, "SetValidator(self, validator: Validator)");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetValidator(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetValidator(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxValidator* validator;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_validator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxValidator, &validator))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::SetValidator(*validator) : sipCpp->SetValidator(*validator));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetValidator, doc_wxRichTextCtrl_SetValidator);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetValidator, "GetValidator(self) -> Validator");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetValidator(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetValidator(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxValidator*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::GetValidator() : sipCpp->GetValidator());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxValidator,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetValidator, doc_wxRichTextCtrl_GetValidator);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_EnableVisibleFocus, "EnableVisibleFocus(self, enabled: bool)");

extern "C" {static PyObject *meth_wxRichTextCtrl_EnableVisibleFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_EnableVisibleFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool enabled;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enabled,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &enabled))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxRichTextCtrl::EnableVisibleFocus(enabled) : sipCpp->EnableVisibleFocus(enabled));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_EnableVisibleFocus, doc_wxRichTextCtrl_EnableVisibleFocus);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ProcessEvent, "ProcessEvent(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_ProcessEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ProcessEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_ProcessEvent(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ProcessEvent, doc_wxRichTextCtrl_ProcessEvent);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoEnable, "DoEnable(self, enable: bool)");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoEnable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoEnable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool enable;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoEnable(sipSelfWasArg,enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoEnable, doc_wxRichTextCtrl_DoEnable);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoGetPosition, "DoGetPosition(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoGetPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoGetPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        const sipwxRichTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetPosition(sipSelfWasArg,&x,&y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",x,y);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoGetPosition, doc_wxRichTextCtrl_DoGetPosition);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoGetSize, "DoGetSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoGetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoGetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxRichTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoGetSize, doc_wxRichTextCtrl_DoGetSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoGetClientSize, "DoGetClientSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoGetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoGetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxRichTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetClientSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoGetClientSize, doc_wxRichTextCtrl_DoGetClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoGetBestClientSize, "DoGetBestClientSize(self) -> Size");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoGetBestClientSize(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoGetBestClientSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestClientSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoGetBestClientSize, doc_wxRichTextCtrl_DoGetBestClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoSetSize, "DoSetSize(self, x: int, y: int, width: int, height: int, sizeFlags: int)");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoSetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoSetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        int sizeFlags;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
            sipName_sizeFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiiii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &x, &y, &width, &height, &sizeFlags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSize(sipSelfWasArg,x,y,width,height,sizeFlags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoSetSize, doc_wxRichTextCtrl_DoSetSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoSetClientSize, "DoSetClientSize(self, width: int, height: int)");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoSetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoSetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetClientSize(sipSelfWasArg,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoSetClientSize, doc_wxRichTextCtrl_DoSetClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoSetSizeHints, "DoSetSizeHints(self, minW: int, minH: int, maxW: int, maxH: int, incW: int, incH: int)");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoSetSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoSetSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int minW;
        int minH;
        int maxW;
        int maxH;
        int incW;
        int incH;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minW,
            sipName_minH,
            sipName_maxW,
            sipName_maxH,
            sipName_incW,
            sipName_incH,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiiiii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &minW, &minH, &maxW, &maxH, &incW, &incH))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSizeHints(sipSelfWasArg,minW,minH,maxW,maxH,incW,incH);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoSetSizeHints, doc_wxRichTextCtrl_DoSetSizeHints);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoMoveWindow, "DoMoveWindow(self, x: int, y: int, width: int, height: int)");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoMoveWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoMoveWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoMoveWindow(sipSelfWasArg,x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoMoveWindow, doc_wxRichTextCtrl_DoMoveWindow);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoSetWindowVariant, "DoSetWindowVariant(self, variant: WindowVariant)");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoSetWindowVariant(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoSetWindowVariant(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowVariant variant;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxWindowVariant, &variant))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetWindowVariant(sipSelfWasArg,variant);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoSetWindowVariant, doc_wxRichTextCtrl_DoSetWindowVariant);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDefaultBorder, "GetDefaultBorder(self) -> Border");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDefaultBorder(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDefaultBorder(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorder(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDefaultBorder, doc_wxRichTextCtrl_GetDefaultBorder);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetDefaultBorderForControl, "GetDefaultBorderForControl(self) -> Border");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetDefaultBorderForControl(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetDefaultBorderForControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorderForControl(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetDefaultBorderForControl, doc_wxRichTextCtrl_GetDefaultBorderForControl);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoFreeze, "DoFreeze(self)");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoFreeze(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoFreeze(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoFreeze(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoFreeze, doc_wxRichTextCtrl_DoFreeze);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_HasTransparentBackground, "HasTransparentBackground(self) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_HasTransparentBackground(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_HasTransparentBackground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_HasTransparentBackground(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_HasTransparentBackground, doc_wxRichTextCtrl_HasTransparentBackground);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_TryBefore, "TryBefore(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_TryBefore(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_TryBefore(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryBefore(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_TryBefore, doc_wxRichTextCtrl_TryBefore);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_TryAfter, "TryAfter(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxRichTextCtrl_TryAfter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_TryAfter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryAfter(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_TryAfter, doc_wxRichTextCtrl_TryAfter);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetClassDefaultAttributes, "GetClassDefaultAttributes(variant=wx.WINDOW_VARIANT_NORMAL) -> wx.VisualAttributes");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetClassDefaultAttributes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetClassDefaultAttributes(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "|E", sipType_wxWindowVariant, &variant))
        {
             ::wxVisualAttributes*sipRes;
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxVisualAttributes( ::wxRichTextCtrl::GetClassDefaultAttributes(variant));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxVisualAttributes,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetClassDefaultAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetMargins, "SetMargins(pt) -> bool\n"
"SetMargins(left, top=-1) -> bool\n"
"\n"
"Attempts to set the control margins.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetMargins(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetMargins(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetMargins(*pt);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxCoord left;
         ::wxCoord top = -1;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_left,
            sipName_top,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|i", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, &left, &top))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetMargins(left,top);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetMargins, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AutoComplete, "AutoComplete(choices) -> bool\n"
"AutoComplete(completer) -> bool\n"
"\n"
"Call this function to enable auto-completion of the text typed in a\n"
"single-line text control using the given choices.\n"
"");

extern "C" {static PyObject *meth_wxRichTextCtrl_AutoComplete(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AutoComplete(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxArrayString* choices;
        int choicesState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_choices,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxArrayString, &choices, &choicesState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoComplete(*choices);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxArrayString *>(choices), sipType_wxArrayString, choicesState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxTextCompleter* completer;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_completer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxTextCompleter, &completer))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoComplete(completer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AutoComplete, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AutoCompleteFileNames, "AutoCompleteFileNames() -> bool\n"
"\n"
"Call this function to enable auto-completion of the text typed in a\n"
"single-line text control using all valid file system paths.");

extern "C" {static PyObject *meth_wxRichTextCtrl_AutoCompleteFileNames(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AutoCompleteFileNames(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompleteFileNames();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AutoCompleteFileNames, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_AutoCompleteDirectories, "AutoCompleteDirectories() -> bool\n"
"\n"
"Call this function to enable auto-completion of the text using the\n"
"file system directories.");

extern "C" {static PyObject *meth_wxRichTextCtrl_AutoCompleteDirectories(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_AutoCompleteDirectories(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompleteDirectories();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_AutoCompleteDirectories, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ChangeValue, "ChangeValue(value)\n"
"\n"
"Sets the new text control value.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ChangeValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ChangeValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* value;
        int valueState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ChangeValue(*value);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ChangeValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_ForceUpper, "ForceUpper()\n"
"\n"
"Convert all text entered into the control to upper case.");

extern "C" {static PyObject *meth_wxRichTextCtrl_ForceUpper(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_ForceUpper(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ForceUpper();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_ForceUpper, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_IsEmpty, "IsEmpty() -> bool\n"
"\n"
"Returns true if the control is currently empty.");

extern "C" {static PyObject *meth_wxRichTextCtrl_IsEmpty(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_IsEmpty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEmpty();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_IsEmpty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_SetHint, "SetHint(hint) -> bool\n"
"\n"
"Sets a hint shown in an empty unfocused text control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_SetHint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_SetHint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* hint;
        int hintState = 0;
         ::wxRichTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_hint,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxRichTextCtrl, &sipCpp, sipType_wxString, &hint, &hintState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetHint(*hint);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(hint), sipType_wxString, hintState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_SetHint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetHint, "GetHint() -> String\n"
"\n"
"Returns the current hint string.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetHint(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetHint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetHint());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetHint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_GetMargins, "GetMargins() -> Point\n"
"\n"
"Returns the margins used by the control.");

extern "C" {static PyObject *meth_wxRichTextCtrl_GetMargins(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_GetMargins(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetMargins());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_GetMargins, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoGetBestSize, "DoGetBestSize() -> wx.Size\n"
"\n"
"Currently this simply returns wxSize(10, 10).");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoGetBestSize(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoGetBestSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoGetBestSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxRichTextCtrl_DoThaw, "DoThaw()");

extern "C" {static PyObject *meth_wxRichTextCtrl_DoThaw(PyObject *, PyObject *);}
static PyObject *meth_wxRichTextCtrl_DoThaw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxRichTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxRichTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoThaw(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_RichTextCtrl, sipName_DoThaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxRichTextCtrl(void *, const sipTypeDef *);}
static void *cast_wxRichTextCtrl(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxRichTextCtrl *sipCpp = reinterpret_cast< ::wxRichTextCtrl *>(sipCppV);

    if (targetType == sipType_wxRichTextCtrl)
        return sipCppV;

    sipCppV = ((const sipClassTypeDef *)sipType_wxControl)->ctd_cast(static_cast< ::wxControl *>(sipCpp), targetType);
    if (sipCppV)
        return sipCppV;

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxRichTextCtrl(void *, int);}
static void release_wxRichTextCtrl(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxRichTextCtrl *>(sipCppV);
    else
        delete reinterpret_cast< ::wxRichTextCtrl *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void *array_wxRichTextCtrl(Py_ssize_t);}
static void *array_wxRichTextCtrl(Py_ssize_t sipNrElem)
{
    return new  ::wxRichTextCtrl[sipNrElem];
}


extern "C" {static void dealloc_wxRichTextCtrl(sipSimpleWrapper *);}
static void dealloc_wxRichTextCtrl(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxRichTextCtrl *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxRichTextCtrl(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxRichTextCtrl(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxRichTextCtrl(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipwxRichTextCtrl *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxRichTextCtrl();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
         ::wxWindow* parent;
         ::wxWindowID id = -1;
        const  ::wxString& valuedef = wxEmptyString;
        const  ::wxString* value = &valuedef;
        int valueState = 0;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        long style = wxRE_MULTILINE;
        const  ::wxValidator& validatordef = wxDefaultValidator;
        const  ::wxValidator* validator = &validatordef;
        const  ::wxString& namedef = wxTextCtrlNameStr;
        const  ::wxString* name = &namedef;
        int nameState = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
            sipName_id,
            sipName_value,
            sipName_pos,
            sipName_size,
            sipName_style,
            sipName_validator,
            sipName_name,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "JH|iJ1J1J1lJ9J1", sipType_wxWindow, &parent, sipOwner, &id, sipType_wxString, &value, &valueState, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, &style, sipType_wxValidator, &validator, sipType_wxString, &name, &nameState))
        {
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxRichTextCtrl(parent,id,*value,*pos,*size,style,*validator,*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxRichTextCtrl[] = {{15, 0, 1}};


static PyMethodDef methods_wxRichTextCtrl[] = {
    {sipName_AcceptsFocus, meth_wxRichTextCtrl_AcceptsFocus, METH_VARARGS, doc_wxRichTextCtrl_AcceptsFocus},
    {sipName_AcceptsFocusFromKeyboard, meth_wxRichTextCtrl_AcceptsFocusFromKeyboard, METH_VARARGS, doc_wxRichTextCtrl_AcceptsFocusFromKeyboard},
    {sipName_AcceptsFocusRecursively, meth_wxRichTextCtrl_AcceptsFocusRecursively, METH_VARARGS, doc_wxRichTextCtrl_AcceptsFocusRecursively},
    {sipName_AddChild, SIP_MLMETH_CAST(meth_wxRichTextCtrl_AddChild), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_AddChild},
    {sipName_AddImage, SIP_MLMETH_CAST(meth_wxRichTextCtrl_AddImage), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_AddImage},
    {sipName_AddParagraph, SIP_MLMETH_CAST(meth_wxRichTextCtrl_AddParagraph), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_AddParagraph},
    {sipName_AppendText, SIP_MLMETH_CAST(meth_wxRichTextCtrl_AppendText), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_AppendText},
    {sipName_ApplyAlignmentToSelection, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ApplyAlignmentToSelection), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ApplyAlignmentToSelection},
    {sipName_ApplyBoldToSelection, meth_wxRichTextCtrl_ApplyBoldToSelection, METH_VARARGS, doc_wxRichTextCtrl_ApplyBoldToSelection},
    {sipName_ApplyItalicToSelection, meth_wxRichTextCtrl_ApplyItalicToSelection, METH_VARARGS, doc_wxRichTextCtrl_ApplyItalicToSelection},
    {sipName_ApplyStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ApplyStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ApplyStyle},
    {sipName_ApplyStyleSheet, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ApplyStyleSheet), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ApplyStyleSheet},
    {sipName_ApplyTextEffectToSelection, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ApplyTextEffectToSelection), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ApplyTextEffectToSelection},
    {sipName_ApplyUnderlineToSelection, meth_wxRichTextCtrl_ApplyUnderlineToSelection, METH_VARARGS, doc_wxRichTextCtrl_ApplyUnderlineToSelection},
    {sipName_AutoComplete, SIP_MLMETH_CAST(meth_wxRichTextCtrl_AutoComplete), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_AutoComplete},
    {sipName_AutoCompleteDirectories, meth_wxRichTextCtrl_AutoCompleteDirectories, METH_VARARGS, doc_wxRichTextCtrl_AutoCompleteDirectories},
    {sipName_AutoCompleteFileNames, meth_wxRichTextCtrl_AutoCompleteFileNames, METH_VARARGS, doc_wxRichTextCtrl_AutoCompleteFileNames},
    {sipName_BatchingUndo, meth_wxRichTextCtrl_BatchingUndo, METH_VARARGS, doc_wxRichTextCtrl_BatchingUndo},
    {sipName_BeginAlignment, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginAlignment},
    {sipName_BeginBatchUndo, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginBatchUndo), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginBatchUndo},
    {sipName_BeginBold, meth_wxRichTextCtrl_BeginBold, METH_VARARGS, doc_wxRichTextCtrl_BeginBold},
    {sipName_BeginCharacterStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginCharacterStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginCharacterStyle},
    {sipName_BeginFont, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginFont), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginFont},
    {sipName_BeginFontSize, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginFontSize), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginFontSize},
    {sipName_BeginItalic, meth_wxRichTextCtrl_BeginItalic, METH_VARARGS, doc_wxRichTextCtrl_BeginItalic},
    {sipName_BeginLeftIndent, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginLeftIndent), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginLeftIndent},
    {sipName_BeginLineSpacing, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginLineSpacing), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginLineSpacing},
    {sipName_BeginListStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginListStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginListStyle},
    {sipName_BeginNumberedBullet, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginNumberedBullet), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginNumberedBullet},
    {sipName_BeginParagraphSpacing, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginParagraphSpacing), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginParagraphSpacing},
    {sipName_BeginParagraphStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginParagraphStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginParagraphStyle},
    {sipName_BeginRightIndent, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginRightIndent), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginRightIndent},
    {sipName_BeginStandardBullet, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginStandardBullet), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginStandardBullet},
    {sipName_BeginStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginStyle},
    {sipName_BeginSuppressUndo, meth_wxRichTextCtrl_BeginSuppressUndo, METH_VARARGS, doc_wxRichTextCtrl_BeginSuppressUndo},
    {sipName_BeginSymbolBullet, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginSymbolBullet), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginSymbolBullet},
    {sipName_BeginTextColour, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginTextColour), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginTextColour},
    {sipName_BeginURL, SIP_MLMETH_CAST(meth_wxRichTextCtrl_BeginURL), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_BeginURL},
    {sipName_BeginUnderline, meth_wxRichTextCtrl_BeginUnderline, METH_VARARGS, doc_wxRichTextCtrl_BeginUnderline},
    {sipName_CanCopy, meth_wxRichTextCtrl_CanCopy, METH_VARARGS, doc_wxRichTextCtrl_CanCopy},
    {sipName_CanCut, meth_wxRichTextCtrl_CanCut, METH_VARARGS, doc_wxRichTextCtrl_CanCut},
    {sipName_CanDeleteRange, SIP_MLMETH_CAST(meth_wxRichTextCtrl_CanDeleteRange), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_CanDeleteRange},
    {sipName_CanDeleteSelection, meth_wxRichTextCtrl_CanDeleteSelection, METH_VARARGS, doc_wxRichTextCtrl_CanDeleteSelection},
    {sipName_CanEditProperties, SIP_MLMETH_CAST(meth_wxRichTextCtrl_CanEditProperties), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_CanEditProperties},
    {sipName_CanInsertContent, SIP_MLMETH_CAST(meth_wxRichTextCtrl_CanInsertContent), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_CanInsertContent},
    {sipName_CanPaste, meth_wxRichTextCtrl_CanPaste, METH_VARARGS, doc_wxRichTextCtrl_CanPaste},
    {sipName_CanRedo, meth_wxRichTextCtrl_CanRedo, METH_VARARGS, doc_wxRichTextCtrl_CanRedo},
    {sipName_CanUndo, meth_wxRichTextCtrl_CanUndo, METH_VARARGS, doc_wxRichTextCtrl_CanUndo},
    {sipName_ChangeValue, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ChangeValue), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ChangeValue},
    {sipName_Clear, meth_wxRichTextCtrl_Clear, METH_VARARGS, doc_wxRichTextCtrl_Clear},
    {sipName_ClearAvailableFontNames, meth_wxRichTextCtrl_ClearAvailableFontNames, METH_VARARGS, doc_wxRichTextCtrl_ClearAvailableFontNames},
    {sipName_ClearListStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ClearListStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ClearListStyle},
    {sipName_Command, SIP_MLMETH_CAST(meth_wxRichTextCtrl_Command), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_Command},
    {sipName_Copy, meth_wxRichTextCtrl_Copy, METH_VARARGS, doc_wxRichTextCtrl_Copy},
    {sipName_Create, SIP_MLMETH_CAST(meth_wxRichTextCtrl_Create), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_Create},
    {sipName_Cut, meth_wxRichTextCtrl_Cut, METH_VARARGS, doc_wxRichTextCtrl_Cut},
    {sipName_Delete, SIP_MLMETH_CAST(meth_wxRichTextCtrl_Delete), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_Delete},
    {sipName_DeleteSelectedContent, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DeleteSelectedContent), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DeleteSelectedContent},
    {sipName_DeleteSelection, meth_wxRichTextCtrl_DeleteSelection, METH_VARARGS, doc_wxRichTextCtrl_DeleteSelection},
    {sipName_Destroy, meth_wxRichTextCtrl_Destroy, METH_VARARGS, doc_wxRichTextCtrl_Destroy},
    {sipName_DiscardEdits, meth_wxRichTextCtrl_DiscardEdits, METH_VARARGS, doc_wxRichTextCtrl_DiscardEdits},
    {sipName_DoEnable, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoEnable), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoEnable},
    {sipName_DoFreeze, meth_wxRichTextCtrl_DoFreeze, METH_VARARGS, doc_wxRichTextCtrl_DoFreeze},
    {sipName_DoGetBestClientSize, meth_wxRichTextCtrl_DoGetBestClientSize, METH_VARARGS, doc_wxRichTextCtrl_DoGetBestClientSize},
    {sipName_DoGetBestSize, meth_wxRichTextCtrl_DoGetBestSize, METH_VARARGS, doc_wxRichTextCtrl_DoGetBestSize},
    {sipName_DoGetClientSize, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoGetClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoGetClientSize},
    {sipName_DoGetPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoGetPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoGetPosition},
    {sipName_DoGetSize, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoGetSize), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoGetSize},
    {sipName_DoGetValue, meth_wxRichTextCtrl_DoGetValue, METH_VARARGS, doc_wxRichTextCtrl_DoGetValue},
    {sipName_DoLayoutBuffer, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoLayoutBuffer), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoLayoutBuffer},
    {sipName_DoLoadFile, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoLoadFile), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoLoadFile},
    {sipName_DoMoveWindow, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoMoveWindow), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoMoveWindow},
    {sipName_DoSaveFile, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoSaveFile), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoSaveFile},
    {sipName_DoSetClientSize, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoSetClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoSetClientSize},
    {sipName_DoSetSize, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoSetSize), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoSetSize},
    {sipName_DoSetSizeHints, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoSetSizeHints), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoSetSizeHints},
    {sipName_DoSetWindowVariant, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoSetWindowVariant), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoSetWindowVariant},
    {sipName_DoThaw, meth_wxRichTextCtrl_DoThaw, METH_VARARGS, doc_wxRichTextCtrl_DoThaw},
    {sipName_DoWriteText, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoWriteText), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoWriteText},
    {sipName_DoesSelectionHaveTextEffectFlag, SIP_MLMETH_CAST(meth_wxRichTextCtrl_DoesSelectionHaveTextEffectFlag), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_DoesSelectionHaveTextEffectFlag},
    {sipName_EditProperties, SIP_MLMETH_CAST(meth_wxRichTextCtrl_EditProperties), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_EditProperties},
    {sipName_EnableDelayedImageLoading, SIP_MLMETH_CAST(meth_wxRichTextCtrl_EnableDelayedImageLoading), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_EnableDelayedImageLoading},
    {sipName_EnableImages, SIP_MLMETH_CAST(meth_wxRichTextCtrl_EnableImages), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_EnableImages},
    {sipName_EnableVerticalScrollbar, SIP_MLMETH_CAST(meth_wxRichTextCtrl_EnableVerticalScrollbar), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_EnableVerticalScrollbar},
    {sipName_EnableVirtualAttributes, SIP_MLMETH_CAST(meth_wxRichTextCtrl_EnableVirtualAttributes), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_EnableVirtualAttributes},
    {sipName_EnableVisibleFocus, SIP_MLMETH_CAST(meth_wxRichTextCtrl_EnableVisibleFocus), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_EnableVisibleFocus},
    {sipName_EndAlignment, meth_wxRichTextCtrl_EndAlignment, METH_VARARGS, doc_wxRichTextCtrl_EndAlignment},
    {sipName_EndAllStyles, meth_wxRichTextCtrl_EndAllStyles, METH_VARARGS, doc_wxRichTextCtrl_EndAllStyles},
    {sipName_EndBatchUndo, meth_wxRichTextCtrl_EndBatchUndo, METH_VARARGS, doc_wxRichTextCtrl_EndBatchUndo},
    {sipName_EndBold, meth_wxRichTextCtrl_EndBold, METH_VARARGS, doc_wxRichTextCtrl_EndBold},
    {sipName_EndCharacterStyle, meth_wxRichTextCtrl_EndCharacterStyle, METH_VARARGS, doc_wxRichTextCtrl_EndCharacterStyle},
    {sipName_EndFont, meth_wxRichTextCtrl_EndFont, METH_VARARGS, doc_wxRichTextCtrl_EndFont},
    {sipName_EndFontSize, meth_wxRichTextCtrl_EndFontSize, METH_VARARGS, doc_wxRichTextCtrl_EndFontSize},
    {sipName_EndItalic, meth_wxRichTextCtrl_EndItalic, METH_VARARGS, doc_wxRichTextCtrl_EndItalic},
    {sipName_EndLeftIndent, meth_wxRichTextCtrl_EndLeftIndent, METH_VARARGS, doc_wxRichTextCtrl_EndLeftIndent},
    {sipName_EndLineSpacing, meth_wxRichTextCtrl_EndLineSpacing, METH_VARARGS, doc_wxRichTextCtrl_EndLineSpacing},
    {sipName_EndListStyle, meth_wxRichTextCtrl_EndListStyle, METH_VARARGS, doc_wxRichTextCtrl_EndListStyle},
    {sipName_EndNumberedBullet, meth_wxRichTextCtrl_EndNumberedBullet, METH_VARARGS, doc_wxRichTextCtrl_EndNumberedBullet},
    {sipName_EndParagraphSpacing, meth_wxRichTextCtrl_EndParagraphSpacing, METH_VARARGS, doc_wxRichTextCtrl_EndParagraphSpacing},
    {sipName_EndParagraphStyle, meth_wxRichTextCtrl_EndParagraphStyle, METH_VARARGS, doc_wxRichTextCtrl_EndParagraphStyle},
    {sipName_EndRightIndent, meth_wxRichTextCtrl_EndRightIndent, METH_VARARGS, doc_wxRichTextCtrl_EndRightIndent},
    {sipName_EndStandardBullet, meth_wxRichTextCtrl_EndStandardBullet, METH_VARARGS, doc_wxRichTextCtrl_EndStandardBullet},
    {sipName_EndStyle, meth_wxRichTextCtrl_EndStyle, METH_VARARGS, doc_wxRichTextCtrl_EndStyle},
    {sipName_EndSuppressUndo, meth_wxRichTextCtrl_EndSuppressUndo, METH_VARARGS, doc_wxRichTextCtrl_EndSuppressUndo},
    {sipName_EndSymbolBullet, meth_wxRichTextCtrl_EndSymbolBullet, METH_VARARGS, doc_wxRichTextCtrl_EndSymbolBullet},
    {sipName_EndTextColour, meth_wxRichTextCtrl_EndTextColour, METH_VARARGS, doc_wxRichTextCtrl_EndTextColour},
    {sipName_EndURL, meth_wxRichTextCtrl_EndURL, METH_VARARGS, doc_wxRichTextCtrl_EndURL},
    {sipName_EndUnderline, meth_wxRichTextCtrl_EndUnderline, METH_VARARGS, doc_wxRichTextCtrl_EndUnderline},
    {sipName_ExtendCellSelection, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ExtendCellSelection), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ExtendCellSelection},
    {sipName_ExtendSelection, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ExtendSelection), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ExtendSelection},
    {sipName_FindCaretPositionForCharacterPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_FindCaretPositionForCharacterPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_FindCaretPositionForCharacterPosition},
    {sipName_FindContainerAtPoint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_FindContainerAtPoint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_FindContainerAtPoint},
    {sipName_FindNextWordPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_FindNextWordPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_FindNextWordPosition},
    {sipName_FindRangeForList, SIP_MLMETH_CAST(meth_wxRichTextCtrl_FindRangeForList), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_FindRangeForList},
    {sipName_ForceDelayedLayout, meth_wxRichTextCtrl_ForceDelayedLayout, METH_VARARGS, doc_wxRichTextCtrl_ForceDelayedLayout},
    {sipName_ForceUpper, meth_wxRichTextCtrl_ForceUpper, METH_VARARGS, doc_wxRichTextCtrl_ForceUpper},
    {sipName_GetAdjustedCaretPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetAdjustedCaretPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetAdjustedCaretPosition},
    {sipName_GetAvailableFontNames, meth_wxRichTextCtrl_GetAvailableFontNames, METH_VARARGS, doc_wxRichTextCtrl_GetAvailableFontNames},
    {sipName_GetBasicStyle, meth_wxRichTextCtrl_GetBasicStyle, METH_VARARGS, doc_wxRichTextCtrl_GetBasicStyle},
    {sipName_GetBuffer, meth_wxRichTextCtrl_GetBuffer, METH_VARARGS, doc_wxRichTextCtrl_GetBuffer},
    {sipName_GetCaretAtLineStart, meth_wxRichTextCtrl_GetCaretAtLineStart, METH_VARARGS, doc_wxRichTextCtrl_GetCaretAtLineStart},
    {sipName_GetCaretPosition, meth_wxRichTextCtrl_GetCaretPosition, METH_VARARGS, doc_wxRichTextCtrl_GetCaretPosition},
    {sipName_GetCaretPositionForDefaultStyle, meth_wxRichTextCtrl_GetCaretPositionForDefaultStyle, METH_VARARGS, doc_wxRichTextCtrl_GetCaretPositionForDefaultStyle},
    {sipName_GetCaretPositionForIndex, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetCaretPositionForIndex), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetCaretPositionForIndex},
    {sipName_GetClassDefaultAttributes, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetClassDefaultAttributes), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetClassDefaultAttributes},
    {sipName_GetClientAreaOrigin, meth_wxRichTextCtrl_GetClientAreaOrigin, METH_VARARGS, doc_wxRichTextCtrl_GetClientAreaOrigin},
    {sipName_GetCommandProcessor, meth_wxRichTextCtrl_GetCommandProcessor, METH_VARARGS, doc_wxRichTextCtrl_GetCommandProcessor},
    {sipName_GetContextMenu, meth_wxRichTextCtrl_GetContextMenu, METH_VARARGS, doc_wxRichTextCtrl_GetContextMenu},
    {sipName_GetContextMenuPropertiesInfo, meth_wxRichTextCtrl_GetContextMenuPropertiesInfo, METH_VARARGS, doc_wxRichTextCtrl_GetContextMenuPropertiesInfo},
    {sipName_GetDefaultBorder, meth_wxRichTextCtrl_GetDefaultBorder, METH_VARARGS, doc_wxRichTextCtrl_GetDefaultBorder},
    {sipName_GetDefaultBorderForControl, meth_wxRichTextCtrl_GetDefaultBorderForControl, METH_VARARGS, doc_wxRichTextCtrl_GetDefaultBorderForControl},
    {sipName_GetDefaultStyleEx, meth_wxRichTextCtrl_GetDefaultStyleEx, METH_VARARGS, doc_wxRichTextCtrl_GetDefaultStyleEx},
    {sipName_GetDelayedImageLoading, meth_wxRichTextCtrl_GetDelayedImageLoading, METH_VARARGS, doc_wxRichTextCtrl_GetDelayedImageLoading},
    {sipName_GetDelayedImageProcessingRequired, meth_wxRichTextCtrl_GetDelayedImageProcessingRequired, METH_VARARGS, doc_wxRichTextCtrl_GetDelayedImageProcessingRequired},
    {sipName_GetDelayedImageProcessingTime, meth_wxRichTextCtrl_GetDelayedImageProcessingTime, METH_VARARGS, doc_wxRichTextCtrl_GetDelayedImageProcessingTime},
    {sipName_GetDelayedLayoutThreshold, meth_wxRichTextCtrl_GetDelayedLayoutThreshold, METH_VARARGS, doc_wxRichTextCtrl_GetDelayedLayoutThreshold},
    {sipName_GetDimensionScale, meth_wxRichTextCtrl_GetDimensionScale, METH_VARARGS, doc_wxRichTextCtrl_GetDimensionScale},
    {sipName_GetDragStartPoint, meth_wxRichTextCtrl_GetDragStartPoint, METH_VARARGS, doc_wxRichTextCtrl_GetDragStartPoint},
    {sipName_GetDragStartTime, meth_wxRichTextCtrl_GetDragStartTime, METH_VARARGS, doc_wxRichTextCtrl_GetDragStartTime},
    {sipName_GetDragging, meth_wxRichTextCtrl_GetDragging, METH_VARARGS, doc_wxRichTextCtrl_GetDragging},
    {sipName_GetFilename, meth_wxRichTextCtrl_GetFilename, METH_VARARGS, doc_wxRichTextCtrl_GetFilename},
    {sipName_GetFirstVisiblePoint, meth_wxRichTextCtrl_GetFirstVisiblePoint, METH_VARARGS, doc_wxRichTextCtrl_GetFirstVisiblePoint},
    {sipName_GetFirstVisiblePosition, meth_wxRichTextCtrl_GetFirstVisiblePosition, METH_VARARGS, doc_wxRichTextCtrl_GetFirstVisiblePosition},
    {sipName_GetFocusObject, meth_wxRichTextCtrl_GetFocusObject, METH_VARARGS, doc_wxRichTextCtrl_GetFocusObject},
    {sipName_GetFontScale, meth_wxRichTextCtrl_GetFontScale, METH_VARARGS, doc_wxRichTextCtrl_GetFontScale},
    {sipName_GetFullLayoutRequired, meth_wxRichTextCtrl_GetFullLayoutRequired, METH_VARARGS, doc_wxRichTextCtrl_GetFullLayoutRequired},
    {sipName_GetFullLayoutSavedPosition, meth_wxRichTextCtrl_GetFullLayoutSavedPosition, METH_VARARGS, doc_wxRichTextCtrl_GetFullLayoutSavedPosition},
    {sipName_GetFullLayoutTime, meth_wxRichTextCtrl_GetFullLayoutTime, METH_VARARGS, doc_wxRichTextCtrl_GetFullLayoutTime},
    {sipName_GetHandlerFlags, meth_wxRichTextCtrl_GetHandlerFlags, METH_VARARGS, doc_wxRichTextCtrl_GetHandlerFlags},
    {sipName_GetHint, meth_wxRichTextCtrl_GetHint, METH_VARARGS, doc_wxRichTextCtrl_GetHint},
    {sipName_GetImagesEnabled, meth_wxRichTextCtrl_GetImagesEnabled, METH_VARARGS, doc_wxRichTextCtrl_GetImagesEnabled},
    {sipName_GetInsertionPoint, meth_wxRichTextCtrl_GetInsertionPoint, METH_VARARGS, doc_wxRichTextCtrl_GetInsertionPoint},
    {sipName_GetInternalSelectionRange, meth_wxRichTextCtrl_GetInternalSelectionRange, METH_VARARGS, doc_wxRichTextCtrl_GetInternalSelectionRange},
    {sipName_GetLastPosition, meth_wxRichTextCtrl_GetLastPosition, METH_VARARGS, doc_wxRichTextCtrl_GetLastPosition},
    {sipName_GetLineLength, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetLineLength), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetLineLength},
    {sipName_GetLineText, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetLineText), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetLineText},
    {sipName_GetLogicalPoint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetLogicalPoint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetLogicalPoint},
    {sipName_GetMainWindowOfCompositeControl, meth_wxRichTextCtrl_GetMainWindowOfCompositeControl, METH_VARARGS, doc_wxRichTextCtrl_GetMainWindowOfCompositeControl},
    {sipName_GetMargins, meth_wxRichTextCtrl_GetMargins, METH_VARARGS, doc_wxRichTextCtrl_GetMargins},
    {sipName_GetNumberOfLines, meth_wxRichTextCtrl_GetNumberOfLines, METH_VARARGS, doc_wxRichTextCtrl_GetNumberOfLines},
    {sipName_GetPhysicalPoint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetPhysicalPoint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetPhysicalPoint},
    {sipName_GetPreDrag, meth_wxRichTextCtrl_GetPreDrag, METH_VARARGS, doc_wxRichTextCtrl_GetPreDrag},
    {sipName_GetPropertiesMenuLabel, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetPropertiesMenuLabel), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetPropertiesMenuLabel},
    {sipName_GetRange, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetRange), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetRange},
    {sipName_GetScale, meth_wxRichTextCtrl_GetScale, METH_VARARGS, doc_wxRichTextCtrl_GetScale},
    {sipName_GetScaledPoint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetScaledPoint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetScaledPoint},
    {sipName_GetScaledRect, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetScaledRect), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetScaledRect},
    {sipName_GetScaledSize, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetScaledSize), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetScaledSize},
    {sipName_GetSelection, meth_wxRichTextCtrl_GetSelection, METH_VARARGS, doc_wxRichTextCtrl_GetSelection},
    {sipName_GetSelectionAnchor, meth_wxRichTextCtrl_GetSelectionAnchor, METH_VARARGS, doc_wxRichTextCtrl_GetSelectionAnchor},
    {sipName_GetSelectionAnchorObject, meth_wxRichTextCtrl_GetSelectionAnchorObject, METH_VARARGS, doc_wxRichTextCtrl_GetSelectionAnchorObject},
    {sipName_GetSelectionRange, meth_wxRichTextCtrl_GetSelectionRange, METH_VARARGS, doc_wxRichTextCtrl_GetSelectionRange},
    {sipName_GetStringSelection, meth_wxRichTextCtrl_GetStringSelection, METH_VARARGS, doc_wxRichTextCtrl_GetStringSelection},
    {sipName_GetStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetStyle},
    {sipName_GetStyleForRange, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetStyleForRange), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetStyleForRange},
    {sipName_GetStyleSheet, meth_wxRichTextCtrl_GetStyleSheet, METH_VARARGS, doc_wxRichTextCtrl_GetStyleSheet},
    {sipName_GetTextCursor, meth_wxRichTextCtrl_GetTextCursor, METH_VARARGS, doc_wxRichTextCtrl_GetTextCursor},
    {sipName_GetURLCursor, meth_wxRichTextCtrl_GetURLCursor, METH_VARARGS, doc_wxRichTextCtrl_GetURLCursor},
    {sipName_GetUncombinedStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetUncombinedStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetUncombinedStyle},
    {sipName_GetUnscaledPoint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetUnscaledPoint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetUnscaledPoint},
    {sipName_GetUnscaledRect, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetUnscaledRect), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetUnscaledRect},
    {sipName_GetUnscaledSize, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetUnscaledSize), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetUnscaledSize},
    {sipName_GetValidator, meth_wxRichTextCtrl_GetValidator, METH_VARARGS, doc_wxRichTextCtrl_GetValidator},
    {sipName_GetValue, meth_wxRichTextCtrl_GetValue, METH_VARARGS, doc_wxRichTextCtrl_GetValue},
    {sipName_GetVerticalScrollbarEnabled, meth_wxRichTextCtrl_GetVerticalScrollbarEnabled, METH_VARARGS, doc_wxRichTextCtrl_GetVerticalScrollbarEnabled},
    {sipName_GetVirtualAttributesEnabled, meth_wxRichTextCtrl_GetVirtualAttributesEnabled, METH_VARARGS, doc_wxRichTextCtrl_GetVirtualAttributesEnabled},
    {sipName_GetVisibleLineForCaretPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_GetVisibleLineForCaretPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_GetVisibleLineForCaretPosition},
    {sipName_HasCharacterAttributes, SIP_MLMETH_CAST(meth_wxRichTextCtrl_HasCharacterAttributes), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_HasCharacterAttributes},
    {sipName_HasParagraphAttributes, SIP_MLMETH_CAST(meth_wxRichTextCtrl_HasParagraphAttributes), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_HasParagraphAttributes},
    {sipName_HasSelection, meth_wxRichTextCtrl_HasSelection, METH_VARARGS, doc_wxRichTextCtrl_HasSelection},
    {sipName_HasTransparentBackground, meth_wxRichTextCtrl_HasTransparentBackground, METH_VARARGS, doc_wxRichTextCtrl_HasTransparentBackground},
    {sipName_HasUnfocusedSelection, meth_wxRichTextCtrl_HasUnfocusedSelection, METH_VARARGS, doc_wxRichTextCtrl_HasUnfocusedSelection},
    {sipName_HitTest, SIP_MLMETH_CAST(meth_wxRichTextCtrl_HitTest), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_HitTest},
    {sipName_HitTestXY, SIP_MLMETH_CAST(meth_wxRichTextCtrl_HitTestXY), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_HitTestXY},
    {sipName_InformFirstDirection, SIP_MLMETH_CAST(meth_wxRichTextCtrl_InformFirstDirection), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_InformFirstDirection},
    {sipName_InheritAttributes, meth_wxRichTextCtrl_InheritAttributes, METH_VARARGS, doc_wxRichTextCtrl_InheritAttributes},
    {sipName_Init, meth_wxRichTextCtrl_Init, METH_VARARGS, doc_wxRichTextCtrl_Init},
    {sipName_InitDialog, meth_wxRichTextCtrl_InitDialog, METH_VARARGS, doc_wxRichTextCtrl_InitDialog},
    {sipName_Invalidate, meth_wxRichTextCtrl_Invalidate, METH_VARARGS, doc_wxRichTextCtrl_Invalidate},
    {sipName_IsDefaultStyleShowing, meth_wxRichTextCtrl_IsDefaultStyleShowing, METH_VARARGS, doc_wxRichTextCtrl_IsDefaultStyleShowing},
    {sipName_IsEditable, meth_wxRichTextCtrl_IsEditable, METH_VARARGS, doc_wxRichTextCtrl_IsEditable},
    {sipName_IsEmpty, meth_wxRichTextCtrl_IsEmpty, METH_VARARGS, doc_wxRichTextCtrl_IsEmpty},
    {sipName_IsModified, meth_wxRichTextCtrl_IsModified, METH_VARARGS, doc_wxRichTextCtrl_IsModified},
    {sipName_IsMultiLine, meth_wxRichTextCtrl_IsMultiLine, METH_VARARGS, doc_wxRichTextCtrl_IsMultiLine},
    {sipName_IsPositionVisible, SIP_MLMETH_CAST(meth_wxRichTextCtrl_IsPositionVisible), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_IsPositionVisible},
    {sipName_IsSelectionAligned, SIP_MLMETH_CAST(meth_wxRichTextCtrl_IsSelectionAligned), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_IsSelectionAligned},
    {sipName_IsSelectionBold, meth_wxRichTextCtrl_IsSelectionBold, METH_VARARGS, doc_wxRichTextCtrl_IsSelectionBold},
    {sipName_IsSelectionItalics, meth_wxRichTextCtrl_IsSelectionItalics, METH_VARARGS, doc_wxRichTextCtrl_IsSelectionItalics},
    {sipName_IsSelectionUnderlined, meth_wxRichTextCtrl_IsSelectionUnderlined, METH_VARARGS, doc_wxRichTextCtrl_IsSelectionUnderlined},
    {sipName_IsSingleLine, meth_wxRichTextCtrl_IsSingleLine, METH_VARARGS, doc_wxRichTextCtrl_IsSingleLine},
    {sipName_KeyboardNavigate, SIP_MLMETH_CAST(meth_wxRichTextCtrl_KeyboardNavigate), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_KeyboardNavigate},
    {sipName_LayoutContent, SIP_MLMETH_CAST(meth_wxRichTextCtrl_LayoutContent), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_LayoutContent},
    {sipName_LineBreak, meth_wxRichTextCtrl_LineBreak, METH_VARARGS, doc_wxRichTextCtrl_LineBreak},
    {sipName_LoadFile, SIP_MLMETH_CAST(meth_wxRichTextCtrl_LoadFile), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_LoadFile},
    {sipName_MarkDirty, meth_wxRichTextCtrl_MarkDirty, METH_VARARGS, doc_wxRichTextCtrl_MarkDirty},
    {sipName_MoveCaret, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveCaret), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveCaret},
    {sipName_MoveCaretBack, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveCaretBack), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveCaretBack},
    {sipName_MoveCaretForward, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveCaretForward), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveCaretForward},
    {sipName_MoveDown, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveDown), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveDown},
    {sipName_MoveEnd, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveEnd), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveEnd},
    {sipName_MoveHome, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveHome), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveHome},
    {sipName_MoveLeft, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveLeft), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveLeft},
    {sipName_MoveRight, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveRight), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveRight},
    {sipName_MoveToLineEnd, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveToLineEnd), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveToLineEnd},
    {sipName_MoveToLineStart, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveToLineStart), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveToLineStart},
    {sipName_MoveToParagraphEnd, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveToParagraphEnd), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveToParagraphEnd},
    {sipName_MoveToParagraphStart, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveToParagraphStart), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveToParagraphStart},
    {sipName_MoveUp, SIP_MLMETH_CAST(meth_wxRichTextCtrl_MoveUp), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_MoveUp},
    {sipName_Newline, meth_wxRichTextCtrl_Newline, METH_VARARGS, doc_wxRichTextCtrl_Newline},
    {sipName_NumberList, SIP_MLMETH_CAST(meth_wxRichTextCtrl_NumberList), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_NumberList},
    {sipName_OnCaptureLost, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnCaptureLost), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnCaptureLost},
    {sipName_OnChar, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnChar), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnChar},
    {sipName_OnClear, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnClear), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnClear},
    {sipName_OnContextMenu, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnContextMenu), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnContextMenu},
    {sipName_OnCopy, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnCopy), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnCopy},
    {sipName_OnCut, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnCut), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnCut},
    {sipName_OnDropFiles, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnDropFiles), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnDropFiles},
    {sipName_OnEraseBackground, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnEraseBackground), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnEraseBackground},
    {sipName_OnIdle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnIdle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnIdle},
    {sipName_OnInternalIdle, meth_wxRichTextCtrl_OnInternalIdle, METH_VARARGS, doc_wxRichTextCtrl_OnInternalIdle},
    {sipName_OnKillFocus, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnKillFocus), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnKillFocus},
    {sipName_OnLeftClick, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnLeftClick), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnLeftClick},
    {sipName_OnLeftDClick, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnLeftDClick), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnLeftDClick},
    {sipName_OnLeftUp, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnLeftUp), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnLeftUp},
    {sipName_OnMiddleClick, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnMiddleClick), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnMiddleClick},
    {sipName_OnMoveMouse, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnMoveMouse), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnMoveMouse},
    {sipName_OnPaint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnPaint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnPaint},
    {sipName_OnPaste, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnPaste), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnPaste},
    {sipName_OnProperties, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnProperties), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnProperties},
    {sipName_OnRedo, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnRedo), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnRedo},
    {sipName_OnRightClick, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnRightClick), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnRightClick},
    {sipName_OnScroll, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnScroll), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnScroll},
    {sipName_OnSelectAll, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnSelectAll), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnSelectAll},
    {sipName_OnSetFocus, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnSetFocus), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnSetFocus},
    {sipName_OnSize, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnSize), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnSize},
    {sipName_OnSysColourChanged, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnSysColourChanged), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnSysColourChanged},
    {sipName_OnTimer, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnTimer), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnTimer},
    {sipName_OnUndo, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUndo), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUndo},
    {sipName_OnUpdateClear, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUpdateClear), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUpdateClear},
    {sipName_OnUpdateCopy, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUpdateCopy), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUpdateCopy},
    {sipName_OnUpdateCut, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUpdateCut), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUpdateCut},
    {sipName_OnUpdatePaste, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUpdatePaste), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUpdatePaste},
    {sipName_OnUpdateProperties, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUpdateProperties), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUpdateProperties},
    {sipName_OnUpdateRedo, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUpdateRedo), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUpdateRedo},
    {sipName_OnUpdateSelectAll, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUpdateSelectAll), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUpdateSelectAll},
    {sipName_OnUpdateUndo, SIP_MLMETH_CAST(meth_wxRichTextCtrl_OnUpdateUndo), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_OnUpdateUndo},
    {sipName_PageDown, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PageDown), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PageDown},
    {sipName_PageUp, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PageUp), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PageUp},
    {sipName_PaintAboveContent, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PaintAboveContent), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PaintAboveContent},
    {sipName_PaintBackground, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PaintBackground), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PaintBackground},
    {sipName_Paste, meth_wxRichTextCtrl_Paste, METH_VARARGS, doc_wxRichTextCtrl_Paste},
    {sipName_PopStyleSheet, meth_wxRichTextCtrl_PopStyleSheet, METH_VARARGS, doc_wxRichTextCtrl_PopStyleSheet},
    {sipName_PositionCaret, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PositionCaret), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PositionCaret},
    {sipName_PositionToXY, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PositionToXY), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PositionToXY},
    {sipName_PrepareContent, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PrepareContent), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PrepareContent},
    {sipName_PrepareContextMenu, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PrepareContextMenu), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PrepareContextMenu},
    {sipName_ProcessBackKey, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ProcessBackKey), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ProcessBackKey},
    {sipName_ProcessDelayedImageLoading, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ProcessDelayedImageLoading), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ProcessDelayedImageLoading},
    {sipName_ProcessEvent, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ProcessEvent), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ProcessEvent},
    {sipName_ProcessMouseMovement, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ProcessMouseMovement), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ProcessMouseMovement},
    {sipName_PromoteList, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PromoteList), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PromoteList},
    {sipName_PushStyleSheet, SIP_MLMETH_CAST(meth_wxRichTextCtrl_PushStyleSheet), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_PushStyleSheet},
    {sipName_Redo, meth_wxRichTextCtrl_Redo, METH_VARARGS, doc_wxRichTextCtrl_Redo},
    {sipName_RefreshForSelectionChange, SIP_MLMETH_CAST(meth_wxRichTextCtrl_RefreshForSelectionChange), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_RefreshForSelectionChange},
    {sipName_Remove, SIP_MLMETH_CAST(meth_wxRichTextCtrl_Remove), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_Remove},
    {sipName_RemoveChild, SIP_MLMETH_CAST(meth_wxRichTextCtrl_RemoveChild), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_RemoveChild},
    {sipName_Replace, SIP_MLMETH_CAST(meth_wxRichTextCtrl_Replace), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_Replace},
    {sipName_RequestDelayedImageProcessing, meth_wxRichTextCtrl_RequestDelayedImageProcessing, METH_VARARGS, doc_wxRichTextCtrl_RequestDelayedImageProcessing},
    {sipName_SaveFile, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SaveFile), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SaveFile},
    {sipName_ScrollIntoView, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ScrollIntoView), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ScrollIntoView},
    {sipName_SelectAll, meth_wxRichTextCtrl_SelectAll, METH_VARARGS, doc_wxRichTextCtrl_SelectAll},
    {sipName_SelectNone, meth_wxRichTextCtrl_SelectNone, METH_VARARGS, doc_wxRichTextCtrl_SelectNone},
    {sipName_SelectWord, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SelectWord), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SelectWord},
    {sipName_SendDestroyEvent, meth_wxRichTextCtrl_SendDestroyEvent, METH_VARARGS, SIP_NULLPTR},
    {sipName_SetAndShowDefaultStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetAndShowDefaultStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetAndShowDefaultStyle},
    {sipName_SetBasicStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetBasicStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetBasicStyle},
    {sipName_SetCanFocus, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetCanFocus), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetCanFocus},
    {sipName_SetCaretAtLineStart, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetCaretAtLineStart), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetCaretAtLineStart},
    {sipName_SetCaretPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetCaretPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetCaretPosition},
    {sipName_SetCaretPositionAfterClick, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetCaretPositionAfterClick), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetCaretPositionAfterClick},
    {sipName_SetCaretPositionForDefaultStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetCaretPositionForDefaultStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetCaretPositionForDefaultStyle},
    {sipName_SetContextMenu, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetContextMenu), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetContextMenu},
    {sipName_SetDefaultStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetDefaultStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetDefaultStyle},
    {sipName_SetDefaultStyleToCursorStyle, meth_wxRichTextCtrl_SetDefaultStyleToCursorStyle, METH_VARARGS, doc_wxRichTextCtrl_SetDefaultStyleToCursorStyle},
    {sipName_SetDelayedImageProcessingRequired, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetDelayedImageProcessingRequired), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetDelayedImageProcessingRequired},
    {sipName_SetDelayedImageProcessingTime, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetDelayedImageProcessingTime), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetDelayedImageProcessingTime},
    {sipName_SetDelayedLayoutThreshold, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetDelayedLayoutThreshold), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetDelayedLayoutThreshold},
    {sipName_SetDimensionScale, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetDimensionScale), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetDimensionScale},
    {sipName_SetDragStartPoint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetDragStartPoint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetDragStartPoint},
    {sipName_SetDragStartTime, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetDragStartTime), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetDragStartTime},
    {sipName_SetDragging, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetDragging), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetDragging},
    {sipName_SetEditable, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetEditable), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetEditable},
    {sipName_SetFilename, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetFilename), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetFilename},
    {sipName_SetFocusObject, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetFocusObject), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetFocusObject},
    {sipName_SetFont, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetFont), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetFont},
    {sipName_SetFontScale, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetFontScale), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetFontScale},
    {sipName_SetFullLayoutRequired, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetFullLayoutRequired), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetFullLayoutRequired},
    {sipName_SetFullLayoutSavedPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetFullLayoutSavedPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetFullLayoutSavedPosition},
    {sipName_SetFullLayoutTime, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetFullLayoutTime), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetFullLayoutTime},
    {sipName_SetHandlerFlags, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetHandlerFlags), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetHandlerFlags},
    {sipName_SetHint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetHint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetHint},
    {sipName_SetInsertionPoint, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetInsertionPoint), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetInsertionPoint},
    {sipName_SetInsertionPointEnd, meth_wxRichTextCtrl_SetInsertionPointEnd, METH_VARARGS, doc_wxRichTextCtrl_SetInsertionPointEnd},
    {sipName_SetInternalSelectionRange, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetInternalSelectionRange), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetInternalSelectionRange},
    {sipName_SetListStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetListStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetListStyle},
    {sipName_SetMargins, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetMargins), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetMargins},
    {sipName_SetMaxLength, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetMaxLength), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetMaxLength},
    {sipName_SetModified, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetModified), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetModified},
    {sipName_SetPreDrag, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetPreDrag), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetPreDrag},
    {sipName_SetProperties, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetProperties), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetProperties},
    {sipName_SetScale, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetScale), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetScale},
    {sipName_SetSelection, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetSelection), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetSelection},
    {sipName_SetSelectionAnchor, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetSelectionAnchor), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetSelectionAnchor},
    {sipName_SetSelectionAnchorObject, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetSelectionAnchorObject), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetSelectionAnchorObject},
    {sipName_SetSelectionRange, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetSelectionRange), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetSelectionRange},
    {sipName_SetStyle, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetStyle},
    {sipName_SetStyleEx, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetStyleEx), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetStyleEx},
    {sipName_SetStyleSheet, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetStyleSheet), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetStyleSheet},
    {sipName_SetTextCursor, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetTextCursor), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetTextCursor},
    {sipName_SetURLCursor, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetURLCursor), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetURLCursor},
    {sipName_SetValidator, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetValidator), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetValidator},
    {sipName_SetValue, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetValue), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetValue},
    {sipName_SetupScrollbars, SIP_MLMETH_CAST(meth_wxRichTextCtrl_SetupScrollbars), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_SetupScrollbars},
    {sipName_ShouldInheritColours, meth_wxRichTextCtrl_ShouldInheritColours, METH_VARARGS, doc_wxRichTextCtrl_ShouldInheritColours},
    {sipName_ShowContextMenu, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ShowContextMenu), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ShowContextMenu},
    {sipName_ShowPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_ShowPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_ShowPosition},
    {sipName_StartCellSelection, SIP_MLMETH_CAST(meth_wxRichTextCtrl_StartCellSelection), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_StartCellSelection},
    {sipName_StoreFocusObject, SIP_MLMETH_CAST(meth_wxRichTextCtrl_StoreFocusObject), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_StoreFocusObject},
    {sipName_SuppressingUndo, meth_wxRichTextCtrl_SuppressingUndo, METH_VARARGS, doc_wxRichTextCtrl_SuppressingUndo},
    {sipName_TransferDataFromWindow, meth_wxRichTextCtrl_TransferDataFromWindow, METH_VARARGS, doc_wxRichTextCtrl_TransferDataFromWindow},
    {sipName_TransferDataToWindow, meth_wxRichTextCtrl_TransferDataToWindow, METH_VARARGS, doc_wxRichTextCtrl_TransferDataToWindow},
    {sipName_TryAfter, SIP_MLMETH_CAST(meth_wxRichTextCtrl_TryAfter), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_TryAfter},
    {sipName_TryBefore, SIP_MLMETH_CAST(meth_wxRichTextCtrl_TryBefore), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_TryBefore},
    {sipName_Undo, meth_wxRichTextCtrl_Undo, METH_VARARGS, doc_wxRichTextCtrl_Undo},
    {sipName_Validate, meth_wxRichTextCtrl_Validate, METH_VARARGS, doc_wxRichTextCtrl_Validate},
    {sipName_WordLeft, SIP_MLMETH_CAST(meth_wxRichTextCtrl_WordLeft), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_WordLeft},
    {sipName_WordRight, SIP_MLMETH_CAST(meth_wxRichTextCtrl_WordRight), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_WordRight},
    {sipName_WriteField, SIP_MLMETH_CAST(meth_wxRichTextCtrl_WriteField), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_WriteField},
    {sipName_WriteImage, SIP_MLMETH_CAST(meth_wxRichTextCtrl_WriteImage), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_WriteImage},
    {sipName_WriteTable, SIP_MLMETH_CAST(meth_wxRichTextCtrl_WriteTable), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_WriteTable},
    {sipName_WriteText, SIP_MLMETH_CAST(meth_wxRichTextCtrl_WriteText), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_WriteText},
    {sipName_WriteTextBox, SIP_MLMETH_CAST(meth_wxRichTextCtrl_WriteTextBox), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_WriteTextBox},
    {sipName_XYToPosition, SIP_MLMETH_CAST(meth_wxRichTextCtrl_XYToPosition), METH_VARARGS|METH_KEYWORDS, doc_wxRichTextCtrl_XYToPosition}
};

sipVariableDef variables_wxRichTextCtrl[] = {
    {PropertyVariable, sipName_VirtualAttributesEnabled, &methods_wxRichTextCtrl[185], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_VerticalScrollbarEnabled, &methods_wxRichTextCtrl[184], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Value, &methods_wxRichTextCtrl[183], &methods_wxRichTextCtrl[341], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_URLCursor, &methods_wxRichTextCtrl[177], &methods_wxRichTextCtrl[339], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TextCursor, &methods_wxRichTextCtrl[176], &methods_wxRichTextCtrl[338], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_StyleSheet, &methods_wxRichTextCtrl[175], &methods_wxRichTextCtrl[337], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_StringSelection, &methods_wxRichTextCtrl[172], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionRange, &methods_wxRichTextCtrl[171], &methods_wxRichTextCtrl[334], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionAnchorObject, &methods_wxRichTextCtrl[170], &methods_wxRichTextCtrl[333], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionAnchor, &methods_wxRichTextCtrl[169], &methods_wxRichTextCtrl[332], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Selection, &methods_wxRichTextCtrl[168], &methods_wxRichTextCtrl[331], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Scale, &methods_wxRichTextCtrl[164], &methods_wxRichTextCtrl[330], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_PreDrag, &methods_wxRichTextCtrl[161], &methods_wxRichTextCtrl[328], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_NumberOfLines, &methods_wxRichTextCtrl[159], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Margins, &methods_wxRichTextCtrl[158], &methods_wxRichTextCtrl[325], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LastPosition, &methods_wxRichTextCtrl[153], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_InternalSelectionRange, &methods_wxRichTextCtrl[152], &methods_wxRichTextCtrl[323], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_InsertionPoint, &methods_wxRichTextCtrl[151], &methods_wxRichTextCtrl[321], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ImagesEnabled, &methods_wxRichTextCtrl[150], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Hint, &methods_wxRichTextCtrl[149], &methods_wxRichTextCtrl[320], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_HandlerFlags, &methods_wxRichTextCtrl[148], &methods_wxRichTextCtrl[319], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FullLayoutTime, &methods_wxRichTextCtrl[147], &methods_wxRichTextCtrl[318], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FullLayoutSavedPosition, &methods_wxRichTextCtrl[146], &methods_wxRichTextCtrl[317], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FullLayoutRequired, &methods_wxRichTextCtrl[145], &methods_wxRichTextCtrl[316], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FontScale, &methods_wxRichTextCtrl[144], &methods_wxRichTextCtrl[315], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FocusObject, &methods_wxRichTextCtrl[143], &methods_wxRichTextCtrl[313], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FirstVisiblePosition, &methods_wxRichTextCtrl[142], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FirstVisiblePoint, &methods_wxRichTextCtrl[141], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Filename, &methods_wxRichTextCtrl[140], &methods_wxRichTextCtrl[312], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Dragging, &methods_wxRichTextCtrl[139], &methods_wxRichTextCtrl[310], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DragStartTime, &methods_wxRichTextCtrl[138], &methods_wxRichTextCtrl[309], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DragStartPoint, &methods_wxRichTextCtrl[137], &methods_wxRichTextCtrl[308], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DimensionScale, &methods_wxRichTextCtrl[136], &methods_wxRichTextCtrl[307], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DelayedLayoutThreshold, &methods_wxRichTextCtrl[135], &methods_wxRichTextCtrl[306], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DelayedImageProcessingTime, &methods_wxRichTextCtrl[134], &methods_wxRichTextCtrl[305], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DelayedImageProcessingRequired, &methods_wxRichTextCtrl[133], &methods_wxRichTextCtrl[304], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DelayedImageLoading, &methods_wxRichTextCtrl[132], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultStyleEx, &methods_wxRichTextCtrl[131], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ContextMenuPropertiesInfo, &methods_wxRichTextCtrl[128], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ContextMenu, &methods_wxRichTextCtrl[127], &methods_wxRichTextCtrl[301], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CommandProcessor, &methods_wxRichTextCtrl[126], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretPositionForDefaultStyle, &methods_wxRichTextCtrl[122], &methods_wxRichTextCtrl[300], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretPosition, &methods_wxRichTextCtrl[121], &methods_wxRichTextCtrl[298], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretAtLineStart, &methods_wxRichTextCtrl[120], &methods_wxRichTextCtrl[297], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Buffer, &methods_wxRichTextCtrl[119], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_BasicStyle, &methods_wxRichTextCtrl[118], &methods_wxRichTextCtrl[295], SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxRichTextCtrl, "RichTextCtrl()\n"
"RichTextCtrl(parent, id=-1, value=wx.EmptyString, pos=wx.DefaultPosition, size=wx.DefaultSize, style=RE_MULTILINE, validator=wx.DefaultValidator, name=wx.TextCtrlNameStr)\n"
"\n"
"wxRichTextCtrl provides a generic, ground-up implementation of a text\n"
"control capable of showing multiple styles and images.");


sipClassTypeDef sipTypeDef__richtext_wxRichTextCtrl = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxRichTextCtrl,
        SIP_NULLPTR,
        SIP_NULLPTR
    },
    {
        sipNameNr_RichTextCtrl,
        {0, 0, 1},
        363, methods_wxRichTextCtrl,
        0, SIP_NULLPTR,
        46, variables_wxRichTextCtrl,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxRichTextCtrl,
    -1,
    -1,
    supers_wxRichTextCtrl,
    SIP_NULLPTR,
    init_type_wxRichTextCtrl,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    dealloc_wxRichTextCtrl,
    SIP_NULLPTR,
    array_wxRichTextCtrl,
    SIP_NULLPTR,
    release_wxRichTextCtrl,
    cast_wxRichTextCtrl,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
};
