/*
 * Interface wrapper code.
 *
 * Generated by SIP 6.7.9
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_grid.h"
        #include <wx/grid.h>
        #include <wx/window.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/window.h>
        #include <wx/event.h>
        #include <wx/validate.h>
        #include <wx/colour.h>
        #include <wx/dc.h>
        #include <wx/gdicmn.h>
        #include <wx/grid.h>
        #include <wx/headerctrl.h>
        #include <wx/region.h>
        #include <wx/grid.h>
        #include <wx/grid.h>
        #include <wx/object.h>
        #include <wx/grid.h>
        #include <wx/grid.h>
        #include <wx/grid.h>
        #include <wx/grid.h>
        #include <wx/grid.h>
        #include <wx/font.h>
        #include <wx/pen.h>
        #include "arrayholder.h"
        #include <wx/grid.h>
        #include <wx/event.h>
        #include <wx/event.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/event.h>
        #include <wx/cursor.h>
        #include <wx/caret.h>
        #include <wx/layout.h>
        #include <wx/sizer.h>
        #include <wx/dnd.h>
        #include <wx/access.h>
        #include <wx/accel.h>
        #include <wx/menu.h>
        #include <wx/tooltip.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/palette.h>
        #include <wx/eventfilter.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>
    PyObject* _wxGrid_GetSelectedRowBlocks(const wxGrid* self)
    {
        wxPyThreadBlocker blocker;
        PyObject* result = PyList_New(0);
        wxGridBlockCoordsVector vector = self->GetSelectedRowBlocks();
        for (size_t idx=0; idx < vector.size(); idx++) {
            PyObject* obj;
            wxGridBlockCoords* item = new wxGridBlockCoords(vector[idx]);
            obj = wxPyConstructObject((void*)item, "wxGridBlockCoords", true);
            PyList_Append(result, obj);
            Py_DECREF(obj);
        }
        return result;
    }
    PyObject* _wxGrid_GetSelectedColBlocks(const wxGrid* self)
    {
        wxPyThreadBlocker blocker;
        PyObject* result = PyList_New(0);
        wxGridBlockCoordsVector vector = self->GetSelectedColBlocks();
        for (size_t idx=0; idx < vector.size(); idx++) {
            PyObject* obj;
            wxGridBlockCoords* item = new wxGridBlockCoords(vector[idx]);
            obj = wxPyConstructObject((void*)item, "wxGridBlockCoords", true);
            PyList_Append(result, obj);
            Py_DECREF(obj);
        }
        return result;
    }


class sipwxGrid : public  ::wxGrid
{
public:
    sipwxGrid();
    sipwxGrid( ::wxWindow*, ::wxWindowID,const  ::wxPoint&,const  ::wxSize&,long,const  ::wxString&);
    virtual ~sipwxGrid();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    void sipProtect_SendDestroyEvent();
    bool sipProtectVirt_ShouldScrollToChildOnFocus(bool, ::wxWindow*);
    bool sipProtectVirt_ProcessEvent(bool, ::wxEvent&);
    void sipProtectVirt_DoEnable(bool,bool);
    void sipProtectVirt_DoGetPosition(bool,int*,int*) const;
    void sipProtectVirt_DoGetSize(bool,int*,int*) const;
    void sipProtectVirt_DoGetClientSize(bool,int*,int*) const;
     ::wxSize sipProtectVirt_DoGetBestSize(bool) const;
     ::wxSize sipProtectVirt_DoGetBestClientSize(bool) const;
    void sipProtectVirt_DoSetSize(bool,int,int,int,int,int);
    void sipProtectVirt_DoSetClientSize(bool,int,int);
    void sipProtectVirt_DoSetSizeHints(bool,int,int,int,int,int,int);
    void sipProtectVirt_DoMoveWindow(bool,int,int,int,int);
    void sipProtectVirt_DoSetWindowVariant(bool, ::wxWindowVariant);
     ::wxBorder sipProtectVirt_GetDefaultBorder(bool) const;
     ::wxBorder sipProtectVirt_GetDefaultBorderForControl(bool) const;
    void sipProtectVirt_DoFreeze(bool);
    void sipProtectVirt_DoThaw(bool);
    bool sipProtectVirt_HasTransparentBackground(bool);
    bool sipProtectVirt_TryBefore(bool, ::wxEvent&);
    bool sipProtectVirt_TryAfter(bool, ::wxEvent&);
    bool sipProtect_CanHaveAttributes() const;
    int sipProtect_GetColMinimalWidth(int) const;
    int sipProtect_GetColRight(int) const;
    int sipProtect_GetColLeft(int) const;
    int sipProtect_GetRowMinimalHeight(int) const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::wxPen GetRowGridLinePen(int) SIP_OVERRIDE;
     ::wxPen GetDefaultGridLinePen() SIP_OVERRIDE;
     ::wxPen GetColGridLinePen(int) SIP_OVERRIDE;
     ::wxSize DoGetBestClientSize() const SIP_OVERRIDE;
     ::wxSize DoGetBestSize() const SIP_OVERRIDE;
    void DoThaw() SIP_OVERRIDE;
    void DoFreeze() SIP_OVERRIDE;
     ::wxBorder GetDefaultBorderForControl() const SIP_OVERRIDE;
     ::wxBorder GetDefaultBorder() const SIP_OVERRIDE;
    void DoSetWindowVariant( ::wxWindowVariant) SIP_OVERRIDE;
    void DoMoveWindow(int,int,int,int) SIP_OVERRIDE;
    void DoSetSizeHints(int,int,int,int,int,int) SIP_OVERRIDE;
    void DoSetClientSize(int,int) SIP_OVERRIDE;
    void DoSetSize(int,int,int,int,int) SIP_OVERRIDE;
    void DoGetClientSize(int*,int*) const SIP_OVERRIDE;
    void DoGetSize(int*,int*) const SIP_OVERRIDE;
    void DoGetPosition(int*,int*) const SIP_OVERRIDE;
    void DoEnable(bool) SIP_OVERRIDE;
     ::wxWindow* GetMainWindowOfCompositeControl() SIP_OVERRIDE;
    void OnInternalIdle() SIP_OVERRIDE;
    void InitDialog() SIP_OVERRIDE;
    void InheritAttributes() SIP_OVERRIDE;
    bool Destroy() SIP_OVERRIDE;
    bool Validate() SIP_OVERRIDE;
    bool TransferDataToWindow() SIP_OVERRIDE;
    bool TransferDataFromWindow() SIP_OVERRIDE;
    void SetValidator(const  ::wxValidator&) SIP_OVERRIDE;
     ::wxValidator* GetValidator() SIP_OVERRIDE;
    bool ShouldInheritColours() const SIP_OVERRIDE;
    bool HasTransparentBackground() SIP_OVERRIDE;
     ::wxPoint GetClientAreaOrigin() const SIP_OVERRIDE;
    bool InformFirstDirection(int,int,int) SIP_OVERRIDE;
    void EnableVisibleFocus(bool) SIP_OVERRIDE;
    void SetCanFocus(bool) SIP_OVERRIDE;
    bool AcceptsFocusRecursively() const SIP_OVERRIDE;
    bool AcceptsFocusFromKeyboard() const SIP_OVERRIDE;
    bool AcceptsFocus() const SIP_OVERRIDE;
    bool TryAfter( ::wxEvent&) SIP_OVERRIDE;
    bool TryBefore( ::wxEvent&) SIP_OVERRIDE;
    bool ProcessEvent( ::wxEvent&) SIP_OVERRIDE;
    void AddChild( ::wxWindowBase*) SIP_OVERRIDE;
    void RemoveChild( ::wxWindowBase*) SIP_OVERRIDE;
    void OnDraw( ::wxDC&) SIP_OVERRIDE;
    bool SendAutoScrollEvents( ::wxScrollWinEvent&) const SIP_OVERRIDE;
    bool ShouldScrollToChildOnFocus( ::wxWindow*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxGrid(const sipwxGrid &);
    sipwxGrid &operator = (const sipwxGrid &);

    char sipPyMethods[45];
};

sipwxGrid::sipwxGrid():  ::wxGrid(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxGrid::sipwxGrid( ::wxWindow*parent, ::wxWindowID id,const  ::wxPoint& pos,const  ::wxSize& size,long style,const  ::wxString& name):  ::wxGrid(parent,id,pos,size,style,name), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxGrid::~sipwxGrid()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

 ::wxPen sipwxGrid::GetRowGridLinePen(int row)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[0], &sipPySelf, SIP_NULLPTR, sipName_GetRowGridLinePen);

    if (!sipMeth)
        return  ::wxGrid::GetRowGridLinePen(row);

    extern  ::wxPen sipVH__grid_66(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH__grid_66(sipGILState, 0, sipPySelf, sipMeth, row);
}

 ::wxPen sipwxGrid::GetDefaultGridLinePen()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[1], &sipPySelf, SIP_NULLPTR, sipName_GetDefaultGridLinePen);

    if (!sipMeth)
        return  ::wxGrid::GetDefaultGridLinePen();

    extern  ::wxPen sipVH__grid_67(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_67(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxPen sipwxGrid::GetColGridLinePen(int col)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[2], &sipPySelf, SIP_NULLPTR, sipName_GetColGridLinePen);

    if (!sipMeth)
        return  ::wxGrid::GetColGridLinePen(col);

    extern  ::wxPen sipVH__grid_66(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH__grid_66(sipGILState, 0, sipPySelf, sipMeth, col);
}

 ::wxSize sipwxGrid::DoGetBestClientSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[3]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetBestClientSize);

    if (!sipMeth)
        return  ::wxGrid::DoGetBestClientSize();

    extern  ::wxSize sipVH__grid_65(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_65(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxSize sipwxGrid::DoGetBestSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[4]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetBestSize);

    if (!sipMeth)
        return  ::wxGrid::DoGetBestSize();

    extern  ::wxSize sipVH__grid_65(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_65(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGrid::DoThaw()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[5], &sipPySelf, SIP_NULLPTR, sipName_DoThaw);

    if (!sipMeth)
    {
         ::wxGrid::DoThaw();
        return;
    }

    extern void sipVH__grid_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__grid_9(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGrid::DoFreeze()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[6], &sipPySelf, SIP_NULLPTR, sipName_DoFreeze);

    if (!sipMeth)
    {
         ::wxGrid::DoFreeze();
        return;
    }

    extern void sipVH__grid_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__grid_9(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxGrid::GetDefaultBorderForControl() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[7]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetDefaultBorderForControl);

    if (!sipMeth)
        return  ::wxGrid::GetDefaultBorderForControl();

    extern  ::wxBorder sipVH__grid_64(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_64(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxGrid::GetDefaultBorder() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[8]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetDefaultBorder);

    if (!sipMeth)
        return  ::wxGrid::GetDefaultBorder();

    extern  ::wxBorder sipVH__grid_64(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_64(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGrid::DoSetWindowVariant( ::wxWindowVariant variant)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[9], &sipPySelf, SIP_NULLPTR, sipName_DoSetWindowVariant);

    if (!sipMeth)
    {
         ::wxGrid::DoSetWindowVariant(variant);
        return;
    }

    extern void sipVH__grid_63(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowVariant);

    sipVH__grid_63(sipGILState, 0, sipPySelf, sipMeth, variant);
}

void sipwxGrid::DoMoveWindow(int x,int y,int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[10], &sipPySelf, SIP_NULLPTR, sipName_DoMoveWindow);

    if (!sipMeth)
    {
         ::wxGrid::DoMoveWindow(x,y,width,height);
        return;
    }

    extern void sipVH__grid_62(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int);

    sipVH__grid_62(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height);
}

void sipwxGrid::DoSetSizeHints(int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[11], &sipPySelf, SIP_NULLPTR, sipName_DoSetSizeHints);

    if (!sipMeth)
    {
         ::wxGrid::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH);
        return;
    }

    extern void sipVH__grid_61(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int,int);

    sipVH__grid_61(sipGILState, 0, sipPySelf, sipMeth, minW, minH, maxW, maxH, incW, incH);
}

void sipwxGrid::DoSetClientSize(int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[12], &sipPySelf, SIP_NULLPTR, sipName_DoSetClientSize);

    if (!sipMeth)
    {
         ::wxGrid::DoSetClientSize(width,height);
        return;
    }

    extern void sipVH__grid_60(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int);

    sipVH__grid_60(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxGrid::DoSetSize(int x,int y,int width,int height,int sizeFlags)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[13], &sipPySelf, SIP_NULLPTR, sipName_DoSetSize);

    if (!sipMeth)
    {
         ::wxGrid::DoSetSize(x,y,width,height,sizeFlags);
        return;
    }

    extern void sipVH__grid_59(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int);

    sipVH__grid_59(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height, sizeFlags);
}

void sipwxGrid::DoGetClientSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[14]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetClientSize);

    if (!sipMeth)
    {
         ::wxGrid::DoGetClientSize(width,height);
        return;
    }

    extern void sipVH__grid_58(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__grid_58(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxGrid::DoGetSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[15]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetSize);

    if (!sipMeth)
    {
         ::wxGrid::DoGetSize(width,height);
        return;
    }

    extern void sipVH__grid_58(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__grid_58(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxGrid::DoGetPosition(int*x,int*y) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[16]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetPosition);

    if (!sipMeth)
    {
         ::wxGrid::DoGetPosition(x,y);
        return;
    }

    extern void sipVH__grid_58(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__grid_58(sipGILState, 0, sipPySelf, sipMeth, x, y);
}

void sipwxGrid::DoEnable(bool enable)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[17], &sipPySelf, SIP_NULLPTR, sipName_DoEnable);

    if (!sipMeth)
    {
         ::wxGrid::DoEnable(enable);
        return;
    }

    extern void sipVH__grid_53(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__grid_53(sipGILState, 0, sipPySelf, sipMeth, enable);
}

 ::wxWindow* sipwxGrid::GetMainWindowOfCompositeControl()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[18], &sipPySelf, SIP_NULLPTR, sipName_GetMainWindowOfCompositeControl);

    if (!sipMeth)
        return  ::wxGrid::GetMainWindowOfCompositeControl();

    extern  ::wxWindow* sipVH__grid_57(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_57(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGrid::OnInternalIdle()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[19], &sipPySelf, SIP_NULLPTR, sipName_OnInternalIdle);

    if (!sipMeth)
    {
         ::wxGrid::OnInternalIdle();
        return;
    }

    extern void sipVH__grid_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__grid_9(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGrid::InitDialog()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[20], &sipPySelf, SIP_NULLPTR, sipName_InitDialog);

    if (!sipMeth)
    {
         ::wxGrid::InitDialog();
        return;
    }

    extern void sipVH__grid_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__grid_9(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGrid::InheritAttributes()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[21], &sipPySelf, SIP_NULLPTR, sipName_InheritAttributes);

    if (!sipMeth)
    {
         ::wxGrid::InheritAttributes();
        return;
    }

    extern void sipVH__grid_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__grid_9(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::Destroy()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[22], &sipPySelf, SIP_NULLPTR, sipName_Destroy);

    if (!sipMeth)
        return  ::wxGrid::Destroy();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::Validate()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[23], &sipPySelf, SIP_NULLPTR, sipName_Validate);

    if (!sipMeth)
        return  ::wxGrid::Validate();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::TransferDataToWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[24], &sipPySelf, SIP_NULLPTR, sipName_TransferDataToWindow);

    if (!sipMeth)
        return  ::wxGrid::TransferDataToWindow();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::TransferDataFromWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[25], &sipPySelf, SIP_NULLPTR, sipName_TransferDataFromWindow);

    if (!sipMeth)
        return  ::wxGrid::TransferDataFromWindow();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGrid::SetValidator(const  ::wxValidator& validator)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[26], &sipPySelf, SIP_NULLPTR, sipName_SetValidator);

    if (!sipMeth)
    {
         ::wxGrid::SetValidator(validator);
        return;
    }

    extern void sipVH__grid_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxValidator&);

    sipVH__grid_18(sipGILState, 0, sipPySelf, sipMeth, validator);
}

 ::wxValidator* sipwxGrid::GetValidator()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[27], &sipPySelf, SIP_NULLPTR, sipName_GetValidator);

    if (!sipMeth)
        return  ::wxGrid::GetValidator();

    extern  ::wxValidator* sipVH__grid_56(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_56(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::ShouldInheritColours() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[28]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_ShouldInheritColours);

    if (!sipMeth)
        return  ::wxGrid::ShouldInheritColours();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::HasTransparentBackground()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[29], &sipPySelf, SIP_NULLPTR, sipName_HasTransparentBackground);

    if (!sipMeth)
        return  ::wxGrid::HasTransparentBackground();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxPoint sipwxGrid::GetClientAreaOrigin() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[30]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetClientAreaOrigin);

    if (!sipMeth)
        return  ::wxGrid::GetClientAreaOrigin();

    extern  ::wxPoint sipVH__grid_55(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_55(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::InformFirstDirection(int direction,int size,int availableOtherDir)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[31], &sipPySelf, SIP_NULLPTR, sipName_InformFirstDirection);

    if (!sipMeth)
        return  ::wxGrid::InformFirstDirection(direction,size,availableOtherDir);

    extern bool sipVH__grid_54(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int);

    return sipVH__grid_54(sipGILState, 0, sipPySelf, sipMeth, direction, size, availableOtherDir);
}

void sipwxGrid::EnableVisibleFocus(bool enabled)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[32], &sipPySelf, SIP_NULLPTR, sipName_EnableVisibleFocus);

    if (!sipMeth)
    {
         ::wxGrid::EnableVisibleFocus(enabled);
        return;
    }

    extern void sipVH__grid_53(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__grid_53(sipGILState, 0, sipPySelf, sipMeth, enabled);
}

void sipwxGrid::SetCanFocus(bool canFocus)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[33], &sipPySelf, SIP_NULLPTR, sipName_SetCanFocus);

    if (!sipMeth)
    {
         ::wxGrid::SetCanFocus(canFocus);
        return;
    }

    extern void sipVH__grid_53(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__grid_53(sipGILState, 0, sipPySelf, sipMeth, canFocus);
}

bool sipwxGrid::AcceptsFocusRecursively() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[34]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocusRecursively);

    if (!sipMeth)
        return  ::wxGrid::AcceptsFocusRecursively();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::AcceptsFocusFromKeyboard() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[35]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocusFromKeyboard);

    if (!sipMeth)
        return  ::wxGrid::AcceptsFocusFromKeyboard();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::AcceptsFocus() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[36]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocus);

    if (!sipMeth)
        return  ::wxGrid::AcceptsFocus();

    extern bool sipVH__grid_44(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__grid_44(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGrid::TryAfter( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[37], &sipPySelf, SIP_NULLPTR, sipName_TryAfter);

    if (!sipMeth)
        return  ::wxGrid::TryAfter(event);

    extern bool sipVH__grid_52(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__grid_52(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxGrid::TryBefore( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[38], &sipPySelf, SIP_NULLPTR, sipName_TryBefore);

    if (!sipMeth)
        return  ::wxGrid::TryBefore(event);

    extern bool sipVH__grid_52(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__grid_52(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxGrid::ProcessEvent( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[39], &sipPySelf, SIP_NULLPTR, sipName_ProcessEvent);

    if (!sipMeth)
        return  ::wxGrid::ProcessEvent(event);

    extern bool sipVH__grid_52(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__grid_52(sipGILState, 0, sipPySelf, sipMeth, event);
}

void sipwxGrid::AddChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[40], &sipPySelf, SIP_NULLPTR, sipName_AddChild);

    if (!sipMeth)
    {
         ::wxGrid::AddChild(child);
        return;
    }

    extern void sipVH__grid_51(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__grid_51(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxGrid::RemoveChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[41], &sipPySelf, SIP_NULLPTR, sipName_RemoveChild);

    if (!sipMeth)
    {
         ::wxGrid::RemoveChild(child);
        return;
    }

    extern void sipVH__grid_51(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__grid_51(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxGrid::OnDraw( ::wxDC& dc)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[42], &sipPySelf, SIP_NULLPTR, sipName_OnDraw);

    if (!sipMeth)
    {
         ::wxGrid::OnDraw(dc);
        return;
    }

    extern void sipVH__grid_50(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxDC&);

    sipVH__grid_50(sipGILState, 0, sipPySelf, sipMeth, dc);
}

bool sipwxGrid::SendAutoScrollEvents( ::wxScrollWinEvent& event) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[43]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_SendAutoScrollEvents);

    if (!sipMeth)
        return  ::wxGrid::SendAutoScrollEvents(event);

    extern bool sipVH__grid_49(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxScrollWinEvent&);

    return sipVH__grid_49(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxGrid::ShouldScrollToChildOnFocus( ::wxWindow*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[44], &sipPySelf, SIP_NULLPTR, sipName_ShouldScrollToChildOnFocus);

    if (!sipMeth)
        return  ::wxGrid::ShouldScrollToChildOnFocus(child);

    extern bool sipVH__grid_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindow*);

    return sipVH__grid_48(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxGrid::sipProtect_SendDestroyEvent()
{
     ::wxWindow::SendDestroyEvent();
}

bool sipwxGrid::sipProtectVirt_ShouldScrollToChildOnFocus(bool sipSelfWasArg, ::wxWindow*child)
{
    return (sipSelfWasArg ?  ::wxScrolledCanvas::ShouldScrollToChildOnFocus(child) : ShouldScrollToChildOnFocus(child));
}

bool sipwxGrid::sipProtectVirt_ProcessEvent(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxGrid::ProcessEvent(event) : ProcessEvent(event));
}

void sipwxGrid::sipProtectVirt_DoEnable(bool sipSelfWasArg,bool enable)
{
    (sipSelfWasArg ?  ::wxGrid::DoEnable(enable) : DoEnable(enable));
}

void sipwxGrid::sipProtectVirt_DoGetPosition(bool sipSelfWasArg,int*x,int*y) const
{
    (sipSelfWasArg ?  ::wxGrid::DoGetPosition(x,y) : DoGetPosition(x,y));
}

void sipwxGrid::sipProtectVirt_DoGetSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxGrid::DoGetSize(width,height) : DoGetSize(width,height));
}

void sipwxGrid::sipProtectVirt_DoGetClientSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxGrid::DoGetClientSize(width,height) : DoGetClientSize(width,height));
}

 ::wxSize sipwxGrid::sipProtectVirt_DoGetBestSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxGrid::DoGetBestSize() : DoGetBestSize());
}

 ::wxSize sipwxGrid::sipProtectVirt_DoGetBestClientSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxGrid::DoGetBestClientSize() : DoGetBestClientSize());
}

void sipwxGrid::sipProtectVirt_DoSetSize(bool sipSelfWasArg,int x,int y,int width,int height,int sizeFlags)
{
    (sipSelfWasArg ?  ::wxGrid::DoSetSize(x,y,width,height,sizeFlags) : DoSetSize(x,y,width,height,sizeFlags));
}

void sipwxGrid::sipProtectVirt_DoSetClientSize(bool sipSelfWasArg,int width,int height)
{
    (sipSelfWasArg ?  ::wxGrid::DoSetClientSize(width,height) : DoSetClientSize(width,height));
}

void sipwxGrid::sipProtectVirt_DoSetSizeHints(bool sipSelfWasArg,int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    (sipSelfWasArg ?  ::wxGrid::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH) : DoSetSizeHints(minW,minH,maxW,maxH,incW,incH));
}

void sipwxGrid::sipProtectVirt_DoMoveWindow(bool sipSelfWasArg,int x,int y,int width,int height)
{
    (sipSelfWasArg ?  ::wxGrid::DoMoveWindow(x,y,width,height) : DoMoveWindow(x,y,width,height));
}

void sipwxGrid::sipProtectVirt_DoSetWindowVariant(bool sipSelfWasArg, ::wxWindowVariant variant)
{
    (sipSelfWasArg ?  ::wxGrid::DoSetWindowVariant(variant) : DoSetWindowVariant(variant));
}

 ::wxBorder sipwxGrid::sipProtectVirt_GetDefaultBorder(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxGrid::GetDefaultBorder() : GetDefaultBorder());
}

 ::wxBorder sipwxGrid::sipProtectVirt_GetDefaultBorderForControl(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxGrid::GetDefaultBorderForControl() : GetDefaultBorderForControl());
}

void sipwxGrid::sipProtectVirt_DoFreeze(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxGrid::DoFreeze() : DoFreeze());
}

void sipwxGrid::sipProtectVirt_DoThaw(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxGrid::DoThaw() : DoThaw());
}

bool sipwxGrid::sipProtectVirt_HasTransparentBackground(bool sipSelfWasArg)
{
    return (sipSelfWasArg ?  ::wxGrid::HasTransparentBackground() : HasTransparentBackground());
}

bool sipwxGrid::sipProtectVirt_TryBefore(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxGrid::TryBefore(event) : TryBefore(event));
}

bool sipwxGrid::sipProtectVirt_TryAfter(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxGrid::TryAfter(event) : TryAfter(event));
}

bool sipwxGrid::sipProtect_CanHaveAttributes() const
{
    return  ::wxGrid::CanHaveAttributes();
}

int sipwxGrid::sipProtect_GetColMinimalWidth(int col) const
{
    return  ::wxGrid::GetColMinimalWidth(col);
}

int sipwxGrid::sipProtect_GetColRight(int col) const
{
    return  ::wxGrid::GetColRight(col);
}

int sipwxGrid::sipProtect_GetColLeft(int col) const
{
    return  ::wxGrid::GetColLeft(col);
}

int sipwxGrid::sipProtect_GetRowMinimalHeight(int col) const
{
    return  ::wxGrid::GetRowMinimalHeight(col);
}


PyDoc_STRVAR(doc_wxGrid_SendDestroyEvent, "SendDestroyEvent()\n"
"\n"
"Generate wxWindowDestroyEvent for this window.");

extern "C" {static PyObject *meth_wxGrid_SendDestroyEvent(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SendDestroyEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtect_SendDestroyEvent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SendDestroyEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ShouldScrollToChildOnFocus, "ShouldScrollToChildOnFocus(child) -> bool\n"
"\n"
"This method can be overridden in a derived class to prevent scrolling\n"
"the child window into view automatically when it gets focus.");

extern "C" {static PyObject *meth_wxGrid_ShouldScrollToChildOnFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ShouldScrollToChildOnFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow* child;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_child,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxWindow, &child))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_ShouldScrollToChildOnFocus(sipSelfWasArg,child);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ShouldScrollToChildOnFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_Create, "Create(parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.WANTS_CHARS, name=GridNameStr) -> bool\n"
"\n"
"Creates the grid window for an object initialized using the default\n"
"constructor.");

extern "C" {static PyObject *meth_wxGrid_Create(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_Create(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* parent;
         ::wxWindowID id = wxID_ANY;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        long style = wxWANTS_CHARS;
        const  ::wxString& namedef = wxGridNameStr;
        const  ::wxString* name = &namedef;
        int nameState = 0;
        sipWrapper *sipOwner = SIP_NULLPTR;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_parent,
            sipName_id,
            sipName_pos,
            sipName_size,
            sipName_style,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJH|iJ1J1lJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxWindow, &parent, &sipOwner, &id, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, &style, sipType_wxString, &name, &nameState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Create(parent,id,*pos,*size,style,*name);
            Py_END_ALLOW_THREADS

            if (sipOwner)
                sipTransferTo(sipSelf, (PyObject *)sipOwner);
            else
                sipTransferBack(sipSelf);
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_Create, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CreateGrid, "CreateGrid(numRows, numCols, selmode=GridSelectCells) -> bool\n"
"\n"
"Creates a grid with the specified initial number of rows and columns.");

extern "C" {static PyObject *meth_wxGrid_CreateGrid(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CreateGrid(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int numRows;
        int numCols;
         ::wxGrid::wxGridSelectionModes selmode =  ::wxGrid::wxGridSelectCells;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_numRows,
            sipName_numCols,
            sipName_selmode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|E", &sipSelf, sipType_wxGrid, &sipCpp, &numRows, &numCols, sipType_wxGrid_wxGridSelectionModes, &selmode))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CreateGrid(numRows,numCols,selmode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CreateGrid, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid__SetTable, "_SetTable(table, takeOwnership=False, selmode=GridSelectCells) -> bool\n"
"\n"
"Passes a pointer to a custom grid table to be used by the grid.");

extern "C" {static PyObject *meth_wxGrid__SetTable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid__SetTable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGridTableBase* table;
        bool takeOwnership = 0;
         ::wxGrid::wxGridSelectionModes selmode =  ::wxGrid::wxGridSelectCells;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_table,
            sipName_takeOwnership,
            sipName_selmode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|bE", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridTableBase, &table, &takeOwnership, sipType_wxGrid_wxGridSelectionModes, &selmode))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetTable(table,takeOwnership,selmode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName__SetTable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AssignTable, "AssignTable(table, selmode=GridSelectCells)\n"
"\n"
"Assigns a pointer to a custom grid table to be used by the grid.");

extern "C" {static PyObject *meth_wxGrid_AssignTable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AssignTable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGridTableBase* table;
         ::wxGrid::wxGridSelectionModes selmode =  ::wxGrid::wxGridSelectCells;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_table,
            sipName_selmode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|E", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridTableBase, &table, sipType_wxGrid_wxGridSelectionModes, &selmode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AssignTable(table,selmode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AssignTable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ProcessTableMessage, "ProcessTableMessage(msg) -> bool\n"
"\n"
"Receive and handle a message from the table.");

extern "C" {static PyObject *meth_wxGrid_ProcessTableMessage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ProcessTableMessage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGridTableMessage* msg;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridTableMessage, &msg))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ProcessTableMessage(*msg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ProcessTableMessage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableGridLines, "EnableGridLines(enable=True)\n"
"\n"
"Turns the drawing of grid lines on or off.");

extern "C" {static PyObject *meth_wxGrid_EnableGridLines(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableGridLines(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableGridLines(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableGridLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColGridLinePen, "GetColGridLinePen(col) -> wx.Pen\n"
"\n"
"Returns the pen used for vertical grid lines.");

extern "C" {static PyObject *meth_wxGrid_GetColGridLinePen(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColGridLinePen(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
             ::wxPen*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPen((sipSelfWasArg ? sipCpp-> ::wxGrid::GetColGridLinePen(col) : sipCpp->GetColGridLinePen(col)));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPen,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColGridLinePen, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultGridLinePen, "GetDefaultGridLinePen() -> wx.Pen\n"
"\n"
"Returns the pen used for grid lines.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultGridLinePen(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultGridLinePen(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxPen*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPen((sipSelfWasArg ? sipCpp-> ::wxGrid::GetDefaultGridLinePen() : sipCpp->GetDefaultGridLinePen()));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPen,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultGridLinePen, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridLineColour, "GetGridLineColour() -> wx.Colour\n"
"\n"
"Returns the colour used for grid lines.");

extern "C" {static PyObject *meth_wxGrid_GetGridLineColour(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridLineColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetGridLineColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridLineColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowGridLinePen, "GetRowGridLinePen(row) -> wx.Pen\n"
"\n"
"Returns the pen used for horizontal grid lines.");

extern "C" {static PyObject *meth_wxGrid_GetRowGridLinePen(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowGridLinePen(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int row;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &row))
        {
             ::wxPen*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPen((sipSelfWasArg ? sipCpp-> ::wxGrid::GetRowGridLinePen(row) : sipCpp->GetRowGridLinePen(row)));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPen,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowGridLinePen, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GridLinesEnabled, "GridLinesEnabled() -> bool\n"
"\n"
"Returns true if drawing of grid lines is turned on, false otherwise.");

extern "C" {static PyObject *meth_wxGrid_GridLinesEnabled(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GridLinesEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GridLinesEnabled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GridLinesEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetGridLineColour, "SetGridLineColour(colour)\n"
"\n"
"Sets the colour used to draw grid lines.");

extern "C" {static PyObject *meth_wxGrid_SetGridLineColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetGridLineColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetGridLineColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetGridLineColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColLabelAlignment, "GetColLabelAlignment() -> (horiz, vert)\n"
"\n"
"Sets the arguments to the current column label alignment values.");

extern "C" {static PyObject *meth_wxGrid_GetColLabelAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColLabelAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int horiz;
        int vert;
        const  ::wxGrid *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GetColLabelAlignment(&horiz,&vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",horiz,vert);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColLabelAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColLabelTextOrientation, "GetColLabelTextOrientation() -> int\n"
"\n"
"Returns the orientation of the column labels (either wxHORIZONTAL or\n"
"wxVERTICAL).");

extern "C" {static PyObject *meth_wxGrid_GetColLabelTextOrientation(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColLabelTextOrientation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColLabelTextOrientation();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColLabelTextOrientation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColLabelValue, "GetColLabelValue(col) -> String\n"
"\n"
"Returns the specified column label.");

extern "C" {static PyObject *meth_wxGrid_GetColLabelValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColLabelValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetColLabelValue(col));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColLabelValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCornerLabelAlignment, "GetCornerLabelAlignment(horiz, vert)\n"
"\n"
"Sets the arguments to the current corner label alignment values.");

extern "C" {static PyObject *meth_wxGrid_GetCornerLabelAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCornerLabelAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int horiz;
        int vert;
        const  ::wxGrid *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GetCornerLabelAlignment(&horiz,&vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",horiz,vert);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCornerLabelAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCornerLabelTextOrientation, "GetCornerLabelTextOrientation() -> int\n"
"\n"
"Returns the orientation of the corner label (either wxHORIZONTAL or\n"
"wxVERTICAL).");

extern "C" {static PyObject *meth_wxGrid_GetCornerLabelTextOrientation(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCornerLabelTextOrientation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCornerLabelTextOrientation();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCornerLabelTextOrientation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCornerLabelValue, "GetCornerLabelValue() -> String\n"
"\n"
"Returns the (top-left) corner label.");

extern "C" {static PyObject *meth_wxGrid_GetCornerLabelValue(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCornerLabelValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetCornerLabelValue());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCornerLabelValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetLabelBackgroundColour, "GetLabelBackgroundColour() -> wx.Colour\n"
"\n"
"Returns the colour used for the background of row and column labels.");

extern "C" {static PyObject *meth_wxGrid_GetLabelBackgroundColour(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetLabelBackgroundColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetLabelBackgroundColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetLabelBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetLabelFont, "GetLabelFont() -> wx.Font\n"
"\n"
"Returns the font used for row and column labels.");

extern "C" {static PyObject *meth_wxGrid_GetLabelFont(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetLabelFont(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxFont*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxFont(sipCpp->GetLabelFont());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxFont,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetLabelFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetLabelTextColour, "GetLabelTextColour() -> wx.Colour\n"
"\n"
"Returns the colour used for row and column label text.");

extern "C" {static PyObject *meth_wxGrid_GetLabelTextColour(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetLabelTextColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetLabelTextColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetLabelTextColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowLabelAlignment, "GetRowLabelAlignment() -> (horiz, vert)\n"
"\n"
"Returns the alignment used for row labels.");

extern "C" {static PyObject *meth_wxGrid_GetRowLabelAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowLabelAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int horiz;
        int vert;
        const  ::wxGrid *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GetRowLabelAlignment(&horiz,&vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",horiz,vert);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowLabelAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowLabelValue, "GetRowLabelValue(row) -> String\n"
"\n"
"Returns the specified row label.");

extern "C" {static PyObject *meth_wxGrid_GetRowLabelValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowLabelValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &row))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetRowLabelValue(row));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowLabelValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_HideColLabels, "HideColLabels()\n"
"\n"
"Hides the column labels by calling SetColLabelSize() with a size of 0.");

extern "C" {static PyObject *meth_wxGrid_HideColLabels(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_HideColLabels(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HideColLabels();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_HideColLabels, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_HideRowLabels, "HideRowLabels()\n"
"\n"
"Hides the row labels by calling SetRowLabelSize() with a size of 0.");

extern "C" {static PyObject *meth_wxGrid_HideRowLabels(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_HideRowLabels(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HideRowLabels();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_HideRowLabels, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColLabelAlignment, "SetColLabelAlignment(horiz, vert)\n"
"\n"
"Sets the horizontal and vertical alignment of column label text.");

extern "C" {static PyObject *meth_wxGrid_SetColLabelAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColLabelAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int horiz;
        int vert;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_horiz,
            sipName_vert,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &horiz, &vert))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColLabelAlignment(horiz,vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColLabelAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColLabelTextOrientation, "SetColLabelTextOrientation(textOrientation)\n"
"\n"
"Sets the orientation of the column labels (either wxHORIZONTAL or\n"
"wxVERTICAL).");

extern "C" {static PyObject *meth_wxGrid_SetColLabelTextOrientation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColLabelTextOrientation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int textOrientation;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_textOrientation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &textOrientation))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColLabelTextOrientation(textOrientation);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColLabelTextOrientation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColLabelValue, "SetColLabelValue(col, value)\n"
"\n"
"Set the value for the given column label.");

extern "C" {static PyObject *meth_wxGrid_SetColLabelValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColLabelValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const  ::wxString* value;
        int valueState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxGrid, &sipCpp, &col, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColLabelValue(col,*value);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColLabelValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCornerLabelAlignment, "SetCornerLabelAlignment(horiz, vert)\n"
"\n"
"Sets the horizontal and vertical alignment of the (top-left) corner\n"
"label text.");

extern "C" {static PyObject *meth_wxGrid_SetCornerLabelAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCornerLabelAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int horiz;
        int vert;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_horiz,
            sipName_vert,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &horiz, &vert))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCornerLabelAlignment(horiz,vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCornerLabelAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCornerLabelTextOrientation, "SetCornerLabelTextOrientation(textOrientation)\n"
"\n"
"Sets the orientation of the (top-left) corner label (either\n"
"wxHORIZONTAL or wxVERTICAL).");

extern "C" {static PyObject *meth_wxGrid_SetCornerLabelTextOrientation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCornerLabelTextOrientation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int textOrientation;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_textOrientation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &textOrientation))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCornerLabelTextOrientation(textOrientation);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCornerLabelTextOrientation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCornerLabelValue, "SetCornerLabelValue()\n"
"\n"
"Set the value for the (top-left) corner label.");

extern "C" {static PyObject *meth_wxGrid_SetCornerLabelValue(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCornerLabelValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* a0;
        int a0State = 0;
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxString, &a0, &a0State))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCornerLabelValue(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(a0), sipType_wxString, a0State);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCornerLabelValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetLabelBackgroundColour, "SetLabelBackgroundColour(colour)\n"
"\n"
"Sets the background colour for row and column labels.");

extern "C" {static PyObject *meth_wxGrid_SetLabelBackgroundColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetLabelBackgroundColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLabelBackgroundColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetLabelBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetLabelFont, "SetLabelFont(font)\n"
"\n"
"Sets the font for row and column labels.");

extern "C" {static PyObject *meth_wxGrid_SetLabelFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetLabelFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxFont* font;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxFont, &font))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLabelFont(*font);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetLabelFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetLabelTextColour, "SetLabelTextColour(colour)\n"
"\n"
"Sets the colour for row and column label text.");

extern "C" {static PyObject *meth_wxGrid_SetLabelTextColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetLabelTextColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLabelTextColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetLabelTextColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowLabelAlignment, "SetRowLabelAlignment(horiz, vert)\n"
"\n"
"Sets the horizontal and vertical alignment of row label text.");

extern "C" {static PyObject *meth_wxGrid_SetRowLabelAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowLabelAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int horiz;
        int vert;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_horiz,
            sipName_vert,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &horiz, &vert))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowLabelAlignment(horiz,vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowLabelAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowLabelValue, "SetRowLabelValue(row, value)\n"
"\n"
"Sets the value for the given row label.");

extern "C" {static PyObject *meth_wxGrid_SetRowLabelValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowLabelValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        const  ::wxString* value;
        int valueState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxGrid, &sipCpp, &row, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowLabelValue(row,*value);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowLabelValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetUseNativeColLabels, "SetUseNativeColLabels(native=True)\n"
"\n"
"Call this in order to make the column labels use a native look by\n"
"using wxRendererNative::DrawHeaderButton() internally.");

extern "C" {static PyObject *meth_wxGrid_SetUseNativeColLabels(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetUseNativeColLabels(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool native = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_native,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &native))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetUseNativeColLabels(native);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetUseNativeColLabels, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_UseNativeColHeader, "UseNativeColHeader(native=True) -> bool\n"
"\n"
"Enable the use of native header window for column labels.");

extern "C" {static PyObject *meth_wxGrid_UseNativeColHeader(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_UseNativeColHeader(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool native = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_native,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &native))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->UseNativeColHeader(native);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_UseNativeColHeader, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellAlignment, "GetCellAlignment(row, col) -> (horiz, vert)\n"
"\n"
"Sets the arguments to the horizontal and vertical text alignment\n"
"values for the grid cell at the specified location.");

extern "C" {static PyObject *meth_wxGrid_GetCellAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        int horiz;
        int vert;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GetCellAlignment(row,col,&horiz,&vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",horiz,vert);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellBackgroundColour, "GetCellBackgroundColour(row, col) -> wx.Colour\n"
"\n"
"Returns the background colour of the cell at the specified location.");

extern "C" {static PyObject *meth_wxGrid_GetCellBackgroundColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellBackgroundColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetCellBackgroundColour(row,col));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellFont, "GetCellFont(row, col) -> wx.Font\n"
"\n"
"Returns the font for text in the grid cell at the specified location.");

extern "C" {static PyObject *meth_wxGrid_GetCellFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxFont*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxFont(sipCpp->GetCellFont(row,col));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxFont,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellTextColour, "GetCellTextColour(row, col) -> wx.Colour\n"
"\n"
"Returns the text colour for the grid cell at the specified location.");

extern "C" {static PyObject *meth_wxGrid_GetCellTextColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellTextColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetCellTextColour(row,col));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellTextColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultCellAlignment, "GetDefaultCellAlignment() -> (horiz, vert)\n"
"\n"
"Returns the default cell alignment.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultCellAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultCellAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int horiz;
        int vert;
        const  ::wxGrid *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GetDefaultCellAlignment(&horiz,&vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",horiz,vert);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultCellAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultCellBackgroundColour, "GetDefaultCellBackgroundColour() -> wx.Colour\n"
"\n"
"Returns the current default background colour for grid cells.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultCellBackgroundColour(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultCellBackgroundColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetDefaultCellBackgroundColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultCellBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultCellFont, "GetDefaultCellFont() -> wx.Font\n"
"\n"
"Returns the current default font for grid cell text.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultCellFont(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultCellFont(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxFont*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxFont(sipCpp->GetDefaultCellFont());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxFont,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultCellFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultCellTextColour, "GetDefaultCellTextColour() -> wx.Colour\n"
"\n"
"Returns the current default colour for grid cell text.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultCellTextColour(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultCellTextColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetDefaultCellTextColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultCellTextColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellAlignment, "SetCellAlignment(row, col, horiz, vert)\n"
"\n"
"Sets the horizontal and vertical alignment for grid cell text at the\n"
"specified location.");

extern "C" {static PyObject *meth_wxGrid_SetCellAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        int horiz;
        int vert;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_horiz,
            sipName_vert,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, &horiz, &vert))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellAlignment(row,col,horiz,vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellBackgroundColour, "SetCellBackgroundColour(row, col, colour)\n"
"\n"
"Set the background colour for the given cell or all cells by default.");

extern "C" {static PyObject *meth_wxGrid_SetCellBackgroundColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellBackgroundColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ1", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellBackgroundColour(row,col,*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellFont, "SetCellFont(row, col, font)\n"
"\n"
"Sets the font for text in the grid cell at the specified location.");

extern "C" {static PyObject *meth_wxGrid_SetCellFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxFont* font;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ9", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, sipType_wxFont, &font))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellFont(row,col,*font);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellTextColour, "SetCellTextColour(row, col, colour)\n"
"\n"
"Sets the text colour for the given cell.");

extern "C" {static PyObject *meth_wxGrid_SetCellTextColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellTextColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ1", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellTextColour(row,col,*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellTextColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultCellAlignment, "SetDefaultCellAlignment(horiz, vert)\n"
"\n"
"Sets the default horizontal and vertical alignment for grid cell text.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultCellAlignment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultCellAlignment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int horiz;
        int vert;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_horiz,
            sipName_vert,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &horiz, &vert))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultCellAlignment(horiz,vert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultCellAlignment, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultCellBackgroundColour, "SetDefaultCellBackgroundColour(colour)\n"
"\n"
"Sets the default background colour for grid cells.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultCellBackgroundColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultCellBackgroundColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultCellBackgroundColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultCellBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultCellFont, "SetDefaultCellFont(font)\n"
"\n"
"Sets the default font to be used for grid cell text.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultCellFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultCellFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxFont* font;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxFont, &font))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultCellFont(*font);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultCellFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultCellTextColour, "SetDefaultCellTextColour(colour)\n"
"\n"
"Sets the current default colour for grid cell text.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultCellTextColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultCellTextColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultCellTextColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultCellTextColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanEnableCellControl, "CanEnableCellControl() -> bool\n"
"\n"
"Returns true if the in-place edit control for the current grid cell\n"
"can be used and false otherwise.");

extern "C" {static PyObject *meth_wxGrid_CanEnableCellControl(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanEnableCellControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanEnableCellControl();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanEnableCellControl, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableCellEditControl, "DisableCellEditControl()\n"
"\n"
"Disables in-place editing of grid cells.");

extern "C" {static PyObject *meth_wxGrid_DisableCellEditControl(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableCellEditControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableCellEditControl();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableCellEditControl, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableCellEditControl, "EnableCellEditControl(enable=True)\n"
"\n"
"Enables or disables in-place editing of grid cell data.");

extern "C" {static PyObject *meth_wxGrid_EnableCellEditControl(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableCellEditControl(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableCellEditControl(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableCellEditControl, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableEditing, "EnableEditing(edit)\n"
"\n"
"Makes the grid globally editable or read-only.");

extern "C" {static PyObject *meth_wxGrid_EnableEditing(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableEditing(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool edit;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_edit,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &edit))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableEditing(edit);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableEditing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellEditor, "GetCellEditor(row, col) -> GridCellEditor\n"
"\n"
"Returns a pointer to the editor for the cell at the specified\n"
"location.");

extern "C" {static PyObject *meth_wxGrid_GetCellEditor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellEditor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGridCellEditor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCellEditor(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellEditor,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellEditor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellRenderer, "GetCellRenderer(row, col) -> GridCellRenderer\n"
"\n"
"Returns a pointer to the renderer for the grid cell at the specified\n"
"location.");

extern "C" {static PyObject *meth_wxGrid_GetCellRenderer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellRenderer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGridCellRenderer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCellRenderer(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellRenderer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellRenderer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellValue, "GetCellValue(row, col) -> String\n"
"GetCellValue(coords) -> String\n"
"\n"
"Returns the string contained in the cell at the specified location.\n"
"");

extern "C" {static PyObject *meth_wxGrid_GetCellValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetCellValue(row,col));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetCellValue(*coords));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultEditor, "GetDefaultEditor() -> GridCellEditor\n"
"\n"
"Returns a pointer to the current default grid cell editor.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultEditor(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultEditor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridCellEditor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultEditor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellEditor,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultEditor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultEditorForCell, "GetDefaultEditorForCell(row, col) -> GridCellEditor\n"
"GetDefaultEditorForCell(c) -> GridCellEditor\n"
"\n"
"Returns the default editor for the specified cell.\n"
"");

extern "C" {static PyObject *meth_wxGrid_GetDefaultEditorForCell(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultEditorForCell(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGridCellEditor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultEditorForCell(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellEditor,SIP_NULLPTR);
        }
    }

    {
        const  ::wxGridCellCoords* c;
        int cState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_c,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &c, &cState))
        {
             ::wxGridCellEditor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultEditorForCell(*c);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(c), sipType_wxGridCellCoords, cState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellEditor,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultEditorForCell, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultEditorForType, "GetDefaultEditorForType(typeName) -> GridCellEditor\n"
"\n"
"Returns the default editor for the cells containing values of the\n"
"given type.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultEditorForType(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultEditorForType(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* typeName;
        int typeNameState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_typeName,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxString, &typeName, &typeNameState))
        {
             ::wxGridCellEditor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultEditorForType(*typeName);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(typeName), sipType_wxString, typeNameState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellEditor,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultEditorForType, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultRenderer, "GetDefaultRenderer() -> GridCellRenderer\n"
"\n"
"Returns a pointer to the current default grid cell renderer.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultRenderer(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultRenderer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridCellRenderer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultRenderer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellRenderer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultRenderer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultRendererForCell, "GetDefaultRendererForCell(row, col) -> GridCellRenderer\n"
"\n"
"Returns the default renderer for the given cell.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultRendererForCell(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultRendererForCell(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGridCellRenderer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultRendererForCell(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellRenderer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultRendererForCell, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultRendererForType, "GetDefaultRendererForType(typeName) -> GridCellRenderer\n"
"\n"
"Returns the default renderer for the cell containing values of the\n"
"given type.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultRendererForType(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultRendererForType(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* typeName;
        int typeNameState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_typeName,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxString, &typeName, &typeNameState))
        {
             ::wxGridCellRenderer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultRendererForType(*typeName);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(typeName), sipType_wxString, typeNameState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellRenderer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultRendererForType, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_HideCellEditControl, "HideCellEditControl()\n"
"\n"
"Hides the in-place cell edit control.");

extern "C" {static PyObject *meth_wxGrid_HideCellEditControl(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_HideCellEditControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HideCellEditControl();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_HideCellEditControl, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsCellEditControlEnabled, "IsCellEditControlEnabled() -> bool\n"
"\n"
"Returns true if the in-place edit control is currently enabled.");

extern "C" {static PyObject *meth_wxGrid_IsCellEditControlEnabled(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsCellEditControlEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsCellEditControlEnabled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsCellEditControlEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsCellEditControlShown, "IsCellEditControlShown() -> bool\n"
"\n"
"Returns true if the in-place edit control is currently shown.");

extern "C" {static PyObject *meth_wxGrid_IsCellEditControlShown(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsCellEditControlShown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsCellEditControlShown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsCellEditControlShown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsCurrentCellReadOnly, "IsCurrentCellReadOnly() -> bool\n"
"\n"
"Returns true if the current cell is read-only.");

extern "C" {static PyObject *meth_wxGrid_IsCurrentCellReadOnly(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsCurrentCellReadOnly(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsCurrentCellReadOnly();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsCurrentCellReadOnly, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsEditable, "IsEditable() -> bool\n"
"\n"
"Returns false if the whole grid has been set as read-only or true\n"
"otherwise.");

extern "C" {static PyObject *meth_wxGrid_IsEditable(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsEditable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEditable();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsEditable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsReadOnly, "IsReadOnly(row, col) -> bool\n"
"\n"
"Returns true if the cell at the specified location can't be edited.");

extern "C" {static PyObject *meth_wxGrid_IsReadOnly(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsReadOnly(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsReadOnly(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsReadOnly, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_RegisterDataType, "RegisterDataType(typeName, renderer, editor)\n"
"\n"
"Register a new data type.");

extern "C" {static PyObject *meth_wxGrid_RegisterDataType(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_RegisterDataType(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* typeName;
        int typeNameState = 0;
         ::wxGridCellRenderer* renderer;
         ::wxGridCellEditor* editor;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_typeName,
            sipName_renderer,
            sipName_editor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J:J:", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxString, &typeName, &typeNameState, sipType_wxGridCellRenderer, &renderer, sipType_wxGridCellEditor, &editor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RegisterDataType(*typeName,renderer,editor);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(typeName), sipType_wxString, typeNameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_RegisterDataType, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SaveEditControlValue, "SaveEditControlValue()\n"
"\n"
"Sets the value of the current grid cell to the current in-place edit\n"
"control value.");

extern "C" {static PyObject *meth_wxGrid_SaveEditControlValue(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SaveEditControlValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SaveEditControlValue();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SaveEditControlValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellEditor, "SetCellEditor(row, col, editor)\n"
"\n"
"Sets the editor for the grid cell at the specified location.");

extern "C" {static PyObject *meth_wxGrid_SetCellEditor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellEditor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGridCellEditor* editor;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_editor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ:", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, sipType_wxGridCellEditor, &editor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellEditor(row,col,editor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellEditor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellRenderer, "SetCellRenderer(row, col, renderer)\n"
"\n"
"Sets the renderer for the grid cell at the specified location.");

extern "C" {static PyObject *meth_wxGrid_SetCellRenderer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellRenderer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGridCellRenderer* renderer;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_renderer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ:", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, sipType_wxGridCellRenderer, &renderer))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellRenderer(row,col,renderer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellRenderer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellValue, "SetCellValue(row, col, s)\n"
"SetCellValue(coords, s)\n"
"\n"
"Sets the string value for the cell at the specified location.\n"
"");

extern "C" {static PyObject *meth_wxGrid_SetCellValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxString* s;
        int sState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_s,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ1", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, sipType_wxString, &s, &sState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellValue(row,col,*s);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(s), sipType_wxString, sState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
        const  ::wxString* s;
        int sState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
            sipName_s,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState, sipType_wxString, &s, &sState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellValue(*coords,*s);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);
            sipReleaseType(const_cast< ::wxString *>(s), sipType_wxString, sState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColFormatBool, "SetColFormatBool(col)\n"
"\n"
"Sets the specified column to display boolean values.");

extern "C" {static PyObject *meth_wxGrid_SetColFormatBool(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColFormatBool(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColFormatBool(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColFormatBool, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColFormatCustom, "SetColFormatCustom(col, typeName)\n"
"\n"
"Sets the specified column to display data in a custom format.");

extern "C" {static PyObject *meth_wxGrid_SetColFormatCustom(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColFormatCustom(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const  ::wxString* typeName;
        int typeNameState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_typeName,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxGrid, &sipCpp, &col, sipType_wxString, &typeName, &typeNameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColFormatCustom(col,*typeName);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(typeName), sipType_wxString, typeNameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColFormatCustom, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColFormatFloat, "SetColFormatFloat(col, width=-1, precision=-1)\n"
"\n"
"Sets the specified column to display floating point values with the\n"
"given width and precision.");

extern "C" {static PyObject *meth_wxGrid_SetColFormatFloat(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColFormatFloat(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        int width = -1;
        int precision = -1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_width,
            sipName_precision,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|ii", &sipSelf, sipType_wxGrid, &sipCpp, &col, &width, &precision))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColFormatFloat(col,width,precision);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColFormatFloat, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColFormatNumber, "SetColFormatNumber(col)\n"
"\n"
"Sets the specified column to display integer values.");

extern "C" {static PyObject *meth_wxGrid_SetColFormatNumber(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColFormatNumber(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColFormatNumber(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColFormatNumber, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColFormatDate, "SetColFormatDate(col, format=\"\")\n"
"\n"
"Sets the specified column to display date values.");

extern "C" {static PyObject *meth_wxGrid_SetColFormatDate(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColFormatDate(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const  ::wxString& formatdef = wxString();
        const  ::wxString* format = &formatdef;
        int formatState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_format,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|J1", &sipSelf, sipType_wxGrid, &sipCpp, &col, sipType_wxString, &format, &formatState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColFormatDate(col,*format);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(format), sipType_wxString, formatState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColFormatDate, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultEditor, "SetDefaultEditor(editor)\n"
"\n"
"Sets the default editor for grid cells.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultEditor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultEditor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGridCellEditor* editor;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_editor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellEditor, &editor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultEditor(editor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultEditor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultRenderer, "SetDefaultRenderer(renderer)\n"
"\n"
"Sets the default renderer for grid cells.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultRenderer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultRenderer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGridCellRenderer* renderer;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_renderer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellRenderer, &renderer))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultRenderer(renderer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultRenderer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetReadOnly, "SetReadOnly(row, col, isReadOnly=True)\n"
"\n"
"Makes the cell at the specified location read-only or editable.");

extern "C" {static PyObject *meth_wxGrid_SetReadOnly(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetReadOnly(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        bool isReadOnly = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_isReadOnly,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|b", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, &isReadOnly))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetReadOnly(row,col,isReadOnly);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetReadOnly, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ShowCellEditControl, "ShowCellEditControl()\n"
"\n"
"Displays the active in-place cell edit control for the current cell\n"
"after it was hidden.");

extern "C" {static PyObject *meth_wxGrid_ShowCellEditControl(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ShowCellEditControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ShowCellEditControl();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ShowCellEditControl, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AutoSize, "AutoSize()\n"
"\n"
"Automatically sets the height and width of all rows and columns to fit\n"
"their contents.");

extern "C" {static PyObject *meth_wxGrid_AutoSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AutoSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AutoSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AutoSizeColLabelSize, "AutoSizeColLabelSize(col)\n"
"\n"
"Automatically adjusts width of the column to fit its label.");

extern "C" {static PyObject *meth_wxGrid_AutoSizeColLabelSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AutoSizeColLabelSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoSizeColLabelSize(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AutoSizeColLabelSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AutoSizeColumn, "AutoSizeColumn(col, setAsMin=True)\n"
"\n"
"Automatically sizes the column to fit its contents.");

extern "C" {static PyObject *meth_wxGrid_AutoSizeColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AutoSizeColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        bool setAsMin = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_setAsMin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|b", &sipSelf, sipType_wxGrid, &sipCpp, &col, &setAsMin))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoSizeColumn(col,setAsMin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AutoSizeColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AutoSizeColumns, "AutoSizeColumns(setAsMin=True)\n"
"\n"
"Automatically sizes all columns to fit their contents.");

extern "C" {static PyObject *meth_wxGrid_AutoSizeColumns(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AutoSizeColumns(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool setAsMin = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_setAsMin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &setAsMin))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoSizeColumns(setAsMin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AutoSizeColumns, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AutoSizeRow, "AutoSizeRow(row, setAsMin=True)\n"
"\n"
"Automatically sizes the row to fit its contents.");

extern "C" {static PyObject *meth_wxGrid_AutoSizeRow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AutoSizeRow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        bool setAsMin = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_setAsMin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|b", &sipSelf, sipType_wxGrid, &sipCpp, &row, &setAsMin))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoSizeRow(row,setAsMin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AutoSizeRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AutoSizeRowLabelSize, "AutoSizeRowLabelSize(col)\n"
"\n"
"Automatically adjusts height of the row to fit its label.");

extern "C" {static PyObject *meth_wxGrid_AutoSizeRowLabelSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AutoSizeRowLabelSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoSizeRowLabelSize(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AutoSizeRowLabelSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AutoSizeRows, "AutoSizeRows(setAsMin=True)\n"
"\n"
"Automatically sizes all rows to fit their contents.");

extern "C" {static PyObject *meth_wxGrid_AutoSizeRows(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AutoSizeRows(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool setAsMin = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_setAsMin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &setAsMin))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoSizeRows(setAsMin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AutoSizeRows, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellFitMode, "GetCellFitMode(row, col) -> GridFitMode\n"
"\n"
"Returns the cell fitting mode.");

extern "C" {static PyObject *meth_wxGrid_GetCellFitMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellFitMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGridFitMode*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridFitMode(sipCpp->GetCellFitMode(row,col));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridFitMode,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellFitMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellOverflow, "GetCellOverflow(row, col) -> bool\n"
"\n"
"Returns true if the cell value can overflow.");

extern "C" {static PyObject *meth_wxGrid_GetCellOverflow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellOverflow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCellOverflow(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellOverflow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColLabelSize, "GetColLabelSize() -> int\n"
"\n"
"Returns the current height of the column labels.");

extern "C" {static PyObject *meth_wxGrid_GetColLabelSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColLabelSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColLabelSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColLabelSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColMinimalAcceptableWidth, "GetColMinimalAcceptableWidth() -> int\n"
"\n"
"Returns the minimal width to which a column may be resized.");

extern "C" {static PyObject *meth_wxGrid_GetColMinimalAcceptableWidth(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColMinimalAcceptableWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColMinimalAcceptableWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColMinimalAcceptableWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColSize, "GetColSize(col) -> int\n"
"\n"
"Returns the width of the specified column.");

extern "C" {static PyObject *meth_wxGrid_GetColSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColSize(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsColShown, "IsColShown(col) -> bool\n"
"\n"
"Returns true if the specified column is not currently hidden.");

extern "C" {static PyObject *meth_wxGrid_IsColShown(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsColShown(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsColShown(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsColShown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultCellFitMode, "GetDefaultCellFitMode() -> GridFitMode\n"
"\n"
"Returns the default cell fitting mode.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultCellFitMode(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultCellFitMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridFitMode*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridFitMode(sipCpp->GetDefaultCellFitMode());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridFitMode,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultCellFitMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultCellOverflow, "GetDefaultCellOverflow() -> bool\n"
"\n"
"Returns true if the cells can overflow by default.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultCellOverflow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultCellOverflow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultCellOverflow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultCellOverflow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultColLabelSize, "GetDefaultColLabelSize() -> int\n"
"\n"
"Returns the default height for column labels.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultColLabelSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultColLabelSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultColLabelSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultColLabelSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultColSize, "GetDefaultColSize() -> int\n"
"\n"
"Returns the current default width for grid columns.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultColSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultColSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultColSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultColSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultRowLabelSize, "GetDefaultRowLabelSize() -> int\n"
"\n"
"Returns the default width for the row labels.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultRowLabelSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultRowLabelSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultRowLabelSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultRowLabelSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultRowSize, "GetDefaultRowSize() -> int\n"
"\n"
"Returns the current default height for grid rows.");

extern "C" {static PyObject *meth_wxGrid_GetDefaultRowSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultRowSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDefaultRowSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultRowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowMinimalAcceptableHeight, "GetRowMinimalAcceptableHeight() -> int\n"
"\n"
"Returns the minimal size to which rows can be resized.");

extern "C" {static PyObject *meth_wxGrid_GetRowMinimalAcceptableHeight(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowMinimalAcceptableHeight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRowMinimalAcceptableHeight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowMinimalAcceptableHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowLabelSize, "GetRowLabelSize() -> int\n"
"\n"
"Returns the current width of the row labels.");

extern "C" {static PyObject *meth_wxGrid_GetRowLabelSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowLabelSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRowLabelSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowLabelSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowSize, "GetRowSize(row) -> int\n"
"\n"
"Returns the height of the specified row.");

extern "C" {static PyObject *meth_wxGrid_GetRowSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &row))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRowSize(row);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsRowShown, "IsRowShown(row) -> bool\n"
"\n"
"Returns true if the specified row is not currently hidden.");

extern "C" {static PyObject *meth_wxGrid_IsRowShown(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsRowShown(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &row))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsRowShown(row);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsRowShown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellFitMode, "SetCellFitMode(row, col, fitMode)\n"
"\n"
"Specifies the behaviour of the cell contents if it doesn't fit into\n"
"the available space.");

extern "C" {static PyObject *meth_wxGrid_SetCellFitMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellFitMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGridFitMode* fitMode;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_fitMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ9", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, sipType_wxGridFitMode, &fitMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellFitMode(row,col,*fitMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellFitMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellOverflow, "SetCellOverflow(row, col, allow)\n"
"\n"
"Sets the overflow permission of the cell.");

extern "C" {static PyObject *meth_wxGrid_SetCellOverflow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellOverflow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        bool allow;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_allow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biib", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, &allow))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellOverflow(row,col,allow);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellOverflow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColLabelSize, "SetColLabelSize(height)\n"
"\n"
"Sets the height of the column labels.");

extern "C" {static PyObject *meth_wxGrid_SetColLabelSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColLabelSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int height;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColLabelSize(height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColLabelSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColMinimalAcceptableWidth, "SetColMinimalAcceptableWidth(width)\n"
"\n"
"Sets the minimal width to which the user can resize columns.");

extern "C" {static PyObject *meth_wxGrid_SetColMinimalAcceptableWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColMinimalAcceptableWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &width))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColMinimalAcceptableWidth(width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColMinimalAcceptableWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColMinimalWidth, "SetColMinimalWidth(col, width)\n"
"\n"
"Sets the minimal width for the specified column col.");

extern "C" {static PyObject *meth_wxGrid_SetColMinimalWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColMinimalWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        int width;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &col, &width))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColMinimalWidth(col,width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColMinimalWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColSize, "SetColSize(col, width)\n"
"\n"
"Sets the width of the specified column.");

extern "C" {static PyObject *meth_wxGrid_SetColSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        int width;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &col, &width))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColSize(col,width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_HideCol, "HideCol(col)\n"
"\n"
"Hides the specified column.");

extern "C" {static PyObject *meth_wxGrid_HideCol(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_HideCol(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HideCol(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_HideCol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ShowCol, "ShowCol(col)\n"
"\n"
"Shows the previously hidden column by resizing it to non-0 size.");

extern "C" {static PyObject *meth_wxGrid_ShowCol(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ShowCol(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ShowCol(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ShowCol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultCellFitMode, "SetDefaultCellFitMode(fitMode)\n"
"\n"
"Specifies the default behaviour of the cell contents if it doesn't fit\n"
"into the available space.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultCellFitMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultCellFitMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGridFitMode* fitMode;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fitMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridFitMode, &fitMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultCellFitMode(*fitMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultCellFitMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultCellOverflow, "SetDefaultCellOverflow(allow)\n"
"\n"
"Sets the default overflow permission of the cells.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultCellOverflow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultCellOverflow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool allow;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_allow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &allow))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultCellOverflow(allow);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultCellOverflow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultColSize, "SetDefaultColSize(width, resizeExistingCols=False)\n"
"\n"
"Sets the default width for columns in the grid.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultColSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultColSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
        bool resizeExistingCols = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_resizeExistingCols,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|b", &sipSelf, sipType_wxGrid, &sipCpp, &width, &resizeExistingCols))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultColSize(width,resizeExistingCols);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultColSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetDefaultRowSize, "SetDefaultRowSize(height, resizeExistingRows=False)\n"
"\n"
"Sets the default height for rows in the grid.");

extern "C" {static PyObject *meth_wxGrid_SetDefaultRowSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetDefaultRowSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int height;
        bool resizeExistingRows = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_height,
            sipName_resizeExistingRows,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|b", &sipSelf, sipType_wxGrid, &sipCpp, &height, &resizeExistingRows))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDefaultRowSize(height,resizeExistingRows);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetDefaultRowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowLabelSize, "SetRowLabelSize(width)\n"
"\n"
"Sets the width of the row labels.");

extern "C" {static PyObject *meth_wxGrid_SetRowLabelSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowLabelSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &width))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowLabelSize(width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowLabelSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowMinimalAcceptableHeight, "SetRowMinimalAcceptableHeight(height)\n"
"\n"
"Sets the minimal row height used by default.");

extern "C" {static PyObject *meth_wxGrid_SetRowMinimalAcceptableHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowMinimalAcceptableHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int height;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowMinimalAcceptableHeight(height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowMinimalAcceptableHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowMinimalHeight, "SetRowMinimalHeight(row, height)\n"
"\n"
"Sets the minimal height for the specified row.");

extern "C" {static PyObject *meth_wxGrid_SetRowMinimalHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowMinimalHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int height;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowMinimalHeight(row,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowMinimalHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowSize, "SetRowSize(row, height)\n"
"\n"
"Sets the height of the specified row.");

extern "C" {static PyObject *meth_wxGrid_SetRowSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int height;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowSize(row,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_HideRow, "HideRow(col)\n"
"\n"
"Hides the specified row.");

extern "C" {static PyObject *meth_wxGrid_HideRow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_HideRow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HideRow(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_HideRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ShowRow, "ShowRow(col)\n"
"\n"
"Shows the previously hidden row.");

extern "C" {static PyObject *meth_wxGrid_ShowRow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ShowRow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ShowRow(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ShowRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColSizes, "GetColSizes() -> GridSizesInfo\n"
"\n"
"Get size information for all columns at once.");

extern "C" {static PyObject *meth_wxGrid_GetColSizes(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColSizes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridSizesInfo*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridSizesInfo(sipCpp->GetColSizes());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridSizesInfo,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColSizes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowSizes, "GetRowSizes() -> GridSizesInfo\n"
"\n"
"Get size information for all row at once.");

extern "C" {static PyObject *meth_wxGrid_GetRowSizes(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowSizes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridSizesInfo*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridSizesInfo(sipCpp->GetRowSizes());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridSizesInfo,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowSizes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColSizes, "SetColSizes(sizeInfo)\n"
"\n"
"Restore all columns sizes.");

extern "C" {static PyObject *meth_wxGrid_SetColSizes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColSizes(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGridSizesInfo* sizeInfo;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizeInfo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridSizesInfo, &sizeInfo))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColSizes(*sizeInfo);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColSizes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowSizes, "SetRowSizes(sizeInfo)\n"
"\n"
"Restore all rows sizes.");

extern "C" {static PyObject *meth_wxGrid_SetRowSizes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowSizes(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGridSizesInfo* sizeInfo;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizeInfo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridSizesInfo, &sizeInfo))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowSizes(*sizeInfo);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowSizes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellSize, "SetCellSize(row, col, num_rows, num_cols)\n"
"\n"
"Set the size of the cell.");

extern "C" {static PyObject *meth_wxGrid_SetCellSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        int num_rows;
        int num_cols;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_num_rows,
            sipName_num_cols,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, &num_rows, &num_cols))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellSize(row,col,num_rows,num_cols);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellSize, "GetCellSize(row, col, num_rows, num_cols) -> CellSpan\n"
"GetCellSize(coords) -> wx.Size\n"
"\n"
"Get the size of the cell in number of cells covered by it.\n"
"");

extern "C" {static PyObject *meth_wxGrid_GetCellSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        int num_rows;
        int num_cols;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGrid::CellSpan sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCellSize(row,col,&num_rows,&num_cols);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(Fii)",sipRes,sipType_wxGrid_CellSpan,num_rows,num_cols);
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetCellSize(*coords));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanDragCell, "CanDragCell() -> bool\n"
"\n"
"Return true if the dragging of cells is enabled or false otherwise.");

extern "C" {static PyObject *meth_wxGrid_CanDragCell(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanDragCell(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDragCell();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanDragCell, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanDragColMove, "CanDragColMove() -> bool\n"
"\n"
"Returns true if columns can be moved by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_CanDragColMove(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanDragColMove(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDragColMove();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanDragColMove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanDragColSize, "CanDragColSize(col) -> bool\n"
"\n"
"Returns true if the given column can be resized by dragging with the\n"
"mouse.");

extern "C" {static PyObject *meth_wxGrid_CanDragColSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanDragColSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDragColSize(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanDragColSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanDragGridColEdges, "CanDragGridColEdges() -> bool\n"
"\n"
"Return true if column edges inside the grid can be dragged to resize\n"
"the rows.");

extern "C" {static PyObject *meth_wxGrid_CanDragGridColEdges(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanDragGridColEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDragGridColEdges();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanDragGridColEdges, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanDragGridRowEdges, "CanDragGridRowEdges() -> bool\n"
"\n"
"Return true if row edges inside the grid can be dragged to resize the\n"
"rows.");

extern "C" {static PyObject *meth_wxGrid_CanDragGridRowEdges(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanDragGridRowEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDragGridRowEdges();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanDragGridRowEdges, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanDragGridSize, "CanDragGridSize() -> bool\n"
"\n"
"Return true if the dragging of grid lines to resize rows and columns\n"
"is enabled or false otherwise.");

extern "C" {static PyObject *meth_wxGrid_CanDragGridSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanDragGridSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDragGridSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanDragGridSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanDragRowMove, "CanDragRowMove() -> bool\n"
"\n"
"Returns true if rows can be moved by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_CanDragRowMove(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanDragRowMove(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDragRowMove();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanDragRowMove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanDragRowSize, "CanDragRowSize(row) -> bool\n"
"\n"
"Returns true if the given row can be resized by dragging with the\n"
"mouse.");

extern "C" {static PyObject *meth_wxGrid_CanDragRowSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanDragRowSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &row))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanDragRowSize(row);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanDragRowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanHideColumns, "CanHideColumns() -> bool\n"
"\n"
"Returns true if columns can be hidden from the popup menu of the\n"
"native header.");

extern "C" {static PyObject *meth_wxGrid_CanHideColumns(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanHideColumns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanHideColumns();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanHideColumns, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableColResize, "DisableColResize(col)\n"
"\n"
"Disable interactive resizing of the specified column.");

extern "C" {static PyObject *meth_wxGrid_DisableColResize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableColResize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableColResize(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableColResize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableRowResize, "DisableRowResize(row)\n"
"\n"
"Disable interactive resizing of the specified row.");

extern "C" {static PyObject *meth_wxGrid_DisableRowResize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableRowResize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &row))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableRowResize(row);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableRowResize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableDragColMove, "DisableDragColMove()\n"
"\n"
"Disables column moving by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_DisableDragColMove(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableDragColMove(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableDragColMove();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableDragColMove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableDragRowMove, "DisableDragRowMove()\n"
"\n"
"Disables row moving by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_DisableDragRowMove(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableDragRowMove(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableDragRowMove();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableDragRowMove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableDragColSize, "DisableDragColSize()\n"
"\n"
"Disables column sizing by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_DisableDragColSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableDragColSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableDragColSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableDragColSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableDragGridSize, "DisableDragGridSize()\n"
"\n"
"Disable mouse dragging of grid lines to resize rows and columns.");

extern "C" {static PyObject *meth_wxGrid_DisableDragGridSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableDragGridSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableDragGridSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableDragGridSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableDragRowSize, "DisableDragRowSize()\n"
"\n"
"Disables row sizing by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_DisableDragRowSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableDragRowSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableDragRowSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableDragRowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DisableHidingColumns, "DisableHidingColumns()\n"
"\n"
"Disables column hiding from the header popup menu.");

extern "C" {static PyObject *meth_wxGrid_DisableHidingColumns(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DisableHidingColumns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableHidingColumns();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DisableHidingColumns, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableDragCell, "EnableDragCell(enable=True)\n"
"\n"
"Enables or disables cell dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_EnableDragCell(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableDragCell(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableDragCell(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableDragCell, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableDragColMove, "EnableDragColMove(enable=True) -> bool\n"
"\n"
"Enables or disables column moving by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_EnableDragColMove(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableDragColMove(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EnableDragColMove(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableDragColMove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableDragRowMove, "EnableDragRowMove(enable=True) -> bool\n"
"\n"
"Enables or disables row moving by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_EnableDragRowMove(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableDragRowMove(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EnableDragRowMove(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableDragRowMove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableDragColSize, "EnableDragColSize(enable=True)\n"
"\n"
"Enables or disables column sizing by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_EnableDragColSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableDragColSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableDragColSize(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableDragColSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableDragGridSize, "EnableDragGridSize(enable=True)\n"
"\n"
"Enables or disables row and column resizing by dragging gridlines with\n"
"the mouse.");

extern "C" {static PyObject *meth_wxGrid_EnableDragGridSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableDragGridSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableDragGridSize(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableDragGridSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableDragRowSize, "EnableDragRowSize(enable=True)\n"
"\n"
"Enables or disables row sizing by dragging with the mouse.");

extern "C" {static PyObject *meth_wxGrid_EnableDragRowSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableDragRowSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableDragRowSize(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableDragRowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableHidingColumns, "EnableHidingColumns(enable=True) -> bool\n"
"\n"
"Enables or disables column hiding from the header popup menu.");

extern "C" {static PyObject *meth_wxGrid_EnableHidingColumns(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableHidingColumns(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EnableHidingColumns(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableHidingColumns, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColAt, "GetColAt(colPos) -> int\n"
"\n"
"Returns the column ID of the specified column position.");

extern "C" {static PyObject *meth_wxGrid_GetColAt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColAt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int colPos;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colPos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &colPos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColAt(colPos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColAt, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColPos, "GetColPos(colID) -> int\n"
"\n"
"Returns the position of the specified column.");

extern "C" {static PyObject *meth_wxGrid_GetColPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int colID;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colID,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &colID))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColPos(colID);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColPos, "SetColPos(colID, newPos)\n"
"\n"
"Sets the position of the specified column.");

extern "C" {static PyObject *meth_wxGrid_SetColPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int colID;
        int newPos;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colID,
            sipName_newPos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &colID, &newPos))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColPos(colID,newPos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColumnsOrder, "SetColumnsOrder(order)\n"
"\n"
"Sets the positions of all columns at once.");

extern "C" {static PyObject *meth_wxGrid_SetColumnsOrder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColumnsOrder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxArrayInt* order;
        int orderState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_order,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxArrayInt, &order, &orderState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColumnsOrder(*order);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxArrayInt *>(order), sipType_wxArrayInt, orderState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColumnsOrder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ResetColPos, "ResetColPos()\n"
"\n"
"Resets the position of the columns to the default.");

extern "C" {static PyObject *meth_wxGrid_ResetColPos(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ResetColPos(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ResetColPos();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ResetColPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowAt, "GetRowAt(rowPos) -> int\n"
"\n"
"Returns the row ID of the specified row position.");

extern "C" {static PyObject *meth_wxGrid_GetRowAt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowAt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int rowPos;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rowPos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &rowPos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRowAt(rowPos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowAt, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowPos, "GetRowPos(rowID) -> int\n"
"\n"
"Returns the position of the specified row.");

extern "C" {static PyObject *meth_wxGrid_GetRowPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int rowID;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rowID,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &rowID))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRowPos(rowID);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowPos, "SetRowPos(rowID, newPos)\n"
"\n"
"Sets the position of the specified row.");

extern "C" {static PyObject *meth_wxGrid_SetRowPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int rowID;
        int newPos;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rowID,
            sipName_newPos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &rowID, &newPos))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowPos(rowID,newPos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowsOrder, "SetRowsOrder(order)\n"
"\n"
"Sets the positions of all rows at once.");

extern "C" {static PyObject *meth_wxGrid_SetRowsOrder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowsOrder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxArrayInt* order;
        int orderState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_order,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxArrayInt, &order, &orderState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowsOrder(*order);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxArrayInt *>(order), sipType_wxArrayInt, orderState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowsOrder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ResetRowPos, "ResetRowPos()\n"
"\n"
"Resets the position of the rows to the default.");

extern "C" {static PyObject *meth_wxGrid_ResetRowPos(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ResetRowPos(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ResetRowPos();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ResetRowPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridCursorCoords, "GetGridCursorCoords() -> GridCellCoords\n"
"\n"
"Returns the current grid cursor position.");

extern "C" {static PyObject *meth_wxGrid_GetGridCursorCoords(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridCursorCoords(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridCellCoords*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridCellCoords(sipCpp->GetGridCursorCoords());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridCellCoords,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridCursorCoords, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridCursorCol, "GetGridCursorCol() -> int\n"
"\n"
"Returns the current grid cell column position.");

extern "C" {static PyObject *meth_wxGrid_GetGridCursorCol(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridCursorCol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGridCursorCol();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridCursorCol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridCursorRow, "GetGridCursorRow() -> int\n"
"\n"
"Returns the current grid cell row position.");

extern "C" {static PyObject *meth_wxGrid_GetGridCursorRow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridCursorRow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGridCursorRow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridCursorRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GoToCell, "GoToCell(row, col)\n"
"GoToCell(coords)\n"
"\n"
"Make the given cell current and ensure it is visible.\n"
"");

extern "C" {static PyObject *meth_wxGrid_GoToCell(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GoToCell(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GoToCell(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GoToCell(*coords);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GoToCell, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MoveCursorDown, "MoveCursorDown(expandSelection) -> bool\n"
"\n"
"Moves the grid cursor down by one row.");

extern "C" {static PyObject *meth_wxGrid_MoveCursorDown(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MoveCursorDown(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool expandSelection;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_expandSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &expandSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCursorDown(expandSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MoveCursorDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MoveCursorDownBlock, "MoveCursorDownBlock(expandSelection) -> bool\n"
"\n"
"Moves the grid cursor down in the current column such that it skips to\n"
"the beginning or end of a block of non-empty cells.");

extern "C" {static PyObject *meth_wxGrid_MoveCursorDownBlock(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MoveCursorDownBlock(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool expandSelection;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_expandSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &expandSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCursorDownBlock(expandSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MoveCursorDownBlock, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MoveCursorLeft, "MoveCursorLeft(expandSelection) -> bool\n"
"\n"
"Moves the grid cursor left by one column.");

extern "C" {static PyObject *meth_wxGrid_MoveCursorLeft(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MoveCursorLeft(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool expandSelection;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_expandSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &expandSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCursorLeft(expandSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MoveCursorLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MoveCursorLeftBlock, "MoveCursorLeftBlock(expandSelection) -> bool\n"
"\n"
"Moves the grid cursor left in the current row such that it skips to\n"
"the beginning or end of a block of non-empty cells.");

extern "C" {static PyObject *meth_wxGrid_MoveCursorLeftBlock(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MoveCursorLeftBlock(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool expandSelection;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_expandSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &expandSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCursorLeftBlock(expandSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MoveCursorLeftBlock, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MoveCursorRight, "MoveCursorRight(expandSelection) -> bool\n"
"\n"
"Moves the grid cursor right by one column.");

extern "C" {static PyObject *meth_wxGrid_MoveCursorRight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MoveCursorRight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool expandSelection;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_expandSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &expandSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCursorRight(expandSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MoveCursorRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MoveCursorRightBlock, "MoveCursorRightBlock(expandSelection) -> bool\n"
"\n"
"Moves the grid cursor right in the current row such that it skips to\n"
"the beginning or end of a block of non-empty cells.");

extern "C" {static PyObject *meth_wxGrid_MoveCursorRightBlock(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MoveCursorRightBlock(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool expandSelection;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_expandSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &expandSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCursorRightBlock(expandSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MoveCursorRightBlock, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MoveCursorUp, "MoveCursorUp(expandSelection) -> bool\n"
"\n"
"Moves the grid cursor up by one row.");

extern "C" {static PyObject *meth_wxGrid_MoveCursorUp(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MoveCursorUp(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool expandSelection;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_expandSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &expandSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCursorUp(expandSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MoveCursorUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MoveCursorUpBlock, "MoveCursorUpBlock(expandSelection) -> bool\n"
"\n"
"Moves the grid cursor up in the current column such that it skips to\n"
"the beginning or end of a block of non-empty cells.");

extern "C" {static PyObject *meth_wxGrid_MoveCursorUpBlock(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MoveCursorUpBlock(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool expandSelection;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_expandSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &expandSelection))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MoveCursorUpBlock(expandSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MoveCursorUpBlock, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MovePageDown, "MovePageDown() -> bool\n"
"\n"
"Moves the grid cursor down by some number of rows so that the previous\n"
"bottom visible row becomes the top visible row.");

extern "C" {static PyObject *meth_wxGrid_MovePageDown(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MovePageDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MovePageDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MovePageDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MovePageUp, "MovePageUp() -> bool\n"
"\n"
"Moves the grid cursor up by some number of rows so that the previous\n"
"top visible row becomes the bottom visible row.");

extern "C" {static PyObject *meth_wxGrid_MovePageUp(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MovePageUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MovePageUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MovePageUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetGridCursor, "SetGridCursor(row, col)\n"
"SetGridCursor(coords)\n"
"\n"
"Set the grid cursor to the specified cell.\n"
"");

extern "C" {static PyObject *meth_wxGrid_SetGridCursor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetGridCursor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetGridCursor(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetGridCursor(*coords);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetGridCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetTabBehaviour, "SetTabBehaviour(behaviour)\n"
"\n"
"Set the grid's behaviour when the user presses the TAB key.");

extern "C" {static PyObject *meth_wxGrid_SetTabBehaviour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetTabBehaviour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid::TabBehaviour behaviour;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_behaviour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGrid_TabBehaviour, &behaviour))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTabBehaviour(behaviour);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetTabBehaviour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ClearSelection, "ClearSelection()\n"
"\n"
"Deselects all cells that are currently selected.");

extern "C" {static PyObject *meth_wxGrid_ClearSelection(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ClearSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ClearSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DeselectRow, "DeselectRow(row)\n"
"\n"
"Deselects a row of cells.");

extern "C" {static PyObject *meth_wxGrid_DeselectRow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DeselectRow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &row))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DeselectRow(row);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DeselectRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DeselectCol, "DeselectCol(col)\n"
"\n"
"Deselects a column of cells.");

extern "C" {static PyObject *meth_wxGrid_DeselectCol(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DeselectCol(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DeselectCol(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DeselectCol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DeselectCell, "DeselectCell(row, col)\n"
"\n"
"Deselects a cell.");

extern "C" {static PyObject *meth_wxGrid_DeselectCell(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DeselectCell(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DeselectCell(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DeselectCell, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectedBlocks, "GetSelectedBlocks() -> GridBlocks\n"
"\n"
"Returns a range of grid selection blocks.");

extern "C" {static PyObject *meth_wxGrid_GetSelectedBlocks(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectedBlocks(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridBlocks*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridBlocks(sipCpp->GetSelectedBlocks());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridBlocks,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectedBlocks, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectedRowBlocks, "GetSelectedRowBlocks() -> PyObject\n"
"\n"
"Returns an ordered range of non-overlapping selected rows.");

extern "C" {static PyObject *meth_wxGrid_GetSelectedRowBlocks(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectedRowBlocks(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyObject * sipRes = SIP_NULLPTR;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxGrid_GetSelectedRowBlocks(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectedRowBlocks, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectedColBlocks, "GetSelectedColBlocks() -> PyObject\n"
"\n"
"Returns an ordered range of non-overlapping selected columns.");

extern "C" {static PyObject *meth_wxGrid_GetSelectedColBlocks(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectedColBlocks(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyObject * sipRes = SIP_NULLPTR;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxGrid_GetSelectedColBlocks(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectedColBlocks, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectedCells, "GetSelectedCells() -> GridCellCoordsArray\n"
"\n"
"Returns an array of individually selected cells.");

extern "C" {static PyObject *meth_wxGrid_GetSelectedCells(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectedCells(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridCellCoordsArray*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridCellCoordsArray(sipCpp->GetSelectedCells());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridCellCoordsArray,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectedCells, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectedCols, "GetSelectedCols() -> ArrayInt\n"
"\n"
"Returns an array of selected columns.");

extern "C" {static PyObject *meth_wxGrid_GetSelectedCols(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectedCols(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxArrayInt*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxArrayInt(sipCpp->GetSelectedCols());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxArrayInt,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectedCols, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectedRows, "GetSelectedRows() -> ArrayInt\n"
"\n"
"Returns an array of selected rows.");

extern "C" {static PyObject *meth_wxGrid_GetSelectedRows(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectedRows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxArrayInt*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxArrayInt(sipCpp->GetSelectedRows());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxArrayInt,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectedRows, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectionBackground, "GetSelectionBackground() -> wx.Colour\n"
"\n"
"Returns the colour used for drawing the selection background.");

extern "C" {static PyObject *meth_wxGrid_GetSelectionBackground(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectionBackground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetSelectionBackground());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectionBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectionBlockBottomRight, "GetSelectionBlockBottomRight() -> GridCellCoordsArray\n"
"\n"
"Returns an array of the bottom right corners of blocks of selected\n"
"cells.");

extern "C" {static PyObject *meth_wxGrid_GetSelectionBlockBottomRight(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectionBlockBottomRight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridCellCoordsArray*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridCellCoordsArray(sipCpp->GetSelectionBlockBottomRight());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridCellCoordsArray,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectionBlockBottomRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectionBlockTopLeft, "GetSelectionBlockTopLeft() -> GridCellCoordsArray\n"
"\n"
"Returns an array of the top left corners of blocks of selected cells.");

extern "C" {static PyObject *meth_wxGrid_GetSelectionBlockTopLeft(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectionBlockTopLeft(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridCellCoordsArray*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridCellCoordsArray(sipCpp->GetSelectionBlockTopLeft());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridCellCoordsArray,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectionBlockTopLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectionForeground, "GetSelectionForeground() -> wx.Colour\n"
"\n"
"Returns the colour used for drawing the selection foreground.");

extern "C" {static PyObject *meth_wxGrid_GetSelectionForeground(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectionForeground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetSelectionForeground());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectionForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSelectionMode, "GetSelectionMode() -> GridSelectionModes\n"
"\n"
"Returns the current selection mode.");

extern "C" {static PyObject *meth_wxGrid_GetSelectionMode(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSelectionMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGrid::wxGridSelectionModes sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxGrid_wxGridSelectionModes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSelectionMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsInSelection, "IsInSelection(row, col) -> bool\n"
"IsInSelection(coords) -> bool\n"
"\n"
"Returns true if the given cell is selected.\n"
"");

extern "C" {static PyObject *meth_wxGrid_IsInSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsInSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsInSelection(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsInSelection(*coords);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsInSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsSelection, "IsSelection() -> bool\n"
"\n"
"Returns true if there are currently any selected cells, rows, columns\n"
"or blocks.");

extern "C" {static PyObject *meth_wxGrid_IsSelection(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SelectAll, "SelectAll()\n"
"\n"
"Selects all cells in the grid.");

extern "C" {static PyObject *meth_wxGrid_SelectAll(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SelectAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SelectAll();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SelectAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SelectBlock, "SelectBlock(topRow, leftCol, bottomRow, rightCol, addToSelected=False)\n"
"SelectBlock(topLeft, bottomRight, addToSelected=False)\n"
"\n"
"Selects a rectangular block of cells.\n"
"");

extern "C" {static PyObject *meth_wxGrid_SelectBlock(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SelectBlock(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int topRow;
        int leftCol;
        int bottomRow;
        int rightCol;
        bool addToSelected = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_topRow,
            sipName_leftCol,
            sipName_bottomRow,
            sipName_rightCol,
            sipName_addToSelected,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii|b", &sipSelf, sipType_wxGrid, &sipCpp, &topRow, &leftCol, &bottomRow, &rightCol, &addToSelected))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SelectBlock(topRow,leftCol,bottomRow,rightCol,addToSelected);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxGridCellCoords* topLeft;
        int topLeftState = 0;
        const  ::wxGridCellCoords* bottomRight;
        int bottomRightState = 0;
        bool addToSelected = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_topLeft,
            sipName_bottomRight,
            sipName_addToSelected,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1|b", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &topLeft, &topLeftState, sipType_wxGridCellCoords, &bottomRight, &bottomRightState, &addToSelected))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SelectBlock(*topLeft,*bottomRight,addToSelected);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(topLeft), sipType_wxGridCellCoords, topLeftState);
            sipReleaseType(const_cast< ::wxGridCellCoords *>(bottomRight), sipType_wxGridCellCoords, bottomRightState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SelectBlock, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SelectCol, "SelectCol(col, addToSelected=False)\n"
"\n"
"Selects the specified column.");

extern "C" {static PyObject *meth_wxGrid_SelectCol(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SelectCol(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        bool addToSelected = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_addToSelected,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|b", &sipSelf, sipType_wxGrid, &sipCpp, &col, &addToSelected))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SelectCol(col,addToSelected);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SelectCol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SelectRow, "SelectRow(row, addToSelected=False)\n"
"\n"
"Selects the specified row.");

extern "C" {static PyObject *meth_wxGrid_SelectRow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SelectRow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        bool addToSelected = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_addToSelected,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|b", &sipSelf, sipType_wxGrid, &sipCpp, &row, &addToSelected))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SelectRow(row,addToSelected);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SelectRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetSelectionBackground, "SetSelectionBackground(c)\n"
"\n"
"Set the colour to be used for drawing the selection background.");

extern "C" {static PyObject *meth_wxGrid_SetSelectionBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetSelectionBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* c;
        int cState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_c,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &c, &cState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionBackground(*c);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(c), sipType_wxColour, cState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetSelectionBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetSelectionForeground, "SetSelectionForeground(c)\n"
"\n"
"Set the colour to be used for drawing the selection foreground.");

extern "C" {static PyObject *meth_wxGrid_SetSelectionForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetSelectionForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* c;
        int cState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_c,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &c, &cState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionForeground(*c);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(c), sipType_wxColour, cState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetSelectionForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetSelectionMode, "SetSelectionMode(selmode)\n"
"\n"
"Set the selection behaviour of the grid.");

extern "C" {static PyObject *meth_wxGrid_SetSelectionMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetSelectionMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid::wxGridSelectionModes selmode;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selmode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGrid_wxGridSelectionModes, &selmode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionMode(selmode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetSelectionMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetScrollLineX, "GetScrollLineX() -> int\n"
"\n"
"Returns the number of pixels per horizontal scroll increment.");

extern "C" {static PyObject *meth_wxGrid_GetScrollLineX(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetScrollLineX(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetScrollLineX();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetScrollLineX, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetScrollLineY, "GetScrollLineY() -> int\n"
"\n"
"Returns the number of pixels per vertical scroll increment.");

extern "C" {static PyObject *meth_wxGrid_GetScrollLineY(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetScrollLineY(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetScrollLineY();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetScrollLineY, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsVisible, "IsVisible(row, col, wholeCellVisible=True) -> bool\n"
"IsVisible(coords, wholeCellVisible=True) -> bool\n"
"\n"
"Returns true if a cell is either entirely or at least partially\n"
"visible in the grid window.\n"
"");

extern "C" {static PyObject *meth_wxGrid_IsVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        bool wholeCellVisible = 1;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_wholeCellVisible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|b", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, &wholeCellVisible))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsVisible(row,col,wholeCellVisible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
        bool wholeCellVisible = 1;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
            sipName_wholeCellVisible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|b", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState, &wholeCellVisible))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsVisible(*coords,wholeCellVisible);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_MakeCellVisible, "MakeCellVisible(row, col)\n"
"MakeCellVisible(coords)\n"
"\n"
"Brings the specified cell into the visible grid cell area with minimal\n"
"scrolling.\n"
"");

extern "C" {static PyObject *meth_wxGrid_MakeCellVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_MakeCellVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MakeCellVisible(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MakeCellVisible(*coords);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_MakeCellVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetFirstFullyVisibleRow, "GetFirstFullyVisibleRow() -> int\n"
"\n"
"Returns the topmost row of the current visible area.");

extern "C" {static PyObject *meth_wxGrid_GetFirstFullyVisibleRow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetFirstFullyVisibleRow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFirstFullyVisibleRow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetFirstFullyVisibleRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetFirstFullyVisibleColumn, "GetFirstFullyVisibleColumn() -> int\n"
"\n"
"Returns the leftmost column of the current visible area.");

extern "C" {static PyObject *meth_wxGrid_GetFirstFullyVisibleColumn(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetFirstFullyVisibleColumn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFirstFullyVisibleColumn();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetFirstFullyVisibleColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetScrollLineX, "SetScrollLineX(x)\n"
"\n"
"Sets the number of pixels per horizontal scroll increment.");

extern "C" {static PyObject *meth_wxGrid_SetScrollLineX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetScrollLineX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &x))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetScrollLineX(x);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetScrollLineX, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetScrollLineY, "SetScrollLineY(y)\n"
"\n"
"Sets the number of pixels per vertical scroll increment.");

extern "C" {static PyObject *meth_wxGrid_SetScrollLineY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetScrollLineY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int y;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &y))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetScrollLineY(y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetScrollLineY, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_BlockToDeviceRect, "BlockToDeviceRect(topLeft, bottomRight, gridWindow=None) -> wx.Rect\n"
"\n"
"Convert grid cell coordinates to grid window pixel coordinates.");

extern "C" {static PyObject *meth_wxGrid_BlockToDeviceRect(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_BlockToDeviceRect(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGridCellCoords* topLeft;
        int topLeftState = 0;
        const  ::wxGridCellCoords* bottomRight;
        int bottomRightState = 0;
        const  ::wxGridWindow* gridWindow = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_topLeft,
            sipName_bottomRight,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1|J8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &topLeft, &topLeftState, sipType_wxGridCellCoords, &bottomRight, &bottomRightState, sipType_wxWindow, &gridWindow))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->BlockToDeviceRect(*topLeft,*bottomRight,gridWindow));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(topLeft), sipType_wxGridCellCoords, topLeftState);
            sipReleaseType(const_cast< ::wxGridCellCoords *>(bottomRight), sipType_wxGridCellCoords, bottomRightState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_BlockToDeviceRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CellToRect, "CellToRect(row, col) -> wx.Rect\n"
"CellToRect(coords) -> wx.Rect\n"
"\n"
"Return the rectangle corresponding to the grid cell's size and\n"
"position in logical coordinates.\n"
"");

extern "C" {static PyObject *meth_wxGrid_CellToRect(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CellToRect(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->CellToRect(row,col));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->CellToRect(*coords));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CellToRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CellToGridWindow, "CellToGridWindow(row, col) -> GridWindow\n"
"CellToGridWindow(coords) -> GridWindow\n"
"\n"
"Returns the grid window that contains the cell.\n"
"");

extern "C" {static PyObject *meth_wxGrid_CellToGridWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CellToGridWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGridWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CellToGridWindow(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
             ::wxGridWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CellToGridWindow(*coords);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CellToGridWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DevicePosToGridWindow, "DevicePosToGridWindow(pos) -> GridWindow\n"
"DevicePosToGridWindow(x, y) -> GridWindow\n"
"\n"
"Returns the grid window that includes the input coordinates.\n"
"");

extern "C" {static PyObject *meth_wxGrid_DevicePosToGridWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DevicePosToGridWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxPoint* pos;
        int posState = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxPoint, &pos, &posState))
        {
             ::wxGridWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DevicePosToGridWindow(*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos, sipType_wxPoint, posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    {
        int x;
        int y;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &x, &y))
        {
             ::wxGridWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DevicePosToGridWindow(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DevicePosToGridWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridWindowOffset, "GetGridWindowOffset(gridWindow) -> wx.Point");

extern "C" {static PyObject *meth_wxGrid_GetGridWindowOffset(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridWindowOffset(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGridWindow* gridWindow;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxWindow, &gridWindow))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetGridWindowOffset(gridWindow));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridWindowOffset, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CalcGridWindowUnscrolledPosition, "CalcGridWindowUnscrolledPosition(x, y, xx, yy, gridWindow)\n"
"CalcGridWindowUnscrolledPosition(pt, gridWindow) -> wx.Point\n"
"\n"
"Translates the device coordinates to the logical ones, taking into\n"
"account the grid window type.\n"
"");

extern "C" {static PyObject *meth_wxGrid_CalcGridWindowUnscrolledPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CalcGridWindowUnscrolledPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        int xx;
        int yy;
        const  ::wxGridWindow* gridWindow;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ8", &sipSelf, sipType_wxGrid, &sipCpp, &x, &y, sipType_wxWindow, &gridWindow))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CalcGridWindowUnscrolledPosition(x,y,&xx,&yy,gridWindow);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",xx,yy);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxGridWindow* gridWindow;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxPoint, &pt, &ptState, sipType_wxWindow, &gridWindow))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->CalcGridWindowUnscrolledPosition(*pt,gridWindow));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CalcGridWindowUnscrolledPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CalcGridWindowScrolledPosition, "CalcGridWindowScrolledPosition(x, y, xx, yy, gridWindow)\n"
"CalcGridWindowScrolledPosition(pt, gridWindow) -> wx.Point\n"
"\n"
"Translates the logical coordinates to the device ones, taking into\n"
"account the grid window type.\n"
"");

extern "C" {static PyObject *meth_wxGrid_CalcGridWindowScrolledPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CalcGridWindowScrolledPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        int xx;
        int yy;
        const  ::wxGridWindow* gridWindow;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ8", &sipSelf, sipType_wxGrid, &sipCpp, &x, &y, sipType_wxWindow, &gridWindow))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CalcGridWindowScrolledPosition(x,y,&xx,&yy,gridWindow);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",xx,yy);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxGridWindow* gridWindow;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxPoint, &pt, &ptState, sipType_wxWindow, &gridWindow))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->CalcGridWindowScrolledPosition(*pt,gridWindow));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CalcGridWindowScrolledPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_XToCol, "XToCol(x, clipToMinMax=False, gridWindow=None) -> int\n"
"\n"
"Returns the column at the given pixel position depending on the\n"
"window.");

extern "C" {static PyObject *meth_wxGrid_XToCol(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_XToCol(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        bool clipToMinMax = 0;
         ::wxGridWindow* gridWindow = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_clipToMinMax,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|bJ8", &sipSelf, sipType_wxGrid, &sipCpp, &x, &clipToMinMax, sipType_wxWindow, &gridWindow))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->XToCol(x,clipToMinMax,gridWindow);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_XToCol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_XToEdgeOfCol, "XToEdgeOfCol(x) -> int\n"
"\n"
"Returns the column whose right hand edge is close to the given logical\n"
"x position.");

extern "C" {static PyObject *meth_wxGrid_XToEdgeOfCol(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_XToEdgeOfCol(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &x))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->XToEdgeOfCol(x);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_XToEdgeOfCol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_XYToCell, "XYToCell(x, y, gridWindow=None) -> GridCellCoords\n"
"XYToCell(pos, gridWindow=None) -> GridCellCoords\n"
"\n"
"Translates logical pixel coordinates to the grid cell coordinates.\n"
"");

extern "C" {static PyObject *meth_wxGrid_XYToCell(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_XYToCell(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
         ::wxGridWindow* gridWindow = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|J8", &sipSelf, sipType_wxGrid, &sipCpp, &x, &y, sipType_wxWindow, &gridWindow))
        {
             ::wxGridCellCoords*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridCellCoords(sipCpp->XYToCell(x,y,gridWindow));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridCellCoords,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pos;
        int posState = 0;
         ::wxGridWindow* gridWindow = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|J8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxPoint, &pos, &posState, sipType_wxWindow, &gridWindow))
        {
             ::wxGridCellCoords*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridCellCoords(sipCpp->XYToCell(*pos,gridWindow));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridCellCoords,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_XYToCell, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_YToEdgeOfRow, "YToEdgeOfRow(y) -> int\n"
"\n"
"Returns the row whose bottom edge is close to the given logical y\n"
"position.");

extern "C" {static PyObject *meth_wxGrid_YToEdgeOfRow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_YToEdgeOfRow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int y;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &y))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->YToEdgeOfRow(y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_YToEdgeOfRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_YToRow, "YToRow(y, clipToMinMax=False, gridWindow=None) -> int\n"
"\n"
"Returns the grid row that corresponds to the logical y coordinate.");

extern "C" {static PyObject *meth_wxGrid_YToRow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_YToRow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int y;
        bool clipToMinMax = 0;
         ::wxGridWindow* gridWindow = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_y,
            sipName_clipToMinMax,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|bJ8", &sipSelf, sipType_wxGrid, &sipCpp, &y, &clipToMinMax, sipType_wxWindow, &gridWindow))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->YToRow(y,clipToMinMax,gridWindow);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_YToRow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AppendCols, "AppendCols(numCols=1, updateLabels=True) -> bool\n"
"\n"
"Appends one or more new columns to the right of the grid.");

extern "C" {static PyObject *meth_wxGrid_AppendCols(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AppendCols(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int numCols = 1;
        bool updateLabels = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_numCols,
            sipName_updateLabels,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ib", &sipSelf, sipType_wxGrid, &sipCpp, &numCols, &updateLabels))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AppendCols(numCols,updateLabels);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AppendCols, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AppendRows, "AppendRows(numRows=1, updateLabels=True) -> bool\n"
"\n"
"Appends one or more new rows to the bottom of the grid.");

extern "C" {static PyObject *meth_wxGrid_AppendRows(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AppendRows(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int numRows = 1;
        bool updateLabels = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_numRows,
            sipName_updateLabels,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|ib", &sipSelf, sipType_wxGrid, &sipCpp, &numRows, &updateLabels))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AppendRows(numRows,updateLabels);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AppendRows, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AreHorzGridLinesClipped, "AreHorzGridLinesClipped() -> bool\n"
"\n"
"Return true if the horizontal grid lines stop at the last column\n"
"boundary or false if they continue to the end of the window.");

extern "C" {static PyObject *meth_wxGrid_AreHorzGridLinesClipped(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AreHorzGridLinesClipped(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AreHorzGridLinesClipped();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AreHorzGridLinesClipped, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AreVertGridLinesClipped, "AreVertGridLinesClipped() -> bool\n"
"\n"
"Return true if the vertical grid lines stop at the last row boundary\n"
"or false if they continue to the end of the window.");

extern "C" {static PyObject *meth_wxGrid_AreVertGridLinesClipped(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AreVertGridLinesClipped(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AreVertGridLinesClipped();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AreVertGridLinesClipped, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_BeginBatch, "BeginBatch()\n"
"\n"
"Increments the grid's batch count.");

extern "C" {static PyObject *meth_wxGrid_BeginBatch(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_BeginBatch(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->BeginBatch();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_BeginBatch, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ClearGrid, "ClearGrid()\n"
"\n"
"Clears all data in the underlying grid table and repaints the grid.");

extern "C" {static PyObject *meth_wxGrid_ClearGrid(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ClearGrid(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearGrid();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ClearGrid, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ClipHorzGridLines, "ClipHorzGridLines(clip)\n"
"\n"
"Change whether the horizontal grid lines are clipped by the end of the\n"
"last column.");

extern "C" {static PyObject *meth_wxGrid_ClipHorzGridLines(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ClipHorzGridLines(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool clip;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_clip,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &clip))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClipHorzGridLines(clip);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ClipHorzGridLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ClipVertGridLines, "ClipVertGridLines(clip)\n"
"\n"
"Change whether the vertical grid lines are clipped by the end of the\n"
"last row.");

extern "C" {static PyObject *meth_wxGrid_ClipVertGridLines(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ClipVertGridLines(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool clip;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_clip,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &clip))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClipVertGridLines(clip);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ClipVertGridLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DeleteCols, "DeleteCols(pos=0, numCols=1, updateLabels=True) -> bool\n"
"\n"
"Deletes one or more columns from a grid starting at the specified\n"
"position.");

extern "C" {static PyObject *meth_wxGrid_DeleteCols(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DeleteCols(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos = 0;
        int numCols = 1;
        bool updateLabels = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_numCols,
            sipName_updateLabels,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|iib", &sipSelf, sipType_wxGrid, &sipCpp, &pos, &numCols, &updateLabels))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DeleteCols(pos,numCols,updateLabels);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DeleteCols, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DeleteRows, "DeleteRows(pos=0, numRows=1, updateLabels=True) -> bool\n"
"\n"
"Deletes one or more rows from a grid starting at the specified\n"
"position.");

extern "C" {static PyObject *meth_wxGrid_DeleteRows(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DeleteRows(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos = 0;
        int numRows = 1;
        bool updateLabels = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_numRows,
            sipName_updateLabels,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|iib", &sipSelf, sipType_wxGrid, &sipCpp, &pos, &numRows, &updateLabels))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DeleteRows(pos,numRows,updateLabels);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DeleteRows, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_FreezeTo, "FreezeTo(row, col) -> bool\n"
"FreezeTo(coords) -> bool\n"
"\n"
"Sets or resets the frozen columns and rows.\n"
"");

extern "C" {static PyObject *meth_wxGrid_FreezeTo(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_FreezeTo(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        uint row;
        uint col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Buu", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FreezeTo(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxGridCellCoords* coords;
        int coordsState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &coords, &coordsState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FreezeTo(*coords);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(coords), sipType_wxGridCellCoords, coordsState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_FreezeTo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EndBatch, "EndBatch()\n"
"\n"
"Decrements the grid's batch count.");

extern "C" {static PyObject *meth_wxGrid_EndBatch(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EndBatch(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EndBatch();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EndBatch, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_Fit, "Fit()\n"
"\n"
"Overridden wxWindow method.");

extern "C" {static PyObject *meth_wxGrid_Fit(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_Fit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Fit();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_Fit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ForceRefresh, "ForceRefresh()\n"
"\n"
"Causes immediate repainting of the grid.");

extern "C" {static PyObject *meth_wxGrid_ForceRefresh(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ForceRefresh(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ForceRefresh();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ForceRefresh, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetBatchCount, "GetBatchCount() -> int\n"
"\n"
"Returns the number of times that BeginBatch() has been called without\n"
"(yet) matching calls to EndBatch().");

extern "C" {static PyObject *meth_wxGrid_GetBatchCount(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetBatchCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetBatchCount();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetBatchCount, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetNumberCols, "GetNumberCols() -> int\n"
"\n"
"Returns the total number of grid columns.");

extern "C" {static PyObject *meth_wxGrid_GetNumberCols(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetNumberCols(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetNumberCols();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetNumberCols, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetNumberRows, "GetNumberRows() -> int\n"
"\n"
"Returns the total number of grid rows.");

extern "C" {static PyObject *meth_wxGrid_GetNumberRows(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetNumberRows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetNumberRows();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetNumberRows, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetNumberFrozenCols, "GetNumberFrozenCols() -> int\n"
"\n"
"Returns the number of frozen grid columns.");

extern "C" {static PyObject *meth_wxGrid_GetNumberFrozenCols(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetNumberFrozenCols(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetNumberFrozenCols();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetNumberFrozenCols, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetNumberFrozenRows, "GetNumberFrozenRows() -> int\n"
"\n"
"Returns the number of frozen grid rows.");

extern "C" {static PyObject *meth_wxGrid_GetNumberFrozenRows(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetNumberFrozenRows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetNumberFrozenRows();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetNumberFrozenRows, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetOrCreateCellAttr, "GetOrCreateCellAttr(row, col) -> GridCellAttr\n"
"\n"
"Returns the attribute for the given cell creating one if necessary.");

extern "C" {static PyObject *meth_wxGrid_GetOrCreateCellAttr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetOrCreateCellAttr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGridCellAttr*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetOrCreateCellAttr(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridCellAttr,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetOrCreateCellAttr, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetOrCreateCellAttrPtr, "GetOrCreateCellAttrPtr(row, col) -> GridCellAttrPtr\n"
"\n"
"Returns the attribute for the given cell creating one if necessary.");

extern "C" {static PyObject *meth_wxGrid_GetOrCreateCellAttrPtr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetOrCreateCellAttrPtr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
             ::wxGridCellAttrPtr*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridCellAttrPtr(sipCpp->GetOrCreateCellAttrPtr(row,col));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridCellAttrPtr,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetOrCreateCellAttrPtr, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetTable, "GetTable() -> GridTableBase\n"
"\n"
"Returns a base pointer to the current table object.");

extern "C" {static PyObject *meth_wxGrid_GetTable(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetTable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxGridTableBase*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTable();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxGridTableBase,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetTable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_InsertCols, "InsertCols(pos=0, numCols=1, updateLabels=True) -> bool\n"
"\n"
"Inserts one or more new columns into a grid with the first new column\n"
"at the specified position.");

extern "C" {static PyObject *meth_wxGrid_InsertCols(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_InsertCols(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos = 0;
        int numCols = 1;
        bool updateLabels = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_numCols,
            sipName_updateLabels,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|iib", &sipSelf, sipType_wxGrid, &sipCpp, &pos, &numCols, &updateLabels))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertCols(pos,numCols,updateLabels);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_InsertCols, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_InsertRows, "InsertRows(pos=0, numRows=1, updateLabels=True) -> bool\n"
"\n"
"Inserts one or more new rows into a grid with the first new row at the\n"
"specified position.");

extern "C" {static PyObject *meth_wxGrid_InsertRows(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_InsertRows(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos = 0;
        int numRows = 1;
        bool updateLabels = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_numRows,
            sipName_updateLabels,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|iib", &sipSelf, sipType_wxGrid, &sipCpp, &pos, &numRows, &updateLabels))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertRows(pos,numRows,updateLabels);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_InsertRows, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_RefreshAttr, "RefreshAttr(row, col)\n"
"\n"
"Invalidates the cached attribute for the given cell.");

extern "C" {static PyObject *meth_wxGrid_RefreshAttr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_RefreshAttr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RefreshAttr(row,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_RefreshAttr, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_RefreshBlock, "RefreshBlock(topLeft, bottomRight)\n"
"RefreshBlock(topRow, leftCol, bottomRow, rightCol)\n"
"\n"
"Redraw all the cells in the given block.\n"
"");

extern "C" {static PyObject *meth_wxGrid_RefreshBlock(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_RefreshBlock(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGridCellCoords* topLeft;
        int topLeftState = 0;
        const  ::wxGridCellCoords* bottomRight;
        int bottomRightState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_topLeft,
            sipName_bottomRight,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxGridCellCoords, &topLeft, &topLeftState, sipType_wxGridCellCoords, &bottomRight, &bottomRightState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RefreshBlock(*topLeft,*bottomRight);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxGridCellCoords *>(topLeft), sipType_wxGridCellCoords, topLeftState);
            sipReleaseType(const_cast< ::wxGridCellCoords *>(bottomRight), sipType_wxGridCellCoords, bottomRightState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        int topRow;
        int leftCol;
        int bottomRow;
        int rightCol;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_topRow,
            sipName_leftCol,
            sipName_bottomRow,
            sipName_rightCol,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxGrid, &sipCpp, &topRow, &leftCol, &bottomRow, &rightCol))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RefreshBlock(topRow,leftCol,bottomRow,rightCol);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_RefreshBlock, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_Render, "Render(dc, pos=wx.DefaultPosition, size=wx.DefaultSize, topLeft=GridCellCoords(-1,-1), bottomRight=GridCellCoords(-1,-1), style=GRID_DRAW_DEFAULT)\n"
"\n"
"Draws part or all of a wxGrid on a wxDC for printing or display.");

extern "C" {static PyObject *meth_wxGrid_Render(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_Render(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        const  ::wxGridCellCoords& topLeftdef = wxGridCellCoords(-1,-1);
        const  ::wxGridCellCoords* topLeft = &topLeftdef;
        int topLeftState = 0;
        const  ::wxGridCellCoords& bottomRightdef = wxGridCellCoords(-1,-1);
        const  ::wxGridCellCoords* bottomRight = &bottomRightdef;
        int bottomRightState = 0;
        int style = wxGRID_DRAW_DEFAULT;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
            sipName_pos,
            sipName_size,
            sipName_topLeft,
            sipName_bottomRight,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9|J1J1J1J1i", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, sipType_wxGridCellCoords, &topLeft, &topLeftState, sipType_wxGridCellCoords, &bottomRight, &bottomRightState, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Render(*dc,*pos,*size,*topLeft,*bottomRight,style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxGridCellCoords *>(topLeft), sipType_wxGridCellCoords, topLeftState);
            sipReleaseType(const_cast< ::wxGridCellCoords *>(bottomRight), sipType_wxGridCellCoords, bottomRightState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_Render, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetAttr, "SetAttr(row, col, attr)\n"
"\n"
"Sets the cell attributes for the specified cell.");

extern "C" {static PyObject *meth_wxGrid_SetAttr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetAttr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
        int col;
         ::wxGridCellAttr* attr;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_col,
            sipName_attr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ8", &sipSelf, sipType_wxGrid, &sipCpp, &row, &col, sipType_wxGridCellAttr, &attr))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAttr(row,col,attr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetAttr, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetColAttr, "SetColAttr(col, attr)\n"
"\n"
"Sets the cell attributes for all cells in the specified column.");

extern "C" {static PyObject *meth_wxGrid_SetColAttr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetColAttr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxGridCellAttr* attr;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_attr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ:", &sipSelf, sipType_wxGrid, &sipCpp, &col, sipType_wxGridCellAttr, &attr))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColAttr(col,attr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetColAttr, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetMargins, "SetMargins(extraWidth, extraHeight)\n"
"\n"
"Sets the extra margins used around the grid area.");

extern "C" {static PyObject *meth_wxGrid_SetMargins(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetMargins(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int extraWidth;
        int extraHeight;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_extraWidth,
            sipName_extraHeight,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &extraWidth, &extraHeight))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMargins(extraWidth,extraHeight);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetMargins, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetRowAttr, "SetRowAttr(row, attr)\n"
"\n"
"Sets the cell attributes for all cells in the specified row.");

extern "C" {static PyObject *meth_wxGrid_SetRowAttr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetRowAttr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int row;
         ::wxGridCellAttr* attr;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_attr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ:", &sipSelf, sipType_wxGrid, &sipCpp, &row, sipType_wxGridCellAttr, &attr))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowAttr(row,attr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetRowAttr, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CalcRowLabelsExposed, "CalcRowLabelsExposed(reg, gridWindow=None) -> ArrayInt\n"
"\n"
"Appends one or more new columns to the right of the grid.");

extern "C" {static PyObject *meth_wxGrid_CalcRowLabelsExposed(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CalcRowLabelsExposed(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRegion* reg;
         ::wxGridWindow* gridWindow = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_reg,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9|J8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxRegion, &reg, sipType_wxWindow, &gridWindow))
        {
             ::wxArrayInt*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxArrayInt(sipCpp->CalcRowLabelsExposed(*reg,gridWindow));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxArrayInt,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CalcRowLabelsExposed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CalcColLabelsExposed, "CalcColLabelsExposed(reg, gridWindow=None) -> ArrayInt\n"
"\n"
"Appends one or more new columns to the right of the grid.");

extern "C" {static PyObject *meth_wxGrid_CalcColLabelsExposed(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CalcColLabelsExposed(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRegion* reg;
         ::wxGridWindow* gridWindow = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_reg,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9|J8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxRegion, &reg, sipType_wxWindow, &gridWindow))
        {
             ::wxArrayInt*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxArrayInt(sipCpp->CalcColLabelsExposed(*reg,gridWindow));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxArrayInt,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CalcColLabelsExposed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CalcCellsExposed, "CalcCellsExposed(reg, gridWindow=None) -> GridCellCoordsArray\n"
"\n"
"Appends one or more new columns to the right of the grid.");

extern "C" {static PyObject *meth_wxGrid_CalcCellsExposed(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CalcCellsExposed(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRegion* reg;
         ::wxGridWindow* gridWindow = 0;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_reg,
            sipName_gridWindow,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9|J8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxRegion, &reg, sipType_wxWindow, &gridWindow))
        {
             ::wxGridCellCoordsArray*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxGridCellCoordsArray(sipCpp->CalcCellsExposed(*reg,gridWindow));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxGridCellCoordsArray,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CalcCellsExposed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetSortingColumn, "GetSortingColumn() -> int\n"
"\n"
"Return the column in which the sorting indicator is currently\n"
"displayed.");

extern "C" {static PyObject *meth_wxGrid_GetSortingColumn(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSortingColumn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSortingColumn();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetSortingColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsSortingBy, "IsSortingBy(col) -> bool\n"
"\n"
"Return true if this column is currently used for sorting.");

extern "C" {static PyObject *meth_wxGrid_IsSortingBy(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsSortingBy(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsSortingBy(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsSortingBy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsSortOrderAscending, "IsSortOrderAscending() -> bool\n"
"\n"
"Return true if the current sorting order is ascending or false if it\n"
"is descending.");

extern "C" {static PyObject *meth_wxGrid_IsSortOrderAscending(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsSortOrderAscending(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsSortOrderAscending();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsSortOrderAscending, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetSortingColumn, "SetSortingColumn(col, ascending=True)\n"
"\n"
"Set the column to display the sorting indicator in and its direction.");

extern "C" {static PyObject *meth_wxGrid_SetSortingColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetSortingColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        bool ascending = 1;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
            sipName_ascending,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|b", &sipSelf, sipType_wxGrid, &sipCpp, &col, &ascending))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSortingColumn(col,ascending);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetSortingColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_UnsetSortingColumn, "UnsetSortingColumn()\n"
"\n"
"Remove any currently shown sorting indicator.");

extern "C" {static PyObject *meth_wxGrid_UnsetSortingColumn(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_UnsetSortingColumn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->UnsetSortingColumn();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_UnsetSortingColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridWindow, "GetGridWindow() -> wx.Window\n"
"\n"
"Return the main grid window containing the grid cells.");

extern "C" {static PyObject *meth_wxGrid_GetGridWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGridWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetFrozenCornerGridWindow, "GetFrozenCornerGridWindow() -> wx.Window\n"
"\n"
"Return the corner grid window containing frozen cells.");

extern "C" {static PyObject *meth_wxGrid_GetFrozenCornerGridWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetFrozenCornerGridWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFrozenCornerGridWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetFrozenCornerGridWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetFrozenRowGridWindow, "GetFrozenRowGridWindow() -> wx.Window\n"
"\n"
"Return the rows grid window containing row frozen cells.");

extern "C" {static PyObject *meth_wxGrid_GetFrozenRowGridWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetFrozenRowGridWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFrozenRowGridWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetFrozenRowGridWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetFrozenColGridWindow, "GetFrozenColGridWindow() -> wx.Window\n"
"\n"
"Return the columns grid window containing column frozen cells.");

extern "C" {static PyObject *meth_wxGrid_GetFrozenColGridWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetFrozenColGridWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFrozenColGridWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetFrozenColGridWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridRowLabelWindow, "GetGridRowLabelWindow() -> wx.Window\n"
"\n"
"Return the row labels window.");

extern "C" {static PyObject *meth_wxGrid_GetGridRowLabelWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridRowLabelWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGridRowLabelWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridRowLabelWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridColLabelWindow, "GetGridColLabelWindow() -> wx.Window\n"
"\n"
"Return the column labels window.");

extern "C" {static PyObject *meth_wxGrid_GetGridColLabelWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridColLabelWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGridColLabelWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridColLabelWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridCornerLabelWindow, "GetGridCornerLabelWindow() -> wx.Window\n"
"\n"
"Return the window in the top left grid corner.");

extern "C" {static PyObject *meth_wxGrid_GetGridCornerLabelWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridCornerLabelWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGridCornerLabelWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridCornerLabelWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetGridColHeader, "GetGridColHeader() -> wx.HeaderCtrl\n"
"\n"
"Return the header control used for column labels display.");

extern "C" {static PyObject *meth_wxGrid_GetGridColHeader(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetGridColHeader(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxHeaderCtrl*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGridColHeader();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxHeaderCtrl,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetGridColHeader, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_IsUsingNativeHeader, "IsUsingNativeHeader() -> bool\n"
"\n"
"Return true if native header control is currently being used.");

extern "C" {static PyObject *meth_wxGrid_IsUsingNativeHeader(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_IsUsingNativeHeader(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsUsingNativeHeader();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_IsUsingNativeHeader, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DrawCellHighlight, "DrawCellHighlight(dc, attr)");

extern "C" {static PyObject *meth_wxGrid_DrawCellHighlight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DrawCellHighlight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
        const  ::wxGridCellAttr* attr;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
            sipName_attr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc, sipType_wxGridCellAttr, &attr))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DrawCellHighlight(*dc,attr);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DrawCellHighlight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DrawRowLabels, "DrawRowLabels(dc, rows)");

extern "C" {static PyObject *meth_wxGrid_DrawRowLabels(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DrawRowLabels(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
        const  ::wxArrayInt* rows;
        int rowsState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
            sipName_rows,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc, sipType_wxArrayInt, &rows, &rowsState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DrawRowLabels(*dc,*rows);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxArrayInt *>(rows), sipType_wxArrayInt, rowsState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DrawRowLabels, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DrawRowLabel, "DrawRowLabel(dc, row)");

extern "C" {static PyObject *meth_wxGrid_DrawRowLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DrawRowLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
        int row;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9i", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc, &row))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DrawRowLabel(*dc,row);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DrawRowLabel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DrawColLabels, "DrawColLabels(dc, cols)");

extern "C" {static PyObject *meth_wxGrid_DrawColLabels(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DrawColLabels(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
        const  ::wxArrayInt* cols;
        int colsState = 0;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
            sipName_cols,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc, sipType_wxArrayInt, &cols, &colsState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DrawColLabels(*dc,*cols);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxArrayInt *>(cols), sipType_wxArrayInt, colsState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DrawColLabels, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DrawColLabel, "DrawColLabel(dc, col)");

extern "C" {static PyObject *meth_wxGrid_DrawColLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DrawColLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
        int col;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9i", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DrawColLabel(*dc,col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DrawColLabel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DrawCornerLabel, "DrawCornerLabel(dc)");

extern "C" {static PyObject *meth_wxGrid_DrawCornerLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DrawCornerLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DrawCornerLabel(*dc);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DrawCornerLabel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DrawTextRectangle, "DrawTextRectangle(dc, text, rect, horizontalAlignment=wx.ALIGN_LEFT, verticalAlignment=wx.ALIGN_TOP, textOrientation=wx.HORIZONTAL)\n"
"DrawTextRectangle(dc, lines, rect, horizontalAlignment=wx.ALIGN_LEFT, verticalAlignment=wx.ALIGN_TOP, textOrientation=wx.HORIZONTAL)\n"
"");

extern "C" {static PyObject *meth_wxGrid_DrawTextRectangle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DrawTextRectangle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDC* dc;
        const  ::wxString* text;
        int textState = 0;
        const  ::wxRect* rect;
        int rectState = 0;
        int horizontalAlignment = wxALIGN_LEFT;
        int verticalAlignment = wxALIGN_TOP;
        int textOrientation = wxHORIZONTAL;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
            sipName_text,
            sipName_rect,
            sipName_horizontalAlignment,
            sipName_verticalAlignment,
            sipName_textOrientation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J1J1|iii", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc, sipType_wxString, &text, &textState, sipType_wxRect, &rect, &rectState, &horizontalAlignment, &verticalAlignment, &textOrientation))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DrawTextRectangle(*dc,*text,*rect,horizontalAlignment,verticalAlignment,textOrientation);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::wxDC* dc;
        const  ::wxArrayString* lines;
        int linesState = 0;
        const  ::wxRect* rect;
        int rectState = 0;
        int horizontalAlignment = wxALIGN_LEFT;
        int verticalAlignment = wxALIGN_TOP;
        int textOrientation = wxHORIZONTAL;
        const  ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dc,
            sipName_lines,
            sipName_rect,
            sipName_horizontalAlignment,
            sipName_verticalAlignment,
            sipName_textOrientation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J1J1|iii", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxDC, &dc, sipType_wxArrayString, &lines, &linesState, sipType_wxRect, &rect, &rectState, &horizontalAlignment, &verticalAlignment, &textOrientation))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DrawTextRectangle(*dc,*lines,*rect,horizontalAlignment,verticalAlignment,textOrientation);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxArrayString *>(lines), sipType_wxArrayString, linesState);
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DrawTextRectangle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellHighlightColour, "GetCellHighlightColour() -> wx.Colour");

extern "C" {static PyObject *meth_wxGrid_GetCellHighlightColour(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellHighlightColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetCellHighlightColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellHighlightColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellHighlightPenWidth, "GetCellHighlightPenWidth() -> int");

extern "C" {static PyObject *meth_wxGrid_GetCellHighlightPenWidth(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellHighlightPenWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCellHighlightPenWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellHighlightPenWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetCellHighlightROPenWidth, "GetCellHighlightROPenWidth() -> int");

extern "C" {static PyObject *meth_wxGrid_GetCellHighlightROPenWidth(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetCellHighlightROPenWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCellHighlightROPenWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetCellHighlightROPenWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellHighlightColour, "SetCellHighlightColour()");

extern "C" {static PyObject *meth_wxGrid_SetCellHighlightColour(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellHighlightColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* a0;
        int a0State = 0;
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &a0, &a0State))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellHighlightColour(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(a0), sipType_wxColour, a0State);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellHighlightColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellHighlightPenWidth, "SetCellHighlightPenWidth(width)");

extern "C" {static PyObject *meth_wxGrid_SetCellHighlightPenWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellHighlightPenWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &width))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellHighlightPenWidth(width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellHighlightPenWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCellHighlightROPenWidth, "SetCellHighlightROPenWidth(width)");

extern "C" {static PyObject *meth_wxGrid_SetCellHighlightROPenWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCellHighlightROPenWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &width))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCellHighlightROPenWidth(width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCellHighlightROPenWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetGridFrozenBorderColour, "SetGridFrozenBorderColour()");

extern "C" {static PyObject *meth_wxGrid_SetGridFrozenBorderColour(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetGridFrozenBorderColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* a0;
        int a0State = 0;
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxColour, &a0, &a0State))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetGridFrozenBorderColour(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(a0), sipType_wxColour, a0State);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetGridFrozenBorderColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetGridFrozenBorderPenWidth, "SetGridFrozenBorderPenWidth(width)");

extern "C" {static PyObject *meth_wxGrid_SetGridFrozenBorderPenWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetGridFrozenBorderPenWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &width))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetGridFrozenBorderPenWidth(width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetGridFrozenBorderPenWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetClientAreaOrigin, "GetClientAreaOrigin(self) -> Point");

extern "C" {static PyObject *meth_wxGrid_GetClientAreaOrigin(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetClientAreaOrigin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint((sipSelfWasArg ? sipCpp-> ::wxGrid::GetClientAreaOrigin() : sipCpp->GetClientAreaOrigin()));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetClientAreaOrigin, doc_wxGrid_GetClientAreaOrigin);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_Validate, "Validate(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_Validate(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_Validate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::Validate() : sipCpp->Validate());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_Validate, doc_wxGrid_Validate);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_TransferDataToWindow, "TransferDataToWindow(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_TransferDataToWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_TransferDataToWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::TransferDataToWindow() : sipCpp->TransferDataToWindow());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_TransferDataToWindow, doc_wxGrid_TransferDataToWindow);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_TransferDataFromWindow, "TransferDataFromWindow(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_TransferDataFromWindow(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_TransferDataFromWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::TransferDataFromWindow() : sipCpp->TransferDataFromWindow());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_TransferDataFromWindow, doc_wxGrid_TransferDataFromWindow);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_InitDialog, "InitDialog(self)");

extern "C" {static PyObject *meth_wxGrid_InitDialog(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_InitDialog(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGrid::InitDialog() : sipCpp->InitDialog());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_InitDialog, doc_wxGrid_InitDialog);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AcceptsFocus, "AcceptsFocus(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_AcceptsFocus(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AcceptsFocus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::AcceptsFocus() : sipCpp->AcceptsFocus());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AcceptsFocus, doc_wxGrid_AcceptsFocus);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AcceptsFocusRecursively, "AcceptsFocusRecursively(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_AcceptsFocusRecursively(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AcceptsFocusRecursively(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::AcceptsFocusRecursively() : sipCpp->AcceptsFocusRecursively());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AcceptsFocusRecursively, doc_wxGrid_AcceptsFocusRecursively);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AcceptsFocusFromKeyboard, "AcceptsFocusFromKeyboard(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_AcceptsFocusFromKeyboard(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AcceptsFocusFromKeyboard(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::AcceptsFocusFromKeyboard() : sipCpp->AcceptsFocusFromKeyboard());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AcceptsFocusFromKeyboard, doc_wxGrid_AcceptsFocusFromKeyboard);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_AddChild, "AddChild(self, child: WindowBase)");

extern "C" {static PyObject *meth_wxGrid_AddChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_AddChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowBase* child;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_child,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxWindowBase, &child))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGrid::AddChild(child) : sipCpp->AddChild(child));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_AddChild, doc_wxGrid_AddChild);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_RemoveChild, "RemoveChild(self, child: WindowBase)");

extern "C" {static PyObject *meth_wxGrid_RemoveChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_RemoveChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowBase* child;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_child,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxWindowBase, &child))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGrid::RemoveChild(child) : sipCpp->RemoveChild(child));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_RemoveChild, doc_wxGrid_RemoveChild);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_InheritAttributes, "InheritAttributes(self)");

extern "C" {static PyObject *meth_wxGrid_InheritAttributes(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_InheritAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGrid::InheritAttributes() : sipCpp->InheritAttributes());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_InheritAttributes, doc_wxGrid_InheritAttributes);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ShouldInheritColours, "ShouldInheritColours(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_ShouldInheritColours(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ShouldInheritColours(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::ShouldInheritColours() : sipCpp->ShouldInheritColours());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ShouldInheritColours, doc_wxGrid_ShouldInheritColours);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_OnInternalIdle, "OnInternalIdle(self)");

extern "C" {static PyObject *meth_wxGrid_OnInternalIdle(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_OnInternalIdle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGrid::OnInternalIdle() : sipCpp->OnInternalIdle());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_OnInternalIdle, doc_wxGrid_OnInternalIdle);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetMainWindowOfCompositeControl, "GetMainWindowOfCompositeControl(self) -> Window");

extern "C" {static PyObject *meth_wxGrid_GetMainWindowOfCompositeControl(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetMainWindowOfCompositeControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::GetMainWindowOfCompositeControl() : sipCpp->GetMainWindowOfCompositeControl());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetMainWindowOfCompositeControl, doc_wxGrid_GetMainWindowOfCompositeControl);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_InformFirstDirection, "InformFirstDirection(self, direction: int, size: int, availableOtherDir: int) -> bool");

extern "C" {static PyObject *meth_wxGrid_InformFirstDirection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_InformFirstDirection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int direction;
        int size;
        int availableOtherDir;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_direction,
            sipName_size,
            sipName_availableOtherDir,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biii", &sipSelf, sipType_wxGrid, &sipCpp, &direction, &size, &availableOtherDir))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::InformFirstDirection(direction,size,availableOtherDir) : sipCpp->InformFirstDirection(direction,size,availableOtherDir));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_InformFirstDirection, doc_wxGrid_InformFirstDirection);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetCanFocus, "SetCanFocus(self, canFocus: bool)");

extern "C" {static PyObject *meth_wxGrid_SetCanFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetCanFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool canFocus;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_canFocus,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &canFocus))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGrid::SetCanFocus(canFocus) : sipCpp->SetCanFocus(canFocus));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetCanFocus, doc_wxGrid_SetCanFocus);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_Destroy, "Destroy(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_Destroy(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_Destroy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::Destroy() : sipCpp->Destroy());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_Destroy, doc_wxGrid_Destroy);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_SetValidator, "SetValidator(self, validator: Validator)");

extern "C" {static PyObject *meth_wxGrid_SetValidator(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_SetValidator(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxValidator* validator;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_validator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxValidator, &validator))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGrid::SetValidator(*validator) : sipCpp->SetValidator(*validator));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_SetValidator, doc_wxGrid_SetValidator);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetValidator, "GetValidator(self) -> Validator");

extern "C" {static PyObject *meth_wxGrid_GetValidator(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetValidator(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxValidator*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGrid::GetValidator() : sipCpp->GetValidator());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxValidator,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetValidator, doc_wxGrid_GetValidator);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_EnableVisibleFocus, "EnableVisibleFocus(self, enabled: bool)");

extern "C" {static PyObject *meth_wxGrid_EnableVisibleFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_EnableVisibleFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool enabled;
         ::wxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enabled,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &enabled))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGrid::EnableVisibleFocus(enabled) : sipCpp->EnableVisibleFocus(enabled));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_EnableVisibleFocus, doc_wxGrid_EnableVisibleFocus);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_ProcessEvent, "ProcessEvent(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxGrid_ProcessEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_ProcessEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_ProcessEvent(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_ProcessEvent, doc_wxGrid_ProcessEvent);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoEnable, "DoEnable(self, enable: bool)");

extern "C" {static PyObject *meth_wxGrid_DoEnable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoEnable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool enable;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxGrid, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoEnable(sipSelfWasArg,enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoEnable, doc_wxGrid_DoEnable);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoGetPosition, "DoGetPosition(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxGrid_DoGetPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoGetPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        const sipwxGrid *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetPosition(sipSelfWasArg,&x,&y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",x,y);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoGetPosition, doc_wxGrid_DoGetPosition);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoGetSize, "DoGetSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxGrid_DoGetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoGetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxGrid *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoGetSize, doc_wxGrid_DoGetSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoGetClientSize, "DoGetClientSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxGrid_DoGetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoGetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxGrid *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetClientSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoGetClientSize, doc_wxGrid_DoGetClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoGetBestSize, "DoGetBestSize(self) -> Size");

extern "C" {static PyObject *meth_wxGrid_DoGetBestSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoGetBestSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoGetBestSize, doc_wxGrid_DoGetBestSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoGetBestClientSize, "DoGetBestClientSize(self) -> Size");

extern "C" {static PyObject *meth_wxGrid_DoGetBestClientSize(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoGetBestClientSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestClientSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoGetBestClientSize, doc_wxGrid_DoGetBestClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoSetSize, "DoSetSize(self, x: int, y: int, width: int, height: int, sizeFlags: int)");

extern "C" {static PyObject *meth_wxGrid_DoSetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoSetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        int sizeFlags;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
            sipName_sizeFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiiii", &sipSelf, sipType_wxGrid, &sipCpp, &x, &y, &width, &height, &sizeFlags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSize(sipSelfWasArg,x,y,width,height,sizeFlags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoSetSize, doc_wxGrid_DoSetSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoSetClientSize, "DoSetClientSize(self, width: int, height: int)");

extern "C" {static PyObject *meth_wxGrid_DoSetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoSetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxGrid, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetClientSize(sipSelfWasArg,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoSetClientSize, doc_wxGrid_DoSetClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoSetSizeHints, "DoSetSizeHints(self, minW: int, minH: int, maxW: int, maxH: int, incW: int, incH: int)");

extern "C" {static PyObject *meth_wxGrid_DoSetSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoSetSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int minW;
        int minH;
        int maxW;
        int maxH;
        int incW;
        int incH;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minW,
            sipName_minH,
            sipName_maxW,
            sipName_maxH,
            sipName_incW,
            sipName_incH,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiiiii", &sipSelf, sipType_wxGrid, &sipCpp, &minW, &minH, &maxW, &maxH, &incW, &incH))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSizeHints(sipSelfWasArg,minW,minH,maxW,maxH,incW,incH);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoSetSizeHints, doc_wxGrid_DoSetSizeHints);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoMoveWindow, "DoMoveWindow(self, x: int, y: int, width: int, height: int)");

extern "C" {static PyObject *meth_wxGrid_DoMoveWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoMoveWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxGrid, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoMoveWindow(sipSelfWasArg,x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoMoveWindow, doc_wxGrid_DoMoveWindow);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoSetWindowVariant, "DoSetWindowVariant(self, variant: WindowVariant)");

extern "C" {static PyObject *meth_wxGrid_DoSetWindowVariant(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoSetWindowVariant(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowVariant variant;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxWindowVariant, &variant))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetWindowVariant(sipSelfWasArg,variant);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoSetWindowVariant, doc_wxGrid_DoSetWindowVariant);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultBorder, "GetDefaultBorder(self) -> Border");

extern "C" {static PyObject *meth_wxGrid_GetDefaultBorder(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultBorder(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorder(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultBorder, doc_wxGrid_GetDefaultBorder);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetDefaultBorderForControl, "GetDefaultBorderForControl(self) -> Border");

extern "C" {static PyObject *meth_wxGrid_GetDefaultBorderForControl(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetDefaultBorderForControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorderForControl(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetDefaultBorderForControl, doc_wxGrid_GetDefaultBorderForControl);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoFreeze, "DoFreeze(self)");

extern "C" {static PyObject *meth_wxGrid_DoFreeze(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoFreeze(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoFreeze(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoFreeze, doc_wxGrid_DoFreeze);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_DoThaw, "DoThaw(self)");

extern "C" {static PyObject *meth_wxGrid_DoThaw(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_DoThaw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoThaw(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_DoThaw, doc_wxGrid_DoThaw);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_HasTransparentBackground, "HasTransparentBackground(self) -> bool");

extern "C" {static PyObject *meth_wxGrid_HasTransparentBackground(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_HasTransparentBackground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_HasTransparentBackground(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_HasTransparentBackground, doc_wxGrid_HasTransparentBackground);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_TryBefore, "TryBefore(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxGrid_TryBefore(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_TryBefore(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryBefore(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_TryBefore, doc_wxGrid_TryBefore);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_TryAfter, "TryAfter(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxGrid_TryAfter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_TryAfter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxGrid, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryAfter(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_TryAfter, doc_wxGrid_TryAfter);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetClassDefaultAttributes, "GetClassDefaultAttributes(variant=wx.WINDOW_VARIANT_NORMAL) -> wx.VisualAttributes");

extern "C" {static PyObject *meth_wxGrid_GetClassDefaultAttributes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetClassDefaultAttributes(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "|E", sipType_wxWindowVariant, &variant))
        {
             ::wxVisualAttributes*sipRes;
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxVisualAttributes( ::wxGrid::GetClassDefaultAttributes(variant));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxVisualAttributes,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetClassDefaultAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_CanHaveAttributes, "CanHaveAttributes() -> bool\n"
"\n"
"Returns true if this grid has support for cell attributes.");

extern "C" {static PyObject *meth_wxGrid_CanHaveAttributes(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_CanHaveAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const sipwxGrid *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGrid, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtect_CanHaveAttributes();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_CanHaveAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColMinimalWidth, "GetColMinimalWidth(col) -> int\n"
"\n"
"Get the minimal width of the given column/row.");

extern "C" {static PyObject *meth_wxGrid_GetColMinimalWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColMinimalWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtect_GetColMinimalWidth(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColMinimalWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColRight, "GetColRight(col) -> int\n"
"\n"
"Returns the coordinate of the right border specified column.");

extern "C" {static PyObject *meth_wxGrid_GetColRight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColRight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtect_GetColRight(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetColLeft, "GetColLeft(col) -> int\n"
"\n"
"Returns the coordinate of the left border specified column.");

extern "C" {static PyObject *meth_wxGrid_GetColLeft(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetColLeft(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtect_GetColLeft(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetColLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxGrid_GetRowMinimalHeight, "GetRowMinimalHeight(col) -> int\n"
"\n"
"Returns the minimal size for the given column.");

extern "C" {static PyObject *meth_wxGrid_GetRowMinimalHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetRowMinimalHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
        const sipwxGrid *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxGrid, &sipCpp, &col))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtect_GetRowMinimalHeight(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Grid, sipName_GetRowMinimalHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_wxGrid_GetSizeAvailableForScrollTarget(PyObject *, PyObject *);}
static PyObject *meth_wxGrid_GetSizeAvailableForScrollTarget(PyObject *, PyObject *)
{

    sipNoMethod(SIP_NULLPTR, sipName_Grid, sipName_GetSizeAvailableForScrollTarget, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxGrid(void *, const sipTypeDef *);}
static void *cast_wxGrid(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxGrid *sipCpp = reinterpret_cast< ::wxGrid *>(sipCppV);

    if (targetType == sipType_wxGrid)
        return sipCppV;

    sipCppV = ((const sipClassTypeDef *)sipType_wxScrolledCanvas)->ctd_cast(static_cast< ::wxScrolledCanvas *>(sipCpp), targetType);
    if (sipCppV)
        return sipCppV;

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxGrid(void *, int);}
static void release_wxGrid(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxGrid *>(sipCppV);
    else
        delete reinterpret_cast< ::wxGrid *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxGrid(sipSimpleWrapper *);}
static void dealloc_wxGrid(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxGrid *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxGrid(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxGrid(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxGrid(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipwxGrid *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxGrid();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
         ::wxWindow* parent;
         ::wxWindowID id = wxID_ANY;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        long style = wxWANTS_CHARS;
        const  ::wxString& namedef = wxGridNameStr;
        const  ::wxString* name = &namedef;
        int nameState = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
            sipName_id,
            sipName_pos,
            sipName_size,
            sipName_style,
            sipName_name,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "JH|iJ1J1lJ1", sipType_wxWindow, &parent, sipOwner, &id, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, &style, sipType_wxString, &name, &nameState))
        {
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxGrid(parent,id,*pos,*size,style,*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxGrid[] = {{25, 0, 1}};


static PyMethodDef methods_wxGrid[] = {
    {sipName_AcceptsFocus, meth_wxGrid_AcceptsFocus, METH_VARARGS, doc_wxGrid_AcceptsFocus},
    {sipName_AcceptsFocusFromKeyboard, meth_wxGrid_AcceptsFocusFromKeyboard, METH_VARARGS, doc_wxGrid_AcceptsFocusFromKeyboard},
    {sipName_AcceptsFocusRecursively, meth_wxGrid_AcceptsFocusRecursively, METH_VARARGS, doc_wxGrid_AcceptsFocusRecursively},
    {sipName_AddChild, SIP_MLMETH_CAST(meth_wxGrid_AddChild), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AddChild},
    {sipName_AppendCols, SIP_MLMETH_CAST(meth_wxGrid_AppendCols), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AppendCols},
    {sipName_AppendRows, SIP_MLMETH_CAST(meth_wxGrid_AppendRows), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AppendRows},
    {sipName_AreHorzGridLinesClipped, meth_wxGrid_AreHorzGridLinesClipped, METH_VARARGS, doc_wxGrid_AreHorzGridLinesClipped},
    {sipName_AreVertGridLinesClipped, meth_wxGrid_AreVertGridLinesClipped, METH_VARARGS, doc_wxGrid_AreVertGridLinesClipped},
    {sipName_AssignTable, SIP_MLMETH_CAST(meth_wxGrid_AssignTable), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AssignTable},
    {sipName_AutoSize, meth_wxGrid_AutoSize, METH_VARARGS, doc_wxGrid_AutoSize},
    {sipName_AutoSizeColLabelSize, SIP_MLMETH_CAST(meth_wxGrid_AutoSizeColLabelSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AutoSizeColLabelSize},
    {sipName_AutoSizeColumn, SIP_MLMETH_CAST(meth_wxGrid_AutoSizeColumn), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AutoSizeColumn},
    {sipName_AutoSizeColumns, SIP_MLMETH_CAST(meth_wxGrid_AutoSizeColumns), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AutoSizeColumns},
    {sipName_AutoSizeRow, SIP_MLMETH_CAST(meth_wxGrid_AutoSizeRow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AutoSizeRow},
    {sipName_AutoSizeRowLabelSize, SIP_MLMETH_CAST(meth_wxGrid_AutoSizeRowLabelSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AutoSizeRowLabelSize},
    {sipName_AutoSizeRows, SIP_MLMETH_CAST(meth_wxGrid_AutoSizeRows), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_AutoSizeRows},
    {sipName_BeginBatch, meth_wxGrid_BeginBatch, METH_VARARGS, doc_wxGrid_BeginBatch},
    {sipName_BlockToDeviceRect, SIP_MLMETH_CAST(meth_wxGrid_BlockToDeviceRect), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_BlockToDeviceRect},
    {sipName_CalcCellsExposed, SIP_MLMETH_CAST(meth_wxGrid_CalcCellsExposed), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CalcCellsExposed},
    {sipName_CalcColLabelsExposed, SIP_MLMETH_CAST(meth_wxGrid_CalcColLabelsExposed), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CalcColLabelsExposed},
    {sipName_CalcGridWindowScrolledPosition, SIP_MLMETH_CAST(meth_wxGrid_CalcGridWindowScrolledPosition), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CalcGridWindowScrolledPosition},
    {sipName_CalcGridWindowUnscrolledPosition, SIP_MLMETH_CAST(meth_wxGrid_CalcGridWindowUnscrolledPosition), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CalcGridWindowUnscrolledPosition},
    {sipName_CalcRowLabelsExposed, SIP_MLMETH_CAST(meth_wxGrid_CalcRowLabelsExposed), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CalcRowLabelsExposed},
    {sipName_CanDragCell, meth_wxGrid_CanDragCell, METH_VARARGS, doc_wxGrid_CanDragCell},
    {sipName_CanDragColMove, meth_wxGrid_CanDragColMove, METH_VARARGS, doc_wxGrid_CanDragColMove},
    {sipName_CanDragColSize, SIP_MLMETH_CAST(meth_wxGrid_CanDragColSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CanDragColSize},
    {sipName_CanDragGridColEdges, meth_wxGrid_CanDragGridColEdges, METH_VARARGS, doc_wxGrid_CanDragGridColEdges},
    {sipName_CanDragGridRowEdges, meth_wxGrid_CanDragGridRowEdges, METH_VARARGS, doc_wxGrid_CanDragGridRowEdges},
    {sipName_CanDragGridSize, meth_wxGrid_CanDragGridSize, METH_VARARGS, doc_wxGrid_CanDragGridSize},
    {sipName_CanDragRowMove, meth_wxGrid_CanDragRowMove, METH_VARARGS, doc_wxGrid_CanDragRowMove},
    {sipName_CanDragRowSize, SIP_MLMETH_CAST(meth_wxGrid_CanDragRowSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CanDragRowSize},
    {sipName_CanEnableCellControl, meth_wxGrid_CanEnableCellControl, METH_VARARGS, doc_wxGrid_CanEnableCellControl},
    {sipName_CanHaveAttributes, meth_wxGrid_CanHaveAttributes, METH_VARARGS, doc_wxGrid_CanHaveAttributes},
    {sipName_CanHideColumns, meth_wxGrid_CanHideColumns, METH_VARARGS, doc_wxGrid_CanHideColumns},
    {sipName_CellToGridWindow, SIP_MLMETH_CAST(meth_wxGrid_CellToGridWindow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CellToGridWindow},
    {sipName_CellToRect, SIP_MLMETH_CAST(meth_wxGrid_CellToRect), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CellToRect},
    {sipName_ClearGrid, meth_wxGrid_ClearGrid, METH_VARARGS, doc_wxGrid_ClearGrid},
    {sipName_ClearSelection, meth_wxGrid_ClearSelection, METH_VARARGS, doc_wxGrid_ClearSelection},
    {sipName_ClipHorzGridLines, SIP_MLMETH_CAST(meth_wxGrid_ClipHorzGridLines), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_ClipHorzGridLines},
    {sipName_ClipVertGridLines, SIP_MLMETH_CAST(meth_wxGrid_ClipVertGridLines), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_ClipVertGridLines},
    {sipName_Create, SIP_MLMETH_CAST(meth_wxGrid_Create), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_Create},
    {sipName_CreateGrid, SIP_MLMETH_CAST(meth_wxGrid_CreateGrid), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_CreateGrid},
    {sipName_DeleteCols, SIP_MLMETH_CAST(meth_wxGrid_DeleteCols), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DeleteCols},
    {sipName_DeleteRows, SIP_MLMETH_CAST(meth_wxGrid_DeleteRows), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DeleteRows},
    {sipName_DeselectCell, SIP_MLMETH_CAST(meth_wxGrid_DeselectCell), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DeselectCell},
    {sipName_DeselectCol, SIP_MLMETH_CAST(meth_wxGrid_DeselectCol), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DeselectCol},
    {sipName_DeselectRow, SIP_MLMETH_CAST(meth_wxGrid_DeselectRow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DeselectRow},
    {sipName_Destroy, meth_wxGrid_Destroy, METH_VARARGS, doc_wxGrid_Destroy},
    {sipName_DevicePosToGridWindow, SIP_MLMETH_CAST(meth_wxGrid_DevicePosToGridWindow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DevicePosToGridWindow},
    {sipName_DisableCellEditControl, meth_wxGrid_DisableCellEditControl, METH_VARARGS, doc_wxGrid_DisableCellEditControl},
    {sipName_DisableColResize, SIP_MLMETH_CAST(meth_wxGrid_DisableColResize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DisableColResize},
    {sipName_DisableDragColMove, meth_wxGrid_DisableDragColMove, METH_VARARGS, doc_wxGrid_DisableDragColMove},
    {sipName_DisableDragColSize, meth_wxGrid_DisableDragColSize, METH_VARARGS, doc_wxGrid_DisableDragColSize},
    {sipName_DisableDragGridSize, meth_wxGrid_DisableDragGridSize, METH_VARARGS, doc_wxGrid_DisableDragGridSize},
    {sipName_DisableDragRowMove, meth_wxGrid_DisableDragRowMove, METH_VARARGS, doc_wxGrid_DisableDragRowMove},
    {sipName_DisableDragRowSize, meth_wxGrid_DisableDragRowSize, METH_VARARGS, doc_wxGrid_DisableDragRowSize},
    {sipName_DisableHidingColumns, meth_wxGrid_DisableHidingColumns, METH_VARARGS, doc_wxGrid_DisableHidingColumns},
    {sipName_DisableRowResize, SIP_MLMETH_CAST(meth_wxGrid_DisableRowResize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DisableRowResize},
    {sipName_DoEnable, SIP_MLMETH_CAST(meth_wxGrid_DoEnable), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoEnable},
    {sipName_DoFreeze, meth_wxGrid_DoFreeze, METH_VARARGS, doc_wxGrid_DoFreeze},
    {sipName_DoGetBestClientSize, meth_wxGrid_DoGetBestClientSize, METH_VARARGS, doc_wxGrid_DoGetBestClientSize},
    {sipName_DoGetBestSize, meth_wxGrid_DoGetBestSize, METH_VARARGS, doc_wxGrid_DoGetBestSize},
    {sipName_DoGetClientSize, SIP_MLMETH_CAST(meth_wxGrid_DoGetClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoGetClientSize},
    {sipName_DoGetPosition, SIP_MLMETH_CAST(meth_wxGrid_DoGetPosition), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoGetPosition},
    {sipName_DoGetSize, SIP_MLMETH_CAST(meth_wxGrid_DoGetSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoGetSize},
    {sipName_DoMoveWindow, SIP_MLMETH_CAST(meth_wxGrid_DoMoveWindow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoMoveWindow},
    {sipName_DoSetClientSize, SIP_MLMETH_CAST(meth_wxGrid_DoSetClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoSetClientSize},
    {sipName_DoSetSize, SIP_MLMETH_CAST(meth_wxGrid_DoSetSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoSetSize},
    {sipName_DoSetSizeHints, SIP_MLMETH_CAST(meth_wxGrid_DoSetSizeHints), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoSetSizeHints},
    {sipName_DoSetWindowVariant, SIP_MLMETH_CAST(meth_wxGrid_DoSetWindowVariant), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DoSetWindowVariant},
    {sipName_DoThaw, meth_wxGrid_DoThaw, METH_VARARGS, doc_wxGrid_DoThaw},
    {sipName_DrawCellHighlight, SIP_MLMETH_CAST(meth_wxGrid_DrawCellHighlight), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DrawCellHighlight},
    {sipName_DrawColLabel, SIP_MLMETH_CAST(meth_wxGrid_DrawColLabel), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DrawColLabel},
    {sipName_DrawColLabels, SIP_MLMETH_CAST(meth_wxGrid_DrawColLabels), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DrawColLabels},
    {sipName_DrawCornerLabel, SIP_MLMETH_CAST(meth_wxGrid_DrawCornerLabel), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DrawCornerLabel},
    {sipName_DrawRowLabel, SIP_MLMETH_CAST(meth_wxGrid_DrawRowLabel), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DrawRowLabel},
    {sipName_DrawRowLabels, SIP_MLMETH_CAST(meth_wxGrid_DrawRowLabels), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DrawRowLabels},
    {sipName_DrawTextRectangle, SIP_MLMETH_CAST(meth_wxGrid_DrawTextRectangle), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_DrawTextRectangle},
    {sipName_EnableCellEditControl, SIP_MLMETH_CAST(meth_wxGrid_EnableCellEditControl), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableCellEditControl},
    {sipName_EnableDragCell, SIP_MLMETH_CAST(meth_wxGrid_EnableDragCell), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableDragCell},
    {sipName_EnableDragColMove, SIP_MLMETH_CAST(meth_wxGrid_EnableDragColMove), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableDragColMove},
    {sipName_EnableDragColSize, SIP_MLMETH_CAST(meth_wxGrid_EnableDragColSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableDragColSize},
    {sipName_EnableDragGridSize, SIP_MLMETH_CAST(meth_wxGrid_EnableDragGridSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableDragGridSize},
    {sipName_EnableDragRowMove, SIP_MLMETH_CAST(meth_wxGrid_EnableDragRowMove), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableDragRowMove},
    {sipName_EnableDragRowSize, SIP_MLMETH_CAST(meth_wxGrid_EnableDragRowSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableDragRowSize},
    {sipName_EnableEditing, SIP_MLMETH_CAST(meth_wxGrid_EnableEditing), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableEditing},
    {sipName_EnableGridLines, SIP_MLMETH_CAST(meth_wxGrid_EnableGridLines), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableGridLines},
    {sipName_EnableHidingColumns, SIP_MLMETH_CAST(meth_wxGrid_EnableHidingColumns), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableHidingColumns},
    {sipName_EnableVisibleFocus, SIP_MLMETH_CAST(meth_wxGrid_EnableVisibleFocus), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_EnableVisibleFocus},
    {sipName_EndBatch, meth_wxGrid_EndBatch, METH_VARARGS, doc_wxGrid_EndBatch},
    {sipName_Fit, meth_wxGrid_Fit, METH_VARARGS, doc_wxGrid_Fit},
    {sipName_ForceRefresh, meth_wxGrid_ForceRefresh, METH_VARARGS, doc_wxGrid_ForceRefresh},
    {sipName_FreezeTo, SIP_MLMETH_CAST(meth_wxGrid_FreezeTo), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_FreezeTo},
    {sipName_GetBatchCount, meth_wxGrid_GetBatchCount, METH_VARARGS, doc_wxGrid_GetBatchCount},
    {sipName_GetCellAlignment, SIP_MLMETH_CAST(meth_wxGrid_GetCellAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellAlignment},
    {sipName_GetCellBackgroundColour, SIP_MLMETH_CAST(meth_wxGrid_GetCellBackgroundColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellBackgroundColour},
    {sipName_GetCellEditor, SIP_MLMETH_CAST(meth_wxGrid_GetCellEditor), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellEditor},
    {sipName_GetCellFitMode, SIP_MLMETH_CAST(meth_wxGrid_GetCellFitMode), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellFitMode},
    {sipName_GetCellFont, SIP_MLMETH_CAST(meth_wxGrid_GetCellFont), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellFont},
    {sipName_GetCellHighlightColour, meth_wxGrid_GetCellHighlightColour, METH_VARARGS, doc_wxGrid_GetCellHighlightColour},
    {sipName_GetCellHighlightPenWidth, meth_wxGrid_GetCellHighlightPenWidth, METH_VARARGS, doc_wxGrid_GetCellHighlightPenWidth},
    {sipName_GetCellHighlightROPenWidth, meth_wxGrid_GetCellHighlightROPenWidth, METH_VARARGS, doc_wxGrid_GetCellHighlightROPenWidth},
    {sipName_GetCellOverflow, SIP_MLMETH_CAST(meth_wxGrid_GetCellOverflow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellOverflow},
    {sipName_GetCellRenderer, SIP_MLMETH_CAST(meth_wxGrid_GetCellRenderer), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellRenderer},
    {sipName_GetCellSize, SIP_MLMETH_CAST(meth_wxGrid_GetCellSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellSize},
    {sipName_GetCellTextColour, SIP_MLMETH_CAST(meth_wxGrid_GetCellTextColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellTextColour},
    {sipName_GetCellValue, SIP_MLMETH_CAST(meth_wxGrid_GetCellValue), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCellValue},
    {sipName_GetClassDefaultAttributes, SIP_MLMETH_CAST(meth_wxGrid_GetClassDefaultAttributes), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetClassDefaultAttributes},
    {sipName_GetClientAreaOrigin, meth_wxGrid_GetClientAreaOrigin, METH_VARARGS, doc_wxGrid_GetClientAreaOrigin},
    {sipName_GetColAt, SIP_MLMETH_CAST(meth_wxGrid_GetColAt), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColAt},
    {sipName_GetColGridLinePen, SIP_MLMETH_CAST(meth_wxGrid_GetColGridLinePen), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColGridLinePen},
    {sipName_GetColLabelAlignment, SIP_MLMETH_CAST(meth_wxGrid_GetColLabelAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColLabelAlignment},
    {sipName_GetColLabelSize, meth_wxGrid_GetColLabelSize, METH_VARARGS, doc_wxGrid_GetColLabelSize},
    {sipName_GetColLabelTextOrientation, meth_wxGrid_GetColLabelTextOrientation, METH_VARARGS, doc_wxGrid_GetColLabelTextOrientation},
    {sipName_GetColLabelValue, SIP_MLMETH_CAST(meth_wxGrid_GetColLabelValue), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColLabelValue},
    {sipName_GetColLeft, SIP_MLMETH_CAST(meth_wxGrid_GetColLeft), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColLeft},
    {sipName_GetColMinimalAcceptableWidth, meth_wxGrid_GetColMinimalAcceptableWidth, METH_VARARGS, doc_wxGrid_GetColMinimalAcceptableWidth},
    {sipName_GetColMinimalWidth, SIP_MLMETH_CAST(meth_wxGrid_GetColMinimalWidth), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColMinimalWidth},
    {sipName_GetColPos, SIP_MLMETH_CAST(meth_wxGrid_GetColPos), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColPos},
    {sipName_GetColRight, SIP_MLMETH_CAST(meth_wxGrid_GetColRight), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColRight},
    {sipName_GetColSize, SIP_MLMETH_CAST(meth_wxGrid_GetColSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetColSize},
    {sipName_GetColSizes, meth_wxGrid_GetColSizes, METH_VARARGS, doc_wxGrid_GetColSizes},
    {sipName_GetCornerLabelAlignment, SIP_MLMETH_CAST(meth_wxGrid_GetCornerLabelAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetCornerLabelAlignment},
    {sipName_GetCornerLabelTextOrientation, meth_wxGrid_GetCornerLabelTextOrientation, METH_VARARGS, doc_wxGrid_GetCornerLabelTextOrientation},
    {sipName_GetCornerLabelValue, meth_wxGrid_GetCornerLabelValue, METH_VARARGS, doc_wxGrid_GetCornerLabelValue},
    {sipName_GetDefaultBorder, meth_wxGrid_GetDefaultBorder, METH_VARARGS, doc_wxGrid_GetDefaultBorder},
    {sipName_GetDefaultBorderForControl, meth_wxGrid_GetDefaultBorderForControl, METH_VARARGS, doc_wxGrid_GetDefaultBorderForControl},
    {sipName_GetDefaultCellAlignment, SIP_MLMETH_CAST(meth_wxGrid_GetDefaultCellAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetDefaultCellAlignment},
    {sipName_GetDefaultCellBackgroundColour, meth_wxGrid_GetDefaultCellBackgroundColour, METH_VARARGS, doc_wxGrid_GetDefaultCellBackgroundColour},
    {sipName_GetDefaultCellFitMode, meth_wxGrid_GetDefaultCellFitMode, METH_VARARGS, doc_wxGrid_GetDefaultCellFitMode},
    {sipName_GetDefaultCellFont, meth_wxGrid_GetDefaultCellFont, METH_VARARGS, doc_wxGrid_GetDefaultCellFont},
    {sipName_GetDefaultCellOverflow, meth_wxGrid_GetDefaultCellOverflow, METH_VARARGS, doc_wxGrid_GetDefaultCellOverflow},
    {sipName_GetDefaultCellTextColour, meth_wxGrid_GetDefaultCellTextColour, METH_VARARGS, doc_wxGrid_GetDefaultCellTextColour},
    {sipName_GetDefaultColLabelSize, meth_wxGrid_GetDefaultColLabelSize, METH_VARARGS, doc_wxGrid_GetDefaultColLabelSize},
    {sipName_GetDefaultColSize, meth_wxGrid_GetDefaultColSize, METH_VARARGS, doc_wxGrid_GetDefaultColSize},
    {sipName_GetDefaultEditor, meth_wxGrid_GetDefaultEditor, METH_VARARGS, doc_wxGrid_GetDefaultEditor},
    {sipName_GetDefaultEditorForCell, SIP_MLMETH_CAST(meth_wxGrid_GetDefaultEditorForCell), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetDefaultEditorForCell},
    {sipName_GetDefaultEditorForType, SIP_MLMETH_CAST(meth_wxGrid_GetDefaultEditorForType), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetDefaultEditorForType},
    {sipName_GetDefaultGridLinePen, meth_wxGrid_GetDefaultGridLinePen, METH_VARARGS, doc_wxGrid_GetDefaultGridLinePen},
    {sipName_GetDefaultRenderer, meth_wxGrid_GetDefaultRenderer, METH_VARARGS, doc_wxGrid_GetDefaultRenderer},
    {sipName_GetDefaultRendererForCell, SIP_MLMETH_CAST(meth_wxGrid_GetDefaultRendererForCell), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetDefaultRendererForCell},
    {sipName_GetDefaultRendererForType, SIP_MLMETH_CAST(meth_wxGrid_GetDefaultRendererForType), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetDefaultRendererForType},
    {sipName_GetDefaultRowLabelSize, meth_wxGrid_GetDefaultRowLabelSize, METH_VARARGS, doc_wxGrid_GetDefaultRowLabelSize},
    {sipName_GetDefaultRowSize, meth_wxGrid_GetDefaultRowSize, METH_VARARGS, doc_wxGrid_GetDefaultRowSize},
    {sipName_GetFirstFullyVisibleColumn, meth_wxGrid_GetFirstFullyVisibleColumn, METH_VARARGS, doc_wxGrid_GetFirstFullyVisibleColumn},
    {sipName_GetFirstFullyVisibleRow, meth_wxGrid_GetFirstFullyVisibleRow, METH_VARARGS, doc_wxGrid_GetFirstFullyVisibleRow},
    {sipName_GetFrozenColGridWindow, meth_wxGrid_GetFrozenColGridWindow, METH_VARARGS, doc_wxGrid_GetFrozenColGridWindow},
    {sipName_GetFrozenCornerGridWindow, meth_wxGrid_GetFrozenCornerGridWindow, METH_VARARGS, doc_wxGrid_GetFrozenCornerGridWindow},
    {sipName_GetFrozenRowGridWindow, meth_wxGrid_GetFrozenRowGridWindow, METH_VARARGS, doc_wxGrid_GetFrozenRowGridWindow},
    {sipName_GetGridColHeader, meth_wxGrid_GetGridColHeader, METH_VARARGS, doc_wxGrid_GetGridColHeader},
    {sipName_GetGridColLabelWindow, meth_wxGrid_GetGridColLabelWindow, METH_VARARGS, doc_wxGrid_GetGridColLabelWindow},
    {sipName_GetGridCornerLabelWindow, meth_wxGrid_GetGridCornerLabelWindow, METH_VARARGS, doc_wxGrid_GetGridCornerLabelWindow},
    {sipName_GetGridCursorCol, meth_wxGrid_GetGridCursorCol, METH_VARARGS, doc_wxGrid_GetGridCursorCol},
    {sipName_GetGridCursorCoords, meth_wxGrid_GetGridCursorCoords, METH_VARARGS, doc_wxGrid_GetGridCursorCoords},
    {sipName_GetGridCursorRow, meth_wxGrid_GetGridCursorRow, METH_VARARGS, doc_wxGrid_GetGridCursorRow},
    {sipName_GetGridLineColour, meth_wxGrid_GetGridLineColour, METH_VARARGS, doc_wxGrid_GetGridLineColour},
    {sipName_GetGridRowLabelWindow, meth_wxGrid_GetGridRowLabelWindow, METH_VARARGS, doc_wxGrid_GetGridRowLabelWindow},
    {sipName_GetGridWindow, meth_wxGrid_GetGridWindow, METH_VARARGS, doc_wxGrid_GetGridWindow},
    {sipName_GetGridWindowOffset, SIP_MLMETH_CAST(meth_wxGrid_GetGridWindowOffset), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetGridWindowOffset},
    {sipName_GetLabelBackgroundColour, meth_wxGrid_GetLabelBackgroundColour, METH_VARARGS, doc_wxGrid_GetLabelBackgroundColour},
    {sipName_GetLabelFont, meth_wxGrid_GetLabelFont, METH_VARARGS, doc_wxGrid_GetLabelFont},
    {sipName_GetLabelTextColour, meth_wxGrid_GetLabelTextColour, METH_VARARGS, doc_wxGrid_GetLabelTextColour},
    {sipName_GetMainWindowOfCompositeControl, meth_wxGrid_GetMainWindowOfCompositeControl, METH_VARARGS, doc_wxGrid_GetMainWindowOfCompositeControl},
    {sipName_GetNumberCols, meth_wxGrid_GetNumberCols, METH_VARARGS, doc_wxGrid_GetNumberCols},
    {sipName_GetNumberFrozenCols, meth_wxGrid_GetNumberFrozenCols, METH_VARARGS, doc_wxGrid_GetNumberFrozenCols},
    {sipName_GetNumberFrozenRows, meth_wxGrid_GetNumberFrozenRows, METH_VARARGS, doc_wxGrid_GetNumberFrozenRows},
    {sipName_GetNumberRows, meth_wxGrid_GetNumberRows, METH_VARARGS, doc_wxGrid_GetNumberRows},
    {sipName_GetOrCreateCellAttr, SIP_MLMETH_CAST(meth_wxGrid_GetOrCreateCellAttr), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetOrCreateCellAttr},
    {sipName_GetOrCreateCellAttrPtr, SIP_MLMETH_CAST(meth_wxGrid_GetOrCreateCellAttrPtr), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetOrCreateCellAttrPtr},
    {sipName_GetRowAt, SIP_MLMETH_CAST(meth_wxGrid_GetRowAt), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetRowAt},
    {sipName_GetRowGridLinePen, SIP_MLMETH_CAST(meth_wxGrid_GetRowGridLinePen), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetRowGridLinePen},
    {sipName_GetRowLabelAlignment, SIP_MLMETH_CAST(meth_wxGrid_GetRowLabelAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetRowLabelAlignment},
    {sipName_GetRowLabelSize, meth_wxGrid_GetRowLabelSize, METH_VARARGS, doc_wxGrid_GetRowLabelSize},
    {sipName_GetRowLabelValue, SIP_MLMETH_CAST(meth_wxGrid_GetRowLabelValue), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetRowLabelValue},
    {sipName_GetRowMinimalAcceptableHeight, meth_wxGrid_GetRowMinimalAcceptableHeight, METH_VARARGS, doc_wxGrid_GetRowMinimalAcceptableHeight},
    {sipName_GetRowMinimalHeight, SIP_MLMETH_CAST(meth_wxGrid_GetRowMinimalHeight), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetRowMinimalHeight},
    {sipName_GetRowPos, SIP_MLMETH_CAST(meth_wxGrid_GetRowPos), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetRowPos},
    {sipName_GetRowSize, SIP_MLMETH_CAST(meth_wxGrid_GetRowSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GetRowSize},
    {sipName_GetRowSizes, meth_wxGrid_GetRowSizes, METH_VARARGS, doc_wxGrid_GetRowSizes},
    {sipName_GetScrollLineX, meth_wxGrid_GetScrollLineX, METH_VARARGS, doc_wxGrid_GetScrollLineX},
    {sipName_GetScrollLineY, meth_wxGrid_GetScrollLineY, METH_VARARGS, doc_wxGrid_GetScrollLineY},
    {sipName_GetSelectedBlocks, meth_wxGrid_GetSelectedBlocks, METH_VARARGS, doc_wxGrid_GetSelectedBlocks},
    {sipName_GetSelectedCells, meth_wxGrid_GetSelectedCells, METH_VARARGS, doc_wxGrid_GetSelectedCells},
    {sipName_GetSelectedColBlocks, meth_wxGrid_GetSelectedColBlocks, METH_VARARGS, doc_wxGrid_GetSelectedColBlocks},
    {sipName_GetSelectedCols, meth_wxGrid_GetSelectedCols, METH_VARARGS, doc_wxGrid_GetSelectedCols},
    {sipName_GetSelectedRowBlocks, meth_wxGrid_GetSelectedRowBlocks, METH_VARARGS, doc_wxGrid_GetSelectedRowBlocks},
    {sipName_GetSelectedRows, meth_wxGrid_GetSelectedRows, METH_VARARGS, doc_wxGrid_GetSelectedRows},
    {sipName_GetSelectionBackground, meth_wxGrid_GetSelectionBackground, METH_VARARGS, doc_wxGrid_GetSelectionBackground},
    {sipName_GetSelectionBlockBottomRight, meth_wxGrid_GetSelectionBlockBottomRight, METH_VARARGS, doc_wxGrid_GetSelectionBlockBottomRight},
    {sipName_GetSelectionBlockTopLeft, meth_wxGrid_GetSelectionBlockTopLeft, METH_VARARGS, doc_wxGrid_GetSelectionBlockTopLeft},
    {sipName_GetSelectionForeground, meth_wxGrid_GetSelectionForeground, METH_VARARGS, doc_wxGrid_GetSelectionForeground},
    {sipName_GetSelectionMode, meth_wxGrid_GetSelectionMode, METH_VARARGS, doc_wxGrid_GetSelectionMode},
    {sipName_GetSizeAvailableForScrollTarget, meth_wxGrid_GetSizeAvailableForScrollTarget, METH_VARARGS, SIP_NULLPTR},
    {sipName_GetSortingColumn, meth_wxGrid_GetSortingColumn, METH_VARARGS, doc_wxGrid_GetSortingColumn},
    {sipName_GetTable, meth_wxGrid_GetTable, METH_VARARGS, doc_wxGrid_GetTable},
    {sipName_GetValidator, meth_wxGrid_GetValidator, METH_VARARGS, doc_wxGrid_GetValidator},
    {sipName_GoToCell, SIP_MLMETH_CAST(meth_wxGrid_GoToCell), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_GoToCell},
    {sipName_GridLinesEnabled, meth_wxGrid_GridLinesEnabled, METH_VARARGS, doc_wxGrid_GridLinesEnabled},
    {sipName_HasTransparentBackground, meth_wxGrid_HasTransparentBackground, METH_VARARGS, doc_wxGrid_HasTransparentBackground},
    {sipName_HideCellEditControl, meth_wxGrid_HideCellEditControl, METH_VARARGS, doc_wxGrid_HideCellEditControl},
    {sipName_HideCol, SIP_MLMETH_CAST(meth_wxGrid_HideCol), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_HideCol},
    {sipName_HideColLabels, meth_wxGrid_HideColLabels, METH_VARARGS, doc_wxGrid_HideColLabels},
    {sipName_HideRow, SIP_MLMETH_CAST(meth_wxGrid_HideRow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_HideRow},
    {sipName_HideRowLabels, meth_wxGrid_HideRowLabels, METH_VARARGS, doc_wxGrid_HideRowLabels},
    {sipName_InformFirstDirection, SIP_MLMETH_CAST(meth_wxGrid_InformFirstDirection), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_InformFirstDirection},
    {sipName_InheritAttributes, meth_wxGrid_InheritAttributes, METH_VARARGS, doc_wxGrid_InheritAttributes},
    {sipName_InitDialog, meth_wxGrid_InitDialog, METH_VARARGS, doc_wxGrid_InitDialog},
    {sipName_InsertCols, SIP_MLMETH_CAST(meth_wxGrid_InsertCols), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_InsertCols},
    {sipName_InsertRows, SIP_MLMETH_CAST(meth_wxGrid_InsertRows), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_InsertRows},
    {sipName_IsCellEditControlEnabled, meth_wxGrid_IsCellEditControlEnabled, METH_VARARGS, doc_wxGrid_IsCellEditControlEnabled},
    {sipName_IsCellEditControlShown, meth_wxGrid_IsCellEditControlShown, METH_VARARGS, doc_wxGrid_IsCellEditControlShown},
    {sipName_IsColShown, SIP_MLMETH_CAST(meth_wxGrid_IsColShown), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_IsColShown},
    {sipName_IsCurrentCellReadOnly, meth_wxGrid_IsCurrentCellReadOnly, METH_VARARGS, doc_wxGrid_IsCurrentCellReadOnly},
    {sipName_IsEditable, meth_wxGrid_IsEditable, METH_VARARGS, doc_wxGrid_IsEditable},
    {sipName_IsInSelection, SIP_MLMETH_CAST(meth_wxGrid_IsInSelection), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_IsInSelection},
    {sipName_IsReadOnly, SIP_MLMETH_CAST(meth_wxGrid_IsReadOnly), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_IsReadOnly},
    {sipName_IsRowShown, SIP_MLMETH_CAST(meth_wxGrid_IsRowShown), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_IsRowShown},
    {sipName_IsSelection, meth_wxGrid_IsSelection, METH_VARARGS, doc_wxGrid_IsSelection},
    {sipName_IsSortOrderAscending, meth_wxGrid_IsSortOrderAscending, METH_VARARGS, doc_wxGrid_IsSortOrderAscending},
    {sipName_IsSortingBy, SIP_MLMETH_CAST(meth_wxGrid_IsSortingBy), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_IsSortingBy},
    {sipName_IsUsingNativeHeader, meth_wxGrid_IsUsingNativeHeader, METH_VARARGS, doc_wxGrid_IsUsingNativeHeader},
    {sipName_IsVisible, SIP_MLMETH_CAST(meth_wxGrid_IsVisible), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_IsVisible},
    {sipName_MakeCellVisible, SIP_MLMETH_CAST(meth_wxGrid_MakeCellVisible), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MakeCellVisible},
    {sipName_MoveCursorDown, SIP_MLMETH_CAST(meth_wxGrid_MoveCursorDown), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MoveCursorDown},
    {sipName_MoveCursorDownBlock, SIP_MLMETH_CAST(meth_wxGrid_MoveCursorDownBlock), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MoveCursorDownBlock},
    {sipName_MoveCursorLeft, SIP_MLMETH_CAST(meth_wxGrid_MoveCursorLeft), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MoveCursorLeft},
    {sipName_MoveCursorLeftBlock, SIP_MLMETH_CAST(meth_wxGrid_MoveCursorLeftBlock), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MoveCursorLeftBlock},
    {sipName_MoveCursorRight, SIP_MLMETH_CAST(meth_wxGrid_MoveCursorRight), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MoveCursorRight},
    {sipName_MoveCursorRightBlock, SIP_MLMETH_CAST(meth_wxGrid_MoveCursorRightBlock), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MoveCursorRightBlock},
    {sipName_MoveCursorUp, SIP_MLMETH_CAST(meth_wxGrid_MoveCursorUp), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MoveCursorUp},
    {sipName_MoveCursorUpBlock, SIP_MLMETH_CAST(meth_wxGrid_MoveCursorUpBlock), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_MoveCursorUpBlock},
    {sipName_MovePageDown, meth_wxGrid_MovePageDown, METH_VARARGS, doc_wxGrid_MovePageDown},
    {sipName_MovePageUp, meth_wxGrid_MovePageUp, METH_VARARGS, doc_wxGrid_MovePageUp},
    {sipName_OnInternalIdle, meth_wxGrid_OnInternalIdle, METH_VARARGS, doc_wxGrid_OnInternalIdle},
    {sipName_ProcessEvent, SIP_MLMETH_CAST(meth_wxGrid_ProcessEvent), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_ProcessEvent},
    {sipName_ProcessTableMessage, SIP_MLMETH_CAST(meth_wxGrid_ProcessTableMessage), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_ProcessTableMessage},
    {sipName_RefreshAttr, SIP_MLMETH_CAST(meth_wxGrid_RefreshAttr), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_RefreshAttr},
    {sipName_RefreshBlock, SIP_MLMETH_CAST(meth_wxGrid_RefreshBlock), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_RefreshBlock},
    {sipName_RegisterDataType, SIP_MLMETH_CAST(meth_wxGrid_RegisterDataType), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_RegisterDataType},
    {sipName_RemoveChild, SIP_MLMETH_CAST(meth_wxGrid_RemoveChild), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_RemoveChild},
    {sipName_Render, SIP_MLMETH_CAST(meth_wxGrid_Render), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_Render},
    {sipName_ResetColPos, meth_wxGrid_ResetColPos, METH_VARARGS, doc_wxGrid_ResetColPos},
    {sipName_ResetRowPos, meth_wxGrid_ResetRowPos, METH_VARARGS, doc_wxGrid_ResetRowPos},
    {sipName_SaveEditControlValue, meth_wxGrid_SaveEditControlValue, METH_VARARGS, doc_wxGrid_SaveEditControlValue},
    {sipName_SelectAll, meth_wxGrid_SelectAll, METH_VARARGS, doc_wxGrid_SelectAll},
    {sipName_SelectBlock, SIP_MLMETH_CAST(meth_wxGrid_SelectBlock), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SelectBlock},
    {sipName_SelectCol, SIP_MLMETH_CAST(meth_wxGrid_SelectCol), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SelectCol},
    {sipName_SelectRow, SIP_MLMETH_CAST(meth_wxGrid_SelectRow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SelectRow},
    {sipName_SendDestroyEvent, meth_wxGrid_SendDestroyEvent, METH_VARARGS, SIP_NULLPTR},
    {sipName_SetAttr, SIP_MLMETH_CAST(meth_wxGrid_SetAttr), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetAttr},
    {sipName_SetCanFocus, SIP_MLMETH_CAST(meth_wxGrid_SetCanFocus), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCanFocus},
    {sipName_SetCellAlignment, SIP_MLMETH_CAST(meth_wxGrid_SetCellAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellAlignment},
    {sipName_SetCellBackgroundColour, SIP_MLMETH_CAST(meth_wxGrid_SetCellBackgroundColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellBackgroundColour},
    {sipName_SetCellEditor, SIP_MLMETH_CAST(meth_wxGrid_SetCellEditor), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellEditor},
    {sipName_SetCellFitMode, SIP_MLMETH_CAST(meth_wxGrid_SetCellFitMode), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellFitMode},
    {sipName_SetCellFont, SIP_MLMETH_CAST(meth_wxGrid_SetCellFont), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellFont},
    {sipName_SetCellHighlightColour, meth_wxGrid_SetCellHighlightColour, METH_VARARGS, doc_wxGrid_SetCellHighlightColour},
    {sipName_SetCellHighlightPenWidth, SIP_MLMETH_CAST(meth_wxGrid_SetCellHighlightPenWidth), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellHighlightPenWidth},
    {sipName_SetCellHighlightROPenWidth, SIP_MLMETH_CAST(meth_wxGrid_SetCellHighlightROPenWidth), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellHighlightROPenWidth},
    {sipName_SetCellOverflow, SIP_MLMETH_CAST(meth_wxGrid_SetCellOverflow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellOverflow},
    {sipName_SetCellRenderer, SIP_MLMETH_CAST(meth_wxGrid_SetCellRenderer), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellRenderer},
    {sipName_SetCellSize, SIP_MLMETH_CAST(meth_wxGrid_SetCellSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellSize},
    {sipName_SetCellTextColour, SIP_MLMETH_CAST(meth_wxGrid_SetCellTextColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellTextColour},
    {sipName_SetCellValue, SIP_MLMETH_CAST(meth_wxGrid_SetCellValue), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCellValue},
    {sipName_SetColAttr, SIP_MLMETH_CAST(meth_wxGrid_SetColAttr), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColAttr},
    {sipName_SetColFormatBool, SIP_MLMETH_CAST(meth_wxGrid_SetColFormatBool), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColFormatBool},
    {sipName_SetColFormatCustom, SIP_MLMETH_CAST(meth_wxGrid_SetColFormatCustom), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColFormatCustom},
    {sipName_SetColFormatDate, SIP_MLMETH_CAST(meth_wxGrid_SetColFormatDate), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColFormatDate},
    {sipName_SetColFormatFloat, SIP_MLMETH_CAST(meth_wxGrid_SetColFormatFloat), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColFormatFloat},
    {sipName_SetColFormatNumber, SIP_MLMETH_CAST(meth_wxGrid_SetColFormatNumber), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColFormatNumber},
    {sipName_SetColLabelAlignment, SIP_MLMETH_CAST(meth_wxGrid_SetColLabelAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColLabelAlignment},
    {sipName_SetColLabelSize, SIP_MLMETH_CAST(meth_wxGrid_SetColLabelSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColLabelSize},
    {sipName_SetColLabelTextOrientation, SIP_MLMETH_CAST(meth_wxGrid_SetColLabelTextOrientation), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColLabelTextOrientation},
    {sipName_SetColLabelValue, SIP_MLMETH_CAST(meth_wxGrid_SetColLabelValue), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColLabelValue},
    {sipName_SetColMinimalAcceptableWidth, SIP_MLMETH_CAST(meth_wxGrid_SetColMinimalAcceptableWidth), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColMinimalAcceptableWidth},
    {sipName_SetColMinimalWidth, SIP_MLMETH_CAST(meth_wxGrid_SetColMinimalWidth), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColMinimalWidth},
    {sipName_SetColPos, SIP_MLMETH_CAST(meth_wxGrid_SetColPos), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColPos},
    {sipName_SetColSize, SIP_MLMETH_CAST(meth_wxGrid_SetColSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColSize},
    {sipName_SetColSizes, SIP_MLMETH_CAST(meth_wxGrid_SetColSizes), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColSizes},
    {sipName_SetColumnsOrder, SIP_MLMETH_CAST(meth_wxGrid_SetColumnsOrder), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetColumnsOrder},
    {sipName_SetCornerLabelAlignment, SIP_MLMETH_CAST(meth_wxGrid_SetCornerLabelAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCornerLabelAlignment},
    {sipName_SetCornerLabelTextOrientation, SIP_MLMETH_CAST(meth_wxGrid_SetCornerLabelTextOrientation), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetCornerLabelTextOrientation},
    {sipName_SetCornerLabelValue, meth_wxGrid_SetCornerLabelValue, METH_VARARGS, doc_wxGrid_SetCornerLabelValue},
    {sipName_SetDefaultCellAlignment, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultCellAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultCellAlignment},
    {sipName_SetDefaultCellBackgroundColour, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultCellBackgroundColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultCellBackgroundColour},
    {sipName_SetDefaultCellFitMode, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultCellFitMode), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultCellFitMode},
    {sipName_SetDefaultCellFont, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultCellFont), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultCellFont},
    {sipName_SetDefaultCellOverflow, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultCellOverflow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultCellOverflow},
    {sipName_SetDefaultCellTextColour, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultCellTextColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultCellTextColour},
    {sipName_SetDefaultColSize, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultColSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultColSize},
    {sipName_SetDefaultEditor, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultEditor), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultEditor},
    {sipName_SetDefaultRenderer, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultRenderer), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultRenderer},
    {sipName_SetDefaultRowSize, SIP_MLMETH_CAST(meth_wxGrid_SetDefaultRowSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetDefaultRowSize},
    {sipName_SetGridCursor, SIP_MLMETH_CAST(meth_wxGrid_SetGridCursor), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetGridCursor},
    {sipName_SetGridFrozenBorderColour, meth_wxGrid_SetGridFrozenBorderColour, METH_VARARGS, doc_wxGrid_SetGridFrozenBorderColour},
    {sipName_SetGridFrozenBorderPenWidth, SIP_MLMETH_CAST(meth_wxGrid_SetGridFrozenBorderPenWidth), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetGridFrozenBorderPenWidth},
    {sipName_SetGridLineColour, SIP_MLMETH_CAST(meth_wxGrid_SetGridLineColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetGridLineColour},
    {sipName_SetLabelBackgroundColour, SIP_MLMETH_CAST(meth_wxGrid_SetLabelBackgroundColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetLabelBackgroundColour},
    {sipName_SetLabelFont, SIP_MLMETH_CAST(meth_wxGrid_SetLabelFont), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetLabelFont},
    {sipName_SetLabelTextColour, SIP_MLMETH_CAST(meth_wxGrid_SetLabelTextColour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetLabelTextColour},
    {sipName_SetMargins, SIP_MLMETH_CAST(meth_wxGrid_SetMargins), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetMargins},
    {sipName_SetReadOnly, SIP_MLMETH_CAST(meth_wxGrid_SetReadOnly), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetReadOnly},
    {sipName_SetRowAttr, SIP_MLMETH_CAST(meth_wxGrid_SetRowAttr), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowAttr},
    {sipName_SetRowLabelAlignment, SIP_MLMETH_CAST(meth_wxGrid_SetRowLabelAlignment), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowLabelAlignment},
    {sipName_SetRowLabelSize, SIP_MLMETH_CAST(meth_wxGrid_SetRowLabelSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowLabelSize},
    {sipName_SetRowLabelValue, SIP_MLMETH_CAST(meth_wxGrid_SetRowLabelValue), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowLabelValue},
    {sipName_SetRowMinimalAcceptableHeight, SIP_MLMETH_CAST(meth_wxGrid_SetRowMinimalAcceptableHeight), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowMinimalAcceptableHeight},
    {sipName_SetRowMinimalHeight, SIP_MLMETH_CAST(meth_wxGrid_SetRowMinimalHeight), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowMinimalHeight},
    {sipName_SetRowPos, SIP_MLMETH_CAST(meth_wxGrid_SetRowPos), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowPos},
    {sipName_SetRowSize, SIP_MLMETH_CAST(meth_wxGrid_SetRowSize), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowSize},
    {sipName_SetRowSizes, SIP_MLMETH_CAST(meth_wxGrid_SetRowSizes), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowSizes},
    {sipName_SetRowsOrder, SIP_MLMETH_CAST(meth_wxGrid_SetRowsOrder), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetRowsOrder},
    {sipName_SetScrollLineX, SIP_MLMETH_CAST(meth_wxGrid_SetScrollLineX), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetScrollLineX},
    {sipName_SetScrollLineY, SIP_MLMETH_CAST(meth_wxGrid_SetScrollLineY), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetScrollLineY},
    {sipName_SetSelectionBackground, SIP_MLMETH_CAST(meth_wxGrid_SetSelectionBackground), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetSelectionBackground},
    {sipName_SetSelectionForeground, SIP_MLMETH_CAST(meth_wxGrid_SetSelectionForeground), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetSelectionForeground},
    {sipName_SetSelectionMode, SIP_MLMETH_CAST(meth_wxGrid_SetSelectionMode), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetSelectionMode},
    {sipName_SetSortingColumn, SIP_MLMETH_CAST(meth_wxGrid_SetSortingColumn), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetSortingColumn},
    {sipName_SetTabBehaviour, SIP_MLMETH_CAST(meth_wxGrid_SetTabBehaviour), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetTabBehaviour},
    {sipName_SetUseNativeColLabels, SIP_MLMETH_CAST(meth_wxGrid_SetUseNativeColLabels), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetUseNativeColLabels},
    {sipName_SetValidator, SIP_MLMETH_CAST(meth_wxGrid_SetValidator), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_SetValidator},
    {sipName_ShouldInheritColours, meth_wxGrid_ShouldInheritColours, METH_VARARGS, doc_wxGrid_ShouldInheritColours},
    {sipName_ShouldScrollToChildOnFocus, SIP_MLMETH_CAST(meth_wxGrid_ShouldScrollToChildOnFocus), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_ShowCellEditControl, meth_wxGrid_ShowCellEditControl, METH_VARARGS, doc_wxGrid_ShowCellEditControl},
    {sipName_ShowCol, SIP_MLMETH_CAST(meth_wxGrid_ShowCol), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_ShowCol},
    {sipName_ShowRow, SIP_MLMETH_CAST(meth_wxGrid_ShowRow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_ShowRow},
    {sipName_TransferDataFromWindow, meth_wxGrid_TransferDataFromWindow, METH_VARARGS, doc_wxGrid_TransferDataFromWindow},
    {sipName_TransferDataToWindow, meth_wxGrid_TransferDataToWindow, METH_VARARGS, doc_wxGrid_TransferDataToWindow},
    {sipName_TryAfter, SIP_MLMETH_CAST(meth_wxGrid_TryAfter), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_TryAfter},
    {sipName_TryBefore, SIP_MLMETH_CAST(meth_wxGrid_TryBefore), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_TryBefore},
    {sipName_UnsetSortingColumn, meth_wxGrid_UnsetSortingColumn, METH_VARARGS, doc_wxGrid_UnsetSortingColumn},
    {sipName_UseNativeColHeader, SIP_MLMETH_CAST(meth_wxGrid_UseNativeColHeader), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_UseNativeColHeader},
    {sipName_Validate, meth_wxGrid_Validate, METH_VARARGS, doc_wxGrid_Validate},
    {sipName_XToCol, SIP_MLMETH_CAST(meth_wxGrid_XToCol), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_XToCol},
    {sipName_XToEdgeOfCol, SIP_MLMETH_CAST(meth_wxGrid_XToEdgeOfCol), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_XToEdgeOfCol},
    {sipName_XYToCell, SIP_MLMETH_CAST(meth_wxGrid_XYToCell), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_XYToCell},
    {sipName_YToEdgeOfRow, SIP_MLMETH_CAST(meth_wxGrid_YToEdgeOfRow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_YToEdgeOfRow},
    {sipName_YToRow, SIP_MLMETH_CAST(meth_wxGrid_YToRow), METH_VARARGS|METH_KEYWORDS, doc_wxGrid_YToRow},
    {sipName__SetTable, SIP_MLMETH_CAST(meth_wxGrid__SetTable), METH_VARARGS|METH_KEYWORDS, doc_wxGrid__SetTable}
};

static sipEnumMemberDef enummembers_wxGrid[] = {
    {sipName_CellSpan_Inside, static_cast<int>( ::wxGrid::CellSpan_Inside), 1},
    {sipName_CellSpan_Main, static_cast<int>( ::wxGrid::CellSpan_Main), 1},
    {sipName_CellSpan_None, static_cast<int>( ::wxGrid::CellSpan_None), 1},
    {sipName_GridSelectCells, static_cast<int>( ::wxGrid::wxGridSelectCells), 3},
    {sipName_GridSelectColumns, static_cast<int>( ::wxGrid::wxGridSelectColumns), 3},
    {sipName_GridSelectNone, static_cast<int>( ::wxGrid::wxGridSelectNone), 3},
    {sipName_GridSelectRows, static_cast<int>( ::wxGrid::wxGridSelectRows), 3},
    {sipName_GridSelectRowsOrColumns, static_cast<int>( ::wxGrid::wxGridSelectRowsOrColumns), 3},
    {sipName_Tab_Leave, static_cast<int>( ::wxGrid::Tab_Leave), 2},
    {sipName_Tab_Stop, static_cast<int>( ::wxGrid::Tab_Stop), 2},
    {sipName_Tab_Wrap, static_cast<int>( ::wxGrid::Tab_Wrap), 2},
};

sipVariableDef variables_wxGrid[] = {
    {PropertyVariable, sipName_SortingColumn, &methods_wxGrid[193], &methods_wxGrid[317], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionMode, &methods_wxGrid[191], &methods_wxGrid[316], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionForeground, &methods_wxGrid[190], &methods_wxGrid[315], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionBlockTopLeft, &methods_wxGrid[189], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionBlockBottomRight, &methods_wxGrid[188], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionBackground, &methods_wxGrid[187], &methods_wxGrid[314], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectedRows, &methods_wxGrid[186], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectedRowBlocks, &methods_wxGrid[185], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectedCols, &methods_wxGrid[184], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectedColBlocks, &methods_wxGrid[183], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectedCells, &methods_wxGrid[182], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectedBlocks, &methods_wxGrid[181], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ScrollLineY, &methods_wxGrid[180], &methods_wxGrid[313], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ScrollLineX, &methods_wxGrid[179], &methods_wxGrid[312], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RowSizes, &methods_wxGrid[178], &methods_wxGrid[310], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RowMinimalAcceptableHeight, &methods_wxGrid[174], &methods_wxGrid[306], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RowLabelSize, &methods_wxGrid[172], &methods_wxGrid[304], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_NumberRows, &methods_wxGrid[166], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_NumberFrozenRows, &methods_wxGrid[165], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_NumberFrozenCols, &methods_wxGrid[164], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_NumberCols, &methods_wxGrid[163], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LabelTextColour, &methods_wxGrid[161], &methods_wxGrid[299], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LabelFont, &methods_wxGrid[160], &methods_wxGrid[298], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LabelBackgroundColour, &methods_wxGrid[159], &methods_wxGrid[297], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridWindow, &methods_wxGrid[157], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridRowLabelWindow, &methods_wxGrid[156], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridLineColour, &methods_wxGrid[155], &methods_wxGrid[296], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridCursorRow, &methods_wxGrid[154], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridCursorCoords, &methods_wxGrid[153], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridCursorCol, &methods_wxGrid[152], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridCornerLabelWindow, &methods_wxGrid[151], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridColLabelWindow, &methods_wxGrid[150], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GridColHeader, &methods_wxGrid[149], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FrozenRowGridWindow, &methods_wxGrid[148], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FrozenCornerGridWindow, &methods_wxGrid[147], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FrozenColGridWindow, &methods_wxGrid[146], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FirstFullyVisibleRow, &methods_wxGrid[145], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FirstFullyVisibleColumn, &methods_wxGrid[144], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultRowSize, &methods_wxGrid[143], &methods_wxGrid[292], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultRowLabelSize, &methods_wxGrid[142], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultRenderer, &methods_wxGrid[139], &methods_wxGrid[291], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultGridLinePen, &methods_wxGrid[138], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultEditor, &methods_wxGrid[135], &methods_wxGrid[290], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultColSize, &methods_wxGrid[134], &methods_wxGrid[289], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultColLabelSize, &methods_wxGrid[133], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultCellTextColour, &methods_wxGrid[132], &methods_wxGrid[288], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultCellOverflow, &methods_wxGrid[131], &methods_wxGrid[287], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultCellFont, &methods_wxGrid[130], &methods_wxGrid[286], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultCellFitMode, &methods_wxGrid[129], &methods_wxGrid[285], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultCellBackgroundColour, &methods_wxGrid[128], &methods_wxGrid[284], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CornerLabelValue, &methods_wxGrid[124], &methods_wxGrid[282], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CornerLabelTextOrientation, &methods_wxGrid[123], &methods_wxGrid[281], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ColSizes, &methods_wxGrid[121], &methods_wxGrid[278], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ColMinimalAcceptableWidth, &methods_wxGrid[116], &methods_wxGrid[274], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ColLabelTextOrientation, &methods_wxGrid[113], &methods_wxGrid[272], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ColLabelSize, &methods_wxGrid[112], &methods_wxGrid[271], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CellHighlightROPenWidth, &methods_wxGrid[101], &methods_wxGrid[258], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CellHighlightPenWidth, &methods_wxGrid[100], &methods_wxGrid[257], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CellHighlightColour, &methods_wxGrid[99], &methods_wxGrid[256], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_BatchCount, &methods_wxGrid[93], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxGrid, "Grid()\n"
"Grid(parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.WANTS_CHARS, name=GridNameStr)\n"
"\n"
"wxGrid and its related classes are used for displaying and editing\n"
"tabular data.");


sipClassTypeDef sipTypeDef__grid_wxGrid = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxGrid,
        SIP_NULLPTR,
        SIP_NULLPTR
    },
    {
        sipNameNr_Grid,
        {0, 0, 1},
        339, methods_wxGrid,
        11, enummembers_wxGrid,
        60, variables_wxGrid,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxGrid,
    -1,
    -1,
    supers_wxGrid,
    SIP_NULLPTR,
    init_type_wxGrid,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    dealloc_wxGrid,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_wxGrid,
    cast_wxGrid,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
};
