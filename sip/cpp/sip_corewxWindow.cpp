/*
 * Interface wrapper code.
 *
 * Generated by SIP 6.7.9
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"
        #include <wx/window.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/event.h>
        #include <wx/window.h>
        #include <wx/event.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/event.h>
        #include <wx/cursor.h>
        #include <wx/caret.h>
        #include <wx/layout.h>
        #include <wx/sizer.h>
        #include <wx/dnd.h>
        #include <wx/access.h>
        #include <wx/accel.h>
        #include <wx/validate.h>
        #include <wx/menu.h>
        #include <wx/tooltip.h>
        #include <wx/event.h>
        #include <wx/gdicmn.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/palette.h>
        #include <wx/colour.h>
        #include <wx/font.h>
        #include <wx/region.h>
        #include <wx/eventfilter.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>
        
        #ifdef __WXMSW__
        #include <wx/msw/private.h>
        #endif
        
        #ifdef __WXGTK__
        #include <gdk/gdkx.h>
        #include <gtk/gtk.h>
        #ifdef __WXGTK3__
        // Unlike GDK_WINDOW_XWINDOW, GDK_WINDOW_XID can't handle a NULL, so check 1st
        static XID GetXWindow(const wxWindow* wxwin) {
            if ((wxwin)->m_wxwindow) {
                if (gtk_widget_get_window((wxwin)->m_wxwindow))
                    return GDK_WINDOW_XID(gtk_widget_get_window((wxwin)->m_wxwindow));
                return 0;
            }
            else {
                if (gtk_widget_get_window((wxwin)->m_widget))
                    return GDK_WINDOW_XID(gtk_widget_get_window((wxwin)->m_widget));
                return 0;
            }
        }
        #else
        #define GetXWindow(wxwin) (wxwin)->m_wxwindow ? \
                                  GDK_WINDOW_XWINDOW((wxwin)->m_wxwindow->window) : \
                                  GDK_WINDOW_XWINDOW((wxwin)->m_widget->window)
        #endif
        #endif
        
        
        
        
        
        wxUIntPtr wxPyGetWinHandle(const wxWindow* win)
        {
        #ifdef __WXMSW__
            return (wxUIntPtr)win->GetHandle();
        #endif
        #if defined(__WXGTK__) || defined(__WXX11__)
            return (wxUIntPtr)GetXWindow(win);
        #endif
        #ifdef __WXMAC__
            return (wxUIntPtr)win->GetHandle();
        #endif
            return 0;
        }
    wxAccessible * _wxWindow_GetAccessible(wxWindow* self)
    {
        #if wxUSE_ACCESSIBILITY
            return self->GetAccessible();
        #else
            wxPyRaiseNotImplemented();
            return NULL;
        #endif
    }
    void _wxWindow_SetAccessible(wxWindow* self, wxAccessible *accessible)
    {
        #if wxUSE_ACCESSIBILITY
            self->SetAccessible(accessible);
        #else
            wxPyRaiseNotImplemented();
        #endif
    }
    wxUIntPtr* _wxWindow_GetHandle(const wxWindow* self)
    {
        return new wxUIntPtr(wxPyGetWinHandle(self));
    }
    void _wxWindow_SetDoubleBuffered(wxWindow* self, bool on)
    {
        #if defined(__WXGTK20__) || defined(__WXGTK3__) || defined(__WXMSW__)
            self->SetDoubleBuffered(on);
        #endif
    }
    bool _wxWindow_RegisterHotKey(wxWindow* self, int hotkeyId, int modifiers, int virtualKeyCode)
    {
        #if wxUSE_HOTKEY
            return self->RegisterHotKey(hotkeyId, modifiers, virtualKeyCode);
        #else
            return false;
        #endif
    }
    bool _wxWindow_UnregisterHotKey(wxWindow* self, int hotkeyId)
    {
        #if wxUSE_HOTKEY
            return self->UnregisterHotKey(hotkeyId);
        #else
            return false;
        #endif
    }
    void* _wxWindow_GetGtkWidget(wxWindow* self)
    {
        #ifdef __WXGTK__
            return (void*)self->GetHandle();
        #else
            return NULL;
        #endif
    }
    void _wxWindow_AssociateHandle(wxWindow* self, long handle)
    {
        self->AssociateHandle((WXWidget)handle);
    }
    void _wxWindow_DissociateHandle(wxWindow* self)
    {
        self->DissociateHandle();
    }
    wxWindow* _wxWindow_GetTopLevelParent(wxWindow* self)
    {
        return wxGetTopLevelParent(self);
    }
    bool _wxWindow_MacIsWindowScrollbar(wxWindow* self, const wxWindow* sb)
    {
        #ifdef __WXMAC__
            return self->MacIsWindowScrollbar(sb);
        #else
            return false;
        #endif
    }
    void _wxWindow_SetDimensions(wxWindow* self, int x, int y, int width, int height, int sizeFlags)
    {
        self->SetSize(x, y, width, height, sizeFlags);
    }


class sipwxWindow : public  ::wxWindow
{
public:
    sipwxWindow();
    sipwxWindow( ::wxWindow*, ::wxWindowID,const  ::wxPoint&,const  ::wxSize&,long,const  ::wxString&);
    virtual ~sipwxWindow();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    void sipProtectVirt_DoEnable(bool,bool);
    void sipProtectVirt_DoGetPosition(bool,int*,int*) const;
    void sipProtectVirt_DoGetSize(bool,int*,int*) const;
    void sipProtectVirt_DoGetClientSize(bool,int*,int*) const;
    void sipProtectVirt_DoSetSize(bool,int,int,int,int,int);
    void sipProtectVirt_DoSetClientSize(bool,int,int);
    void sipProtectVirt_DoSetSizeHints(bool,int,int,int,int,int,int);
    void sipProtectVirt_DoMoveWindow(bool,int,int,int,int);
    void sipProtectVirt_DoSetWindowVariant(bool, ::wxWindowVariant);
     ::wxBorder sipProtectVirt_GetDefaultBorder(bool) const;
     ::wxBorder sipProtectVirt_GetDefaultBorderForControl(bool) const;
    void sipProtectVirt_DoFreeze(bool);
    void sipProtectVirt_DoThaw(bool);
    bool sipProtectVirt_TryBefore(bool, ::wxEvent&);
    bool sipProtectVirt_TryAfter(bool, ::wxEvent&);
     ::wxSize sipProtectVirt_DoGetBestSize(bool) const;
     ::wxSize sipProtectVirt_DoGetBestClientSize(bool) const;
    void sipProtect_SendDestroyEvent();
    bool sipProtectVirt_ProcessEvent(bool, ::wxEvent&);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::wxSize DoGetBestClientSize() const SIP_OVERRIDE;
     ::wxSize DoGetBestSize() const SIP_OVERRIDE;
    void DoThaw() SIP_OVERRIDE;
    void DoFreeze() SIP_OVERRIDE;
     ::wxBorder GetDefaultBorderForControl() const SIP_OVERRIDE;
     ::wxBorder GetDefaultBorder() const SIP_OVERRIDE;
    void DoSetWindowVariant( ::wxWindowVariant) SIP_OVERRIDE;
    void DoMoveWindow(int,int,int,int) SIP_OVERRIDE;
    void DoSetSizeHints(int,int,int,int,int,int) SIP_OVERRIDE;
    void DoSetClientSize(int,int) SIP_OVERRIDE;
    void DoSetSize(int,int,int,int,int) SIP_OVERRIDE;
    void DoGetClientSize(int*,int*) const SIP_OVERRIDE;
    void DoGetSize(int*,int*) const SIP_OVERRIDE;
    void DoGetPosition(int*,int*) const SIP_OVERRIDE;
    void DoEnable(bool) SIP_OVERRIDE;
     ::wxWindow* GetMainWindowOfCompositeControl() SIP_OVERRIDE;
    void OnInternalIdle() SIP_OVERRIDE;
    void InitDialog() SIP_OVERRIDE;
    void InheritAttributes() SIP_OVERRIDE;
    bool Destroy() SIP_OVERRIDE;
    bool Validate() SIP_OVERRIDE;
    bool TransferDataToWindow() SIP_OVERRIDE;
    bool TransferDataFromWindow() SIP_OVERRIDE;
    void SetValidator(const  ::wxValidator&) SIP_OVERRIDE;
     ::wxValidator* GetValidator() SIP_OVERRIDE;
    bool ShouldInheritColours() const SIP_OVERRIDE;
    bool HasTransparentBackground() SIP_OVERRIDE;
     ::wxPoint GetClientAreaOrigin() const SIP_OVERRIDE;
    bool InformFirstDirection(int,int,int) SIP_OVERRIDE;
    void EnableVisibleFocus(bool) SIP_OVERRIDE;
    void SetCanFocus(bool) SIP_OVERRIDE;
    bool AcceptsFocusRecursively() const SIP_OVERRIDE;
    bool AcceptsFocusFromKeyboard() const SIP_OVERRIDE;
    bool AcceptsFocus() const SIP_OVERRIDE;
    bool TryAfter( ::wxEvent&) SIP_OVERRIDE;
    bool TryBefore( ::wxEvent&) SIP_OVERRIDE;
    bool ProcessEvent( ::wxEvent&) SIP_OVERRIDE;
    void AddChild( ::wxWindowBase*) SIP_OVERRIDE;
    void RemoveChild( ::wxWindowBase*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxWindow(const sipwxWindow &);
    sipwxWindow &operator = (const sipwxWindow &);

    char sipPyMethods[39];
};

sipwxWindow::sipwxWindow():  ::wxWindow(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxWindow::sipwxWindow( ::wxWindow*parent, ::wxWindowID id,const  ::wxPoint& pos,const  ::wxSize& size,long style,const  ::wxString& name):  ::wxWindow(parent,id,pos,size,style,name), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxWindow::~sipwxWindow()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

 ::wxSize sipwxWindow::DoGetBestClientSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[0]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetBestClientSize);

    if (!sipMeth)
        return  ::wxWindow::DoGetBestClientSize();

    extern  ::wxSize sipVH__core_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_25(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxSize sipwxWindow::DoGetBestSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[1]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetBestSize);

    if (!sipMeth)
        return  ::wxWindow::DoGetBestSize();

    extern  ::wxSize sipVH__core_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_25(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxWindow::DoThaw()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[2], &sipPySelf, SIP_NULLPTR, sipName_DoThaw);

    if (!sipMeth)
    {
         ::wxWindow::DoThaw();
        return;
    }

    extern void sipVH__core_57(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_57(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxWindow::DoFreeze()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[3], &sipPySelf, SIP_NULLPTR, sipName_DoFreeze);

    if (!sipMeth)
    {
         ::wxWindow::DoFreeze();
        return;
    }

    extern void sipVH__core_57(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_57(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxWindow::GetDefaultBorderForControl() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[4]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetDefaultBorderForControl);

    if (!sipMeth)
        return  ::wxWindow::GetDefaultBorderForControl();

    extern  ::wxBorder sipVH__core_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_136(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxWindow::GetDefaultBorder() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[5]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetDefaultBorder);

    if (!sipMeth)
        return  ::wxWindow::GetDefaultBorder();

    extern  ::wxBorder sipVH__core_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_136(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxWindow::DoSetWindowVariant( ::wxWindowVariant variant)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[6], &sipPySelf, SIP_NULLPTR, sipName_DoSetWindowVariant);

    if (!sipMeth)
    {
         ::wxWindow::DoSetWindowVariant(variant);
        return;
    }

    extern void sipVH__core_135(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowVariant);

    sipVH__core_135(sipGILState, 0, sipPySelf, sipMeth, variant);
}

void sipwxWindow::DoMoveWindow(int x,int y,int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[7], &sipPySelf, SIP_NULLPTR, sipName_DoMoveWindow);

    if (!sipMeth)
    {
         ::wxWindow::DoMoveWindow(x,y,width,height);
        return;
    }

    extern void sipVH__core_134(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int);

    sipVH__core_134(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height);
}

void sipwxWindow::DoSetSizeHints(int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[8], &sipPySelf, SIP_NULLPTR, sipName_DoSetSizeHints);

    if (!sipMeth)
    {
         ::wxWindow::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int,int);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, minW, minH, maxW, maxH, incW, incH);
}

void sipwxWindow::DoSetClientSize(int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[9], &sipPySelf, SIP_NULLPTR, sipName_DoSetClientSize);

    if (!sipMeth)
    {
         ::wxWindow::DoSetClientSize(width,height);
        return;
    }

    extern void sipVH__core_132(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int);

    sipVH__core_132(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxWindow::DoSetSize(int x,int y,int width,int height,int sizeFlags)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[10], &sipPySelf, SIP_NULLPTR, sipName_DoSetSize);

    if (!sipMeth)
    {
         ::wxWindow::DoSetSize(x,y,width,height,sizeFlags);
        return;
    }

    extern void sipVH__core_131(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int);

    sipVH__core_131(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height, sizeFlags);
}

void sipwxWindow::DoGetClientSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[11]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetClientSize);

    if (!sipMeth)
    {
         ::wxWindow::DoGetClientSize(width,height);
        return;
    }

    extern void sipVH__core_130(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__core_130(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxWindow::DoGetSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[12]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetSize);

    if (!sipMeth)
    {
         ::wxWindow::DoGetSize(width,height);
        return;
    }

    extern void sipVH__core_130(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__core_130(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxWindow::DoGetPosition(int*x,int*y) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[13]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetPosition);

    if (!sipMeth)
    {
         ::wxWindow::DoGetPosition(x,y);
        return;
    }

    extern void sipVH__core_130(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__core_130(sipGILState, 0, sipPySelf, sipMeth, x, y);
}

void sipwxWindow::DoEnable(bool enable)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[14], &sipPySelf, SIP_NULLPTR, sipName_DoEnable);

    if (!sipMeth)
    {
         ::wxWindow::DoEnable(enable);
        return;
    }

    extern void sipVH__core_96(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__core_96(sipGILState, 0, sipPySelf, sipMeth, enable);
}

 ::wxWindow* sipwxWindow::GetMainWindowOfCompositeControl()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[15], &sipPySelf, SIP_NULLPTR, sipName_GetMainWindowOfCompositeControl);

    if (!sipMeth)
        return  ::wxWindow::GetMainWindowOfCompositeControl();

    extern  ::wxWindow* sipVH__core_129(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_129(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxWindow::OnInternalIdle()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[16], &sipPySelf, SIP_NULLPTR, sipName_OnInternalIdle);

    if (!sipMeth)
    {
         ::wxWindow::OnInternalIdle();
        return;
    }

    extern void sipVH__core_57(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_57(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxWindow::InitDialog()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[17], &sipPySelf, SIP_NULLPTR, sipName_InitDialog);

    if (!sipMeth)
    {
         ::wxWindow::InitDialog();
        return;
    }

    extern void sipVH__core_57(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_57(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxWindow::InheritAttributes()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[18], &sipPySelf, SIP_NULLPTR, sipName_InheritAttributes);

    if (!sipMeth)
    {
         ::wxWindow::InheritAttributes();
        return;
    }

    extern void sipVH__core_57(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_57(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::Destroy()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[19], &sipPySelf, SIP_NULLPTR, sipName_Destroy);

    if (!sipMeth)
        return  ::wxWindow::Destroy();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::Validate()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[20], &sipPySelf, SIP_NULLPTR, sipName_Validate);

    if (!sipMeth)
        return  ::wxWindow::Validate();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::TransferDataToWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[21], &sipPySelf, SIP_NULLPTR, sipName_TransferDataToWindow);

    if (!sipMeth)
        return  ::wxWindow::TransferDataToWindow();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::TransferDataFromWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[22], &sipPySelf, SIP_NULLPTR, sipName_TransferDataFromWindow);

    if (!sipMeth)
        return  ::wxWindow::TransferDataFromWindow();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxWindow::SetValidator(const  ::wxValidator& validator)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[23], &sipPySelf, SIP_NULLPTR, sipName_SetValidator);

    if (!sipMeth)
    {
         ::wxWindow::SetValidator(validator);
        return;
    }

    extern void sipVH__core_128(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxValidator&);

    sipVH__core_128(sipGILState, 0, sipPySelf, sipMeth, validator);
}

 ::wxValidator* sipwxWindow::GetValidator()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[24], &sipPySelf, SIP_NULLPTR, sipName_GetValidator);

    if (!sipMeth)
        return  ::wxWindow::GetValidator();

    extern  ::wxValidator* sipVH__core_127(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_127(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::ShouldInheritColours() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[25]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_ShouldInheritColours);

    if (!sipMeth)
        return  ::wxWindow::ShouldInheritColours();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::HasTransparentBackground()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[26], &sipPySelf, SIP_NULLPTR, sipName_HasTransparentBackground);

    if (!sipMeth)
        return  ::wxWindow::HasTransparentBackground();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxPoint sipwxWindow::GetClientAreaOrigin() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[27]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetClientAreaOrigin);

    if (!sipMeth)
        return  ::wxWindow::GetClientAreaOrigin();

    extern  ::wxPoint sipVH__core_126(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_126(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::InformFirstDirection(int direction,int size,int availableOtherDir)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[28], &sipPySelf, SIP_NULLPTR, sipName_InformFirstDirection);

    if (!sipMeth)
        return  ::wxWindow::InformFirstDirection(direction,size,availableOtherDir);

    extern bool sipVH__core_125(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int);

    return sipVH__core_125(sipGILState, 0, sipPySelf, sipMeth, direction, size, availableOtherDir);
}

void sipwxWindow::EnableVisibleFocus(bool enable)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[29], &sipPySelf, SIP_NULLPTR, sipName_EnableVisibleFocus);

    if (!sipMeth)
    {
         ::wxWindow::EnableVisibleFocus(enable);
        return;
    }

    extern void sipVH__core_96(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__core_96(sipGILState, 0, sipPySelf, sipMeth, enable);
}

void sipwxWindow::SetCanFocus(bool canFocus)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[30], &sipPySelf, SIP_NULLPTR, sipName_SetCanFocus);

    if (!sipMeth)
    {
         ::wxWindow::SetCanFocus(canFocus);
        return;
    }

    extern void sipVH__core_96(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__core_96(sipGILState, 0, sipPySelf, sipMeth, canFocus);
}

bool sipwxWindow::AcceptsFocusRecursively() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[31]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocusRecursively);

    if (!sipMeth)
        return  ::wxWindow::AcceptsFocusRecursively();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::AcceptsFocusFromKeyboard() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[32]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocusFromKeyboard);

    if (!sipMeth)
        return  ::wxWindow::AcceptsFocusFromKeyboard();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::AcceptsFocus() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[33]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocus);

    if (!sipMeth)
        return  ::wxWindow::AcceptsFocus();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxWindow::TryAfter( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[34], &sipPySelf, SIP_NULLPTR, sipName_TryAfter);

    if (!sipMeth)
        return  ::wxWindow::TryAfter(event);

    extern bool sipVH__core_102(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_102(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxWindow::TryBefore( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[35], &sipPySelf, SIP_NULLPTR, sipName_TryBefore);

    if (!sipMeth)
        return  ::wxWindow::TryBefore(event);

    extern bool sipVH__core_102(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_102(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxWindow::ProcessEvent( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[36], &sipPySelf, SIP_NULLPTR, sipName_ProcessEvent);

    if (!sipMeth)
        return  ::wxWindow::ProcessEvent(event);

    extern bool sipVH__core_102(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_102(sipGILState, 0, sipPySelf, sipMeth, event);
}

void sipwxWindow::AddChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[37], &sipPySelf, SIP_NULLPTR, sipName_AddChild);

    if (!sipMeth)
    {
         ::wxWindow::AddChild(child);
        return;
    }

    extern void sipVH__core_124(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__core_124(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxWindow::RemoveChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[38], &sipPySelf, SIP_NULLPTR, sipName_RemoveChild);

    if (!sipMeth)
    {
         ::wxWindow::RemoveChild(child);
        return;
    }

    extern void sipVH__core_124(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__core_124(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxWindow::sipProtectVirt_DoEnable(bool sipSelfWasArg,bool enable)
{
    (sipSelfWasArg ?  ::wxWindow::DoEnable(enable) : DoEnable(enable));
}

void sipwxWindow::sipProtectVirt_DoGetPosition(bool sipSelfWasArg,int*x,int*y) const
{
    (sipSelfWasArg ?  ::wxWindow::DoGetPosition(x,y) : DoGetPosition(x,y));
}

void sipwxWindow::sipProtectVirt_DoGetSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxWindow::DoGetSize(width,height) : DoGetSize(width,height));
}

void sipwxWindow::sipProtectVirt_DoGetClientSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxWindow::DoGetClientSize(width,height) : DoGetClientSize(width,height));
}

void sipwxWindow::sipProtectVirt_DoSetSize(bool sipSelfWasArg,int x,int y,int width,int height,int sizeFlags)
{
    (sipSelfWasArg ?  ::wxWindow::DoSetSize(x,y,width,height,sizeFlags) : DoSetSize(x,y,width,height,sizeFlags));
}

void sipwxWindow::sipProtectVirt_DoSetClientSize(bool sipSelfWasArg,int width,int height)
{
    (sipSelfWasArg ?  ::wxWindow::DoSetClientSize(width,height) : DoSetClientSize(width,height));
}

void sipwxWindow::sipProtectVirt_DoSetSizeHints(bool sipSelfWasArg,int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    (sipSelfWasArg ?  ::wxWindow::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH) : DoSetSizeHints(minW,minH,maxW,maxH,incW,incH));
}

void sipwxWindow::sipProtectVirt_DoMoveWindow(bool sipSelfWasArg,int x,int y,int width,int height)
{
    (sipSelfWasArg ?  ::wxWindow::DoMoveWindow(x,y,width,height) : DoMoveWindow(x,y,width,height));
}

void sipwxWindow::sipProtectVirt_DoSetWindowVariant(bool sipSelfWasArg, ::wxWindowVariant variant)
{
    (sipSelfWasArg ?  ::wxWindow::DoSetWindowVariant(variant) : DoSetWindowVariant(variant));
}

 ::wxBorder sipwxWindow::sipProtectVirt_GetDefaultBorder(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::GetDefaultBorder() : GetDefaultBorder());
}

 ::wxBorder sipwxWindow::sipProtectVirt_GetDefaultBorderForControl(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::GetDefaultBorderForControl() : GetDefaultBorderForControl());
}

void sipwxWindow::sipProtectVirt_DoFreeze(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxWindow::DoFreeze() : DoFreeze());
}

void sipwxWindow::sipProtectVirt_DoThaw(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxWindow::DoThaw() : DoThaw());
}

bool sipwxWindow::sipProtectVirt_TryBefore(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxWindow::TryBefore(event) : TryBefore(event));
}

bool sipwxWindow::sipProtectVirt_TryAfter(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxWindow::TryAfter(event) : TryAfter(event));
}

 ::wxSize sipwxWindow::sipProtectVirt_DoGetBestSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::DoGetBestSize() : DoGetBestSize());
}

 ::wxSize sipwxWindow::sipProtectVirt_DoGetBestClientSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::DoGetBestClientSize() : DoGetBestClientSize());
}

void sipwxWindow::sipProtect_SendDestroyEvent()
{
     ::wxWindow::SendDestroyEvent();
}

bool sipwxWindow::sipProtectVirt_ProcessEvent(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxWindow::ProcessEvent(event) : ProcessEvent(event));
}


PyDoc_STRVAR(doc_wxWindow_AcceptsFocus, "AcceptsFocus() -> bool\n"
"\n"
"This method may be overridden in the derived classes to return false\n"
"to indicate that this control doesn't accept input at all (i.e.\n"
"behaves like e.g. wxStaticText) and so doesn't need focus.");

extern "C" {static PyObject *meth_wxWindow_AcceptsFocus(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_AcceptsFocus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::AcceptsFocus() : sipCpp->AcceptsFocus());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_AcceptsFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_AcceptsFocusFromKeyboard, "AcceptsFocusFromKeyboard() -> bool\n"
"\n"
"This method may be overridden in the derived classes to return false\n"
"to indicate that while this control can, in principle, have focus if\n"
"the user clicks it with the mouse, it shouldn't be included in the TAB\n"
"traversal chain when using the keyboard.");

extern "C" {static PyObject *meth_wxWindow_AcceptsFocusFromKeyboard(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_AcceptsFocusFromKeyboard(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::AcceptsFocusFromKeyboard() : sipCpp->AcceptsFocusFromKeyboard());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_AcceptsFocusFromKeyboard, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_AcceptsFocusRecursively, "AcceptsFocusRecursively() -> bool\n"
"\n"
"Overridden to indicate whether this window or one of its children\n"
"accepts focus.");

extern "C" {static PyObject *meth_wxWindow_AcceptsFocusRecursively(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_AcceptsFocusRecursively(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::AcceptsFocusRecursively() : sipCpp->AcceptsFocusRecursively());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_AcceptsFocusRecursively, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DisableFocusFromKeyboard, "DisableFocusFromKeyboard()\n"
"\n"
"Disable giving focus to this window using the keyboard navigation\n"
"keys.");

extern "C" {static PyObject *meth_wxWindow_DisableFocusFromKeyboard(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DisableFocusFromKeyboard(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DisableFocusFromKeyboard();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DisableFocusFromKeyboard, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsFocusable, "IsFocusable() -> bool\n"
"\n"
"Can this window itself have focus?");

extern "C" {static PyObject *meth_wxWindow_IsFocusable(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsFocusable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsFocusable();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsFocusable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_CanAcceptFocus, "CanAcceptFocus() -> bool\n"
"\n"
"Can this window have focus right now?");

extern "C" {static PyObject *meth_wxWindow_CanAcceptFocus(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_CanAcceptFocus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanAcceptFocus();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_CanAcceptFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_CanAcceptFocusFromKeyboard, "CanAcceptFocusFromKeyboard() -> bool\n"
"\n"
"Can this window be assigned focus from keyboard right now?");

extern "C" {static PyObject *meth_wxWindow_CanAcceptFocusFromKeyboard(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_CanAcceptFocusFromKeyboard(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanAcceptFocusFromKeyboard();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_CanAcceptFocusFromKeyboard, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HasFocus, "HasFocus() -> bool\n"
"\n"
"Returns true if the window (or in case of composite controls, its main\n"
"child window) has focus.");

extern "C" {static PyObject *meth_wxWindow_HasFocus(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HasFocus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasFocus();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HasFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetCanFocus, "SetCanFocus(canFocus)\n"
"\n"
"This method is only implemented by ports which have support for native\n"
"TAB traversal (such as GTK+ 2.0).");

extern "C" {static PyObject *meth_wxWindow_SetCanFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetCanFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool canFocus;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_canFocus,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxWindow, &sipCpp, &canFocus))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxWindow::SetCanFocus(canFocus) : sipCpp->SetCanFocus(canFocus));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetCanFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_EnableVisibleFocus, "EnableVisibleFocus(enable)\n"
"\n"
"Enables or disables visible indication of keyboard focus.");

extern "C" {static PyObject *meth_wxWindow_EnableVisibleFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_EnableVisibleFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool enable;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxWindow, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxWindow::EnableVisibleFocus(enable) : sipCpp->EnableVisibleFocus(enable));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_EnableVisibleFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetFocus, "SetFocus()\n"
"\n"
"This sets the window to receive keyboard input.");

extern "C" {static PyObject *meth_wxWindow_SetFocus(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetFocus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFocus();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetFocusFromKbd, "SetFocusFromKbd()\n"
"\n"
"This function is called by wxWidgets keyboard navigation code when the\n"
"user gives the focus to this window from keyboard (e.g. using TAB\n"
"key).");

extern "C" {static PyObject *meth_wxWindow_SetFocusFromKbd(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetFocusFromKbd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFocusFromKbd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetFocusFromKbd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_AddChild, "AddChild(child)\n"
"\n"
"Adds a child window.");

extern "C" {static PyObject *meth_wxWindow_AddChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_AddChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowBase* child;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_child,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindowBase, &child))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxWindow::AddChild(child) : sipCpp->AddChild(child));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_AddChild, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DestroyChildren, "DestroyChildren() -> bool\n"
"\n"
"Destroys all children of a window.");

extern "C" {static PyObject *meth_wxWindow_DestroyChildren(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DestroyChildren(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DestroyChildren();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DestroyChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_FindWindow, "FindWindow(id) -> Window\n"
"FindWindow(name) -> Window\n"
"\n"
"Find a child of this window, by id.\n"
"");

extern "C" {static PyObject *meth_wxWindow_FindWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_FindWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long id;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxWindow, &sipCpp, &id))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindWindow(id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    {
        const  ::wxString* name;
        int nameState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxString, &name, &nameState))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindWindow(*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_FindWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetChildren, "GetChildren() -> WindowList\n"
"\n"
"Returns a reference to the list of the window's children.");

extern "C" {static PyObject *meth_wxWindow_GetChildren(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetChildren(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindowList*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->GetChildren();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindowList,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_RemoveChild, "RemoveChild(child)\n"
"\n"
"Removes a child window.");

extern "C" {static PyObject *meth_wxWindow_RemoveChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_RemoveChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowBase* child;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_child,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindowBase, &child))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxWindow::RemoveChild(child) : sipCpp->RemoveChild(child));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_RemoveChild, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetGrandParent, "GetGrandParent() -> Window\n"
"\n"
"Returns the grandparent of a window, or NULL if there isn't one.");

extern "C" {static PyObject *meth_wxWindow_GetGrandParent(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetGrandParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGrandParent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetGrandParent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetNextSibling, "GetNextSibling() -> Window\n"
"\n"
"Returns the next window after this one among the parent's children or\n"
"NULL if this window is the last child.");

extern "C" {static PyObject *meth_wxWindow_GetNextSibling(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetNextSibling(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetNextSibling();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetNextSibling, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetParent, "GetParent() -> Window\n"
"\n"
"Returns the parent of the window, or NULL if there is no parent.");

extern "C" {static PyObject *meth_wxWindow_GetParent(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetParent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetParent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetPrevSibling, "GetPrevSibling() -> Window\n"
"\n"
"Returns the previous window before this one among the parent's\n"
"children or  NULL if this window is the first child.");

extern "C" {static PyObject *meth_wxWindow_GetPrevSibling(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetPrevSibling(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPrevSibling();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetPrevSibling, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsDescendant, "IsDescendant(win) -> bool\n"
"\n"
"Check if the specified window is a descendant of this one.");

extern "C" {static PyObject *meth_wxWindow_IsDescendant(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsDescendant(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* win;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_win,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindow, &win))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsDescendant(win);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsDescendant, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Reparent, "Reparent(newParent) -> bool\n"
"\n"
"Reparents the window, i.e. the window will be removed from its current\n"
"parent window (e.g.");

extern "C" {static PyObject *meth_wxWindow_Reparent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Reparent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* newParent;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_newParent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindow, &newParent))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Reparent(newParent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Reparent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_AlwaysShowScrollbars, "AlwaysShowScrollbars(hflag=True, vflag=True)\n"
"\n"
"Call this function to force one or both scrollbars to be always shown,\n"
"even if the window is big enough to show its entire contents without\n"
"scrolling.");

extern "C" {static PyObject *meth_wxWindow_AlwaysShowScrollbars(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_AlwaysShowScrollbars(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool hflag = 1;
        bool vflag = 1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_hflag,
            sipName_vflag,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|bb", &sipSelf, sipType_wxWindow, &sipCpp, &hflag, &vflag))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AlwaysShowScrollbars(hflag,vflag);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_AlwaysShowScrollbars, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetScrollPos, "GetScrollPos(orientation) -> int\n"
"\n"
"Returns the built-in scrollbar position.");

extern "C" {static PyObject *meth_wxWindow_GetScrollPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetScrollPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int orientation;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_orientation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &orientation))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetScrollPos(orientation);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetScrollPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetScrollRange, "GetScrollRange(orientation) -> int\n"
"\n"
"Returns the built-in scrollbar range.");

extern "C" {static PyObject *meth_wxWindow_GetScrollRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetScrollRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int orientation;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_orientation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &orientation))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetScrollRange(orientation);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetScrollRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetScrollThumb, "GetScrollThumb(orientation) -> int\n"
"\n"
"Returns the built-in scrollbar thumb size.");

extern "C" {static PyObject *meth_wxWindow_GetScrollThumb(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetScrollThumb(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int orientation;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_orientation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &orientation))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetScrollThumb(orientation);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetScrollThumb, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_CanScroll, "CanScroll(orient) -> bool\n"
"\n"
"Returns true if this window can have a scroll bar in this orientation.");

extern "C" {static PyObject *meth_wxWindow_CanScroll(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_CanScroll(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int orient;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_orient,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &orient))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanScroll(orient);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_CanScroll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HasScrollbar, "HasScrollbar(orient) -> bool\n"
"\n"
"Returns true if this window currently has a scroll bar for this\n"
"orientation.");

extern "C" {static PyObject *meth_wxWindow_HasScrollbar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HasScrollbar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int orient;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_orient,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &orient))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasScrollbar(orient);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HasScrollbar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsScrollbarAlwaysShown, "IsScrollbarAlwaysShown(orient) -> bool\n"
"\n"
"Return whether a scrollbar is always shown.");

extern "C" {static PyObject *meth_wxWindow_IsScrollbarAlwaysShown(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsScrollbarAlwaysShown(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int orient;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_orient,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &orient))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsScrollbarAlwaysShown(orient);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsScrollbarAlwaysShown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ScrollLines, "ScrollLines(lines) -> bool\n"
"\n"
"Scrolls the window by the given number of lines down (if lines is\n"
"positive) or up.");

extern "C" {static PyObject *meth_wxWindow_ScrollLines(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ScrollLines(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lines;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lines,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &lines))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ScrollLines(lines);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ScrollLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ScrollPages, "ScrollPages(pages) -> bool\n"
"\n"
"Scrolls the window by the given number of pages down (if pages is\n"
"positive) or up.");

extern "C" {static PyObject *meth_wxWindow_ScrollPages(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ScrollPages(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pages;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pages,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &pages))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ScrollPages(pages);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ScrollPages, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ScrollWindow, "ScrollWindow(dx, dy, rect=None)\n"
"\n"
"Physically scrolls the pixels in the window and move child windows\n"
"accordingly.");

extern "C" {static PyObject *meth_wxWindow_ScrollWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ScrollWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int dx;
        int dy;
        const  ::wxRect* rect = 0;
        int rectState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dx,
            sipName_dy,
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|J0", &sipSelf, sipType_wxWindow, &sipCpp, &dx, &dy, sipType_wxRect, &rect, &rectState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ScrollWindow(dx,dy,rect);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ScrollWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_LineUp, "LineUp() -> bool\n"
"\n"
"Same as ScrollLines (-1).");

extern "C" {static PyObject *meth_wxWindow_LineUp(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_LineUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LineUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_LineUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_LineDown, "LineDown() -> bool\n"
"\n"
"Same as ScrollLines (1).");

extern "C" {static PyObject *meth_wxWindow_LineDown(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_LineDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LineDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_LineDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_PageUp, "PageUp() -> bool\n"
"\n"
"Same as ScrollPages (-1).");

extern "C" {static PyObject *meth_wxWindow_PageUp(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_PageUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PageUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_PageUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_PageDown, "PageDown() -> bool\n"
"\n"
"Same as ScrollPages (1).");

extern "C" {static PyObject *meth_wxWindow_PageDown(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_PageDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PageDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_PageDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetScrollPos, "SetScrollPos(orientation, pos, refresh=True)\n"
"\n"
"Sets the position of one of the built-in scrollbars.");

extern "C" {static PyObject *meth_wxWindow_SetScrollPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetScrollPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int orientation;
        int pos;
        bool refresh = 1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_orientation,
            sipName_pos,
            sipName_refresh,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|b", &sipSelf, sipType_wxWindow, &sipCpp, &orientation, &pos, &refresh))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetScrollPos(orientation,pos,refresh);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetScrollPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetScrollbar, "SetScrollbar(orientation, position, thumbSize, range, refresh=True)\n"
"\n"
"Sets the scrollbar properties of a built-in scrollbar.");

extern "C" {static PyObject *meth_wxWindow_SetScrollbar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetScrollbar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int orientation;
        int position;
        int thumbSize;
        int range;
        bool refresh = 1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_orientation,
            sipName_position,
            sipName_thumbSize,
            sipName_range,
            sipName_refresh,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii|b", &sipSelf, sipType_wxWindow, &sipCpp, &orientation, &position, &thumbSize, &range, &refresh))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetScrollbar(orientation,position,thumbSize,range,refresh);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetScrollbar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_BeginRepositioningChildren, "BeginRepositioningChildren() -> bool\n"
"\n"
"Prepare for changing positions of multiple child windows.");

extern "C" {static PyObject *meth_wxWindow_BeginRepositioningChildren(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_BeginRepositioningChildren(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BeginRepositioningChildren();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_BeginRepositioningChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_EndRepositioningChildren, "EndRepositioningChildren()\n"
"\n"
"Fix child window positions after setting all of them at once.");

extern "C" {static PyObject *meth_wxWindow_EndRepositioningChildren(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_EndRepositioningChildren(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EndRepositioningChildren();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_EndRepositioningChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_CacheBestSize, "CacheBestSize(size)\n"
"\n"
"Sets the cached best size value.");

extern "C" {static PyObject *meth_wxWindow_CacheBestSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_CacheBestSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CacheBestSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_CacheBestSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ClientToWindowSize, "ClientToWindowSize(size) -> Size\n"
"\n"
"Converts client area size size to corresponding window size.");

extern "C" {static PyObject *meth_wxWindow_ClientToWindowSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ClientToWindowSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ClientToWindowSize(*size));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ClientToWindowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_WindowToClientSize, "WindowToClientSize(size) -> Size\n"
"\n"
"Converts window size size to corresponding client area size In other\n"
"words, the returned value is what would GetClientSize() return if this\n"
"window had given window size.");

extern "C" {static PyObject *meth_wxWindow_WindowToClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_WindowToClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->WindowToClientSize(*size));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_WindowToClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Fit, "Fit()\n"
"\n"
"Sizes the window to fit its best size.");

extern "C" {static PyObject *meth_wxWindow_Fit(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Fit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Fit();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Fit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_FitInside, "FitInside()\n"
"\n"
"Similar to Fit(), but sizes the interior (virtual) size of a window.");

extern "C" {static PyObject *meth_wxWindow_FitInside(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_FitInside(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FitInside();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_FitInside, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_FromDIP, "FromDIP(sz) -> Size\n"
"FromDIP(pt) -> Point\n"
"FromDIP(d) -> int\n"
"FromDIP(sz, w) -> Size\n"
"FromDIP(pt, w) -> Point\n"
"FromDIP(d, w) -> int\n"
"\n"
"Convert DPI-independent pixel values to the value in pixels\n"
"appropriate for the current toolkit.\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxWindow_FromDIP(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_FromDIP(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &sz, &szState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->FromDIP(*sz));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->FromDIP(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        int d;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_d,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &d))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FromDIP(d);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_sz,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J8", sipType_wxSize, &sz, &szState, sipType_wxWindow, &w))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize( ::wxWindow::FromDIP(*sz,w));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J8", sipType_wxPoint, &pt, &ptState, sipType_wxWindow, &w))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint( ::wxWindow::FromDIP(*pt,w));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        int d;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_d,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "iJ8", &d, sipType_wxWindow, &w))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::FromDIP(d,w);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_FromDIP, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ToDIP, "ToDIP(sz) -> Size\n"
"ToDIP(pt) -> Point\n"
"ToDIP(d) -> int\n"
"ToDIP(sz, w) -> Size\n"
"ToDIP(pt, w) -> Point\n"
"ToDIP(d, w) -> int\n"
"\n"
"Convert pixel values of the current toolkit to DPI-independent pixel\n"
"values.\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxWindow_ToDIP(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ToDIP(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &sz, &szState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ToDIP(*sz));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->ToDIP(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        int d;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_d,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &d))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ToDIP(d);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_sz,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J8", sipType_wxSize, &sz, &szState, sipType_wxWindow, &w))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize( ::wxWindow::ToDIP(*sz,w));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J8", sipType_wxPoint, &pt, &ptState, sipType_wxWindow, &w))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint( ::wxWindow::ToDIP(*pt,w));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        int d;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_d,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "iJ8", &d, sipType_wxWindow, &w))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::ToDIP(d,w);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ToDIP, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_FromPhys, "FromPhys(sz) -> Size\n"
"FromPhys(pt) -> Point\n"
"FromPhys(d) -> int\n"
"FromPhys(sz, w) -> Size\n"
"FromPhys(pt, w) -> Point\n"
"FromPhys(d, w) -> int\n"
"\n"
"Convert from physical pixels to logical pixels.\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxWindow_FromPhys(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_FromPhys(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &sz, &szState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->FromPhys(*sz));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->FromPhys(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        int d;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_d,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &d))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FromPhys(d);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_sz,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J8", sipType_wxSize, &sz, &szState, sipType_wxWindow, &w))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize( ::wxWindow::FromPhys(*sz,w));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J8", sipType_wxPoint, &pt, &ptState, sipType_wxWindow, &w))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint( ::wxWindow::FromPhys(*pt,w));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        int d;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_d,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "iJ8", &d, sipType_wxWindow, &w))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::FromPhys(d,w);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_FromPhys, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ToPhys, "ToPhys(sz) -> Size\n"
"ToPhys(pt) -> Point\n"
"ToPhys(d) -> int\n"
"ToPhys(sz, w) -> Size\n"
"ToPhys(pt, w) -> Point\n"
"ToPhys(d, w) -> int\n"
"\n"
"Convert from logical pixels to physical pixels.\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxWindow_ToPhys(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ToPhys(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &sz, &szState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ToPhys(*sz));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->ToPhys(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        int d;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_d,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &d))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ToPhys(d);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_sz,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J8", sipType_wxSize, &sz, &szState, sipType_wxWindow, &w))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize( ::wxWindow::ToPhys(*sz,w));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J8", sipType_wxPoint, &pt, &ptState, sipType_wxWindow, &w))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint( ::wxWindow::ToPhys(*pt,w));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        int d;
        const  ::wxWindow* w;

        static const char *sipKwdList[] = {
            sipName_d,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "iJ8", &d, sipType_wxWindow, &w))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::ToPhys(d,w);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ToPhys, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetBestSize, "GetBestSize() -> Size\n"
"\n"
"This functions returns the best acceptable minimal size for the\n"
"window.");

extern "C" {static PyObject *meth_wxWindow_GetBestSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetBestSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetBestSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetBestSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetBestHeight, "GetBestHeight(width) -> int\n"
"\n"
"Returns the best height needed by this window if it had the given\n"
"width.");

extern "C" {static PyObject *meth_wxWindow_GetBestHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetBestHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &width))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetBestHeight(width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetBestHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetBestWidth, "GetBestWidth(height) -> int\n"
"\n"
"Returns the best width needed by this window if it had the given\n"
"height.");

extern "C" {static PyObject *meth_wxWindow_GetBestWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetBestWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int height;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &height))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetBestWidth(height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetBestWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetClientSize, "GetClientSize() -> Size\n"
"\n"
"Returns the size of the window 'client area' in pixels.");

extern "C" {static PyObject *meth_wxWindow_GetClientSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetClientSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetClientSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetEffectiveMinSize, "GetEffectiveMinSize() -> Size\n"
"\n"
"Merges the window's best size into the min size and returns the\n"
"result.");

extern "C" {static PyObject *meth_wxWindow_GetEffectiveMinSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetEffectiveMinSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetEffectiveMinSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetEffectiveMinSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMaxClientSize, "GetMaxClientSize() -> Size\n"
"\n"
"Returns the maximum size of window's client area.");

extern "C" {static PyObject *meth_wxWindow_GetMaxClientSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMaxClientSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetMaxClientSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMaxClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMaxSize, "GetMaxSize() -> Size\n"
"\n"
"Returns the maximum size of the window.");

extern "C" {static PyObject *meth_wxWindow_GetMaxSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMaxSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetMaxSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMaxSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMinClientSize, "GetMinClientSize() -> Size\n"
"\n"
"Returns the minimum size of window's client area, an indication to the\n"
"sizer layout mechanism that this is the minimum required size of its\n"
"client area.");

extern "C" {static PyObject *meth_wxWindow_GetMinClientSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMinClientSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetMinClientSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMinClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMinSize, "GetMinSize() -> Size\n"
"\n"
"Returns the minimum size of the window, an indication to the sizer\n"
"layout mechanism that this is the minimum required size.");

extern "C" {static PyObject *meth_wxWindow_GetMinSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMinSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetMinSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMinSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMinWidth, "GetMinWidth() -> int\n"
"\n"
"Returns the horizontal component of window minimal size.");

extern "C" {static PyObject *meth_wxWindow_GetMinWidth(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMinWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMinWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMinWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMinHeight, "GetMinHeight() -> int\n"
"\n"
"Returns the vertical component of window minimal size.");

extern "C" {static PyObject *meth_wxWindow_GetMinHeight(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMinHeight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMinHeight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMinHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMaxWidth, "GetMaxWidth() -> int\n"
"\n"
"Returns the horizontal component of window maximal size.");

extern "C" {static PyObject *meth_wxWindow_GetMaxWidth(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMaxWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMaxWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMaxWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMaxHeight, "GetMaxHeight() -> int\n"
"\n"
"Returns the vertical component of window maximal size.");

extern "C" {static PyObject *meth_wxWindow_GetMaxHeight(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMaxHeight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMaxHeight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMaxHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetSize, "GetSize() -> Size\n"
"\n"
"Returns the size of the entire window in pixels, including title bar,\n"
"border, scrollbars, etc.");

extern "C" {static PyObject *meth_wxWindow_GetSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetVirtualSize, "GetVirtualSize() -> Size\n"
"\n"
"This gets the virtual size of the window in pixels.");

extern "C" {static PyObject *meth_wxWindow_GetVirtualSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetVirtualSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetVirtualSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetVirtualSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetBestVirtualSize, "GetBestVirtualSize() -> Size\n"
"\n"
"Return the largest of ClientSize and BestSize (as determined by a\n"
"sizer, interior children, or other means)");

extern "C" {static PyObject *meth_wxWindow_GetBestVirtualSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetBestVirtualSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetBestVirtualSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetBestVirtualSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetContentScaleFactor, "GetContentScaleFactor() -> double\n"
"\n"
"Returns the factor mapping logical pixels of this window to physical\n"
"pixels.");

extern "C" {static PyObject *meth_wxWindow_GetContentScaleFactor(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetContentScaleFactor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            double sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetContentScaleFactor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyFloat_FromDouble(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetContentScaleFactor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetDPIScaleFactor, "GetDPIScaleFactor() -> double\n"
"\n"
"Returns the ratio of the DPI used by this window to the standard DPI.");

extern "C" {static PyObject *meth_wxWindow_GetDPIScaleFactor(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetDPIScaleFactor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            double sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDPIScaleFactor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyFloat_FromDouble(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetDPIScaleFactor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetWindowBorderSize, "GetWindowBorderSize() -> Size\n"
"\n"
"Returns the size of the left/right and top/bottom borders of this\n"
"window in x and y components of the result respectively.");

extern "C" {static PyObject *meth_wxWindow_GetWindowBorderSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetWindowBorderSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetWindowBorderSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetWindowBorderSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_InformFirstDirection, "InformFirstDirection(direction, size, availableOtherDir) -> bool\n"
"\n"
"wxSizer and friends use this to give a chance to a component to recalc\n"
"its min size once one of the final size components is known.");

extern "C" {static PyObject *meth_wxWindow_InformFirstDirection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_InformFirstDirection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int direction;
        int size;
        int availableOtherDir;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_direction,
            sipName_size,
            sipName_availableOtherDir,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biii", &sipSelf, sipType_wxWindow, &sipCpp, &direction, &size, &availableOtherDir))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::InformFirstDirection(direction,size,availableOtherDir) : sipCpp->InformFirstDirection(direction,size,availableOtherDir));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_InformFirstDirection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_InvalidateBestSize, "InvalidateBestSize()\n"
"\n"
"Resets the cached best size value so it will be recalculated the next\n"
"time it is needed.");

extern "C" {static PyObject *meth_wxWindow_InvalidateBestSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_InvalidateBestSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->InvalidateBestSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_InvalidateBestSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_PostSizeEvent, "PostSizeEvent()\n"
"\n"
"Posts a size event to the window.");

extern "C" {static PyObject *meth_wxWindow_PostSizeEvent(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_PostSizeEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PostSizeEvent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_PostSizeEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_PostSizeEventToParent, "PostSizeEventToParent()\n"
"\n"
"Posts a size event to the parent of this window.");

extern "C" {static PyObject *meth_wxWindow_PostSizeEventToParent(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_PostSizeEventToParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PostSizeEventToParent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_PostSizeEventToParent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SendSizeEvent, "SendSizeEvent(flags=0)\n"
"\n"
"This function sends a dummy size event to the window allowing it to\n"
"re-layout its children positions.");

extern "C" {static PyObject *meth_wxWindow_SendSizeEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SendSizeEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxWindow, &sipCpp, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SendSizeEvent(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SendSizeEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SendSizeEventToParent, "SendSizeEventToParent(flags=0)\n"
"\n"
"Safe wrapper for GetParent()->SendSizeEvent().");

extern "C" {static PyObject *meth_wxWindow_SendSizeEventToParent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SendSizeEventToParent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxWindow, &sipCpp, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SendSizeEventToParent(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SendSizeEventToParent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetClientSize, "SetClientSize(width, height)\n"
"SetClientSize(size)\n"
"SetClientSize(rect)\n"
"\n"
"This sets the size of the window client area in pixels.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxWindow_SetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
        int height;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClientSize(width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClientSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxRect* rect;
        int rectState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxRect, &rect, &rectState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClientSize(*rect);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetContainingSizer, "SetContainingSizer(sizer)\n"
"\n"
"Used by wxSizer internally to notify the window about being managed by\n"
"the given sizer.");

extern "C" {static PyObject *meth_wxWindow_SetContainingSizer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetContainingSizer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSizer* sizer;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSizer, &sizer))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetContainingSizer(sizer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetContainingSizer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetInitialSize, "SetInitialSize(size=DefaultSize)\n"
"\n"
"A smart SetSize that will fill in default size components with the\n"
"window's best size values.");

extern "C" {static PyObject *meth_wxWindow_SetInitialSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetInitialSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetInitialSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetInitialSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetMaxClientSize, "SetMaxClientSize(size)\n"
"\n"
"Sets the maximum client size of the window, to indicate to the sizer\n"
"layout mechanism that this is the maximum possible size of its client\n"
"area.");

extern "C" {static PyObject *meth_wxWindow_SetMaxClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetMaxClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMaxClientSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetMaxClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetMaxSize, "SetMaxSize(size)\n"
"\n"
"Sets the maximum size of the window, to indicate to the sizer layout\n"
"mechanism that this is the maximum possible size.");

extern "C" {static PyObject *meth_wxWindow_SetMaxSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetMaxSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMaxSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetMaxSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetMinClientSize, "SetMinClientSize(size)\n"
"\n"
"Sets the minimum client size of the window, to indicate to the sizer\n"
"layout mechanism that this is the minimum required size of window's\n"
"client area.");

extern "C" {static PyObject *meth_wxWindow_SetMinClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetMinClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMinClientSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetMinClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetMinSize, "SetMinSize(size)\n"
"\n"
"Sets the minimum size of the window, to indicate to the sizer layout\n"
"mechanism that this is the minimum required size.");

extern "C" {static PyObject *meth_wxWindow_SetMinSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetMinSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMinSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetMinSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetSize, "SetSize(x, y, width, height, sizeFlags=SIZE_AUTO)\n"
"SetSize(rect)\n"
"SetSize(size)\n"
"SetSize(width, height)\n"
"\n"
"Sets the size of the window in pixels.\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxWindow_SetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        int width;
        int height;
        int sizeFlags = wxSIZE_AUTO;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
            sipName_sizeFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii|i", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y, &width, &height, &sizeFlags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSize(x,y,width,height,sizeFlags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxRect* rect;
        int rectState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxRect, &rect, &rectState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSize(*rect);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        int width;
        int height;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSize(width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetSizeHints, "SetSizeHints(minSize, maxSize=DefaultSize, incSize=DefaultSize)\n"
"SetSizeHints(minW, minH, maxW=-1, maxH=-1, incW=-1, incH=-1)\n"
"\n"
"Use of this function for windows which are not toplevel windows (such\n"
"as wxDialog or wxFrame) is discouraged.\n"
"");

extern "C" {static PyObject *meth_wxWindow_SetSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* minSize;
        int minSizeState = 0;
        const  ::wxSize& maxSizedef = wxDefaultSize;
        const  ::wxSize* maxSize = &maxSizedef;
        int maxSizeState = 0;
        const  ::wxSize& incSizedef = wxDefaultSize;
        const  ::wxSize* incSize = &incSizedef;
        int incSizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minSize,
            sipName_maxSize,
            sipName_incSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|J1J1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &minSize, &minSizeState, sipType_wxSize, &maxSize, &maxSizeState, sipType_wxSize, &incSize, &incSizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSizeHints(*minSize,*maxSize,*incSize);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(minSize), sipType_wxSize, minSizeState);
            sipReleaseType(const_cast< ::wxSize *>(maxSize), sipType_wxSize, maxSizeState);
            sipReleaseType(const_cast< ::wxSize *>(incSize), sipType_wxSize, incSizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        int minW;
        int minH;
        int maxW = -1;
        int maxH = -1;
        int incW = -1;
        int incH = -1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minW,
            sipName_minH,
            sipName_maxW,
            sipName_maxH,
            sipName_incW,
            sipName_incH,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|iiii", &sipSelf, sipType_wxWindow, &sipCpp, &minW, &minH, &maxW, &maxH, &incW, &incH))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSizeHints(minW,minH,maxW,maxH,incW,incH);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetSizeHints, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetVirtualSize, "SetVirtualSize(width, height)\n"
"SetVirtualSize(size)\n"
"\n"
"Sets the virtual size of the window in pixels.\n"
"");

extern "C" {static PyObject *meth_wxWindow_SetVirtualSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetVirtualSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
        int height;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetVirtualSize(width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetVirtualSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetVirtualSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Center, "Center(dir=BOTH)\n"
"\n"
"A synonym for Centre().");

extern "C" {static PyObject *meth_wxWindow_Center(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Center(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int dir = wxBOTH;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dir,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxWindow, &sipCpp, &dir))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Center(dir);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Center, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_CenterOnParent, "CenterOnParent(dir=BOTH)\n"
"\n"
"A synonym for CentreOnParent().");

extern "C" {static PyObject *meth_wxWindow_CenterOnParent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_CenterOnParent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int dir = wxBOTH;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dir,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxWindow, &sipCpp, &dir))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CenterOnParent(dir);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_CenterOnParent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Centre, "Centre(direction=BOTH)\n"
"\n"
"Centres the window.");

extern "C" {static PyObject *meth_wxWindow_Centre(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Centre(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int direction = wxBOTH;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_direction,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxWindow, &sipCpp, &direction))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Centre(direction);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Centre, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_CentreOnParent, "CentreOnParent(direction=BOTH)\n"
"\n"
"Centres the window on its parent.");

extern "C" {static PyObject *meth_wxWindow_CentreOnParent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_CentreOnParent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int direction = wxBOTH;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_direction,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxWindow, &sipCpp, &direction))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CentreOnParent(direction);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_CentreOnParent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetPosition, "GetPosition() -> Point\n"
"\n"
"This gets the position of the window in pixels, relative to the parent\n"
"window for the child windows or relative to the display origin for the\n"
"top level windows.");

extern "C" {static PyObject *meth_wxWindow_GetPosition(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetPosition());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetRect, "GetRect() -> Rect\n"
"\n"
"Returns the position and size of the window as a wxRect object.");

extern "C" {static PyObject *meth_wxWindow_GetRect(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetRect(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->GetRect());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetScreenPosition, "GetScreenPosition() -> Point\n"
"\n"
"Returns the window position in screen coordinates, whether the window\n"
"is a child window or a top level one.");

extern "C" {static PyObject *meth_wxWindow_GetScreenPosition(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetScreenPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetScreenPosition());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetScreenPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetScreenRect, "GetScreenRect() -> Rect\n"
"\n"
"Returns the position and size of the window on the screen as a wxRect\n"
"object.");

extern "C" {static PyObject *meth_wxWindow_GetScreenRect(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetScreenRect(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->GetScreenRect());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetScreenRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetClientAreaOrigin, "GetClientAreaOrigin() -> Point\n"
"\n"
"Get the origin of the client area of the window relative to the window\n"
"top left corner (the client area may be shifted because of the\n"
"borders, scrollbars, other decorations...)");

extern "C" {static PyObject *meth_wxWindow_GetClientAreaOrigin(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetClientAreaOrigin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint((sipSelfWasArg ? sipCpp-> ::wxWindow::GetClientAreaOrigin() : sipCpp->GetClientAreaOrigin()));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetClientAreaOrigin, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetClientRect, "GetClientRect() -> Rect\n"
"\n"
"Get the client rectangle in window (i.e. client) coordinates.");

extern "C" {static PyObject *meth_wxWindow_GetClientRect(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetClientRect(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->GetClientRect());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetClientRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Move, "Move(x, y, flags=SIZE_USE_EXISTING)\n"
"Move(pt, flags=SIZE_USE_EXISTING)\n"
"\n"
"Moves the window to the given position.\n"
"");

extern "C" {static PyObject *meth_wxWindow_Move(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Move(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        int flags = wxSIZE_USE_EXISTING;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|i", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Move(x,y,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        int flags = wxSIZE_USE_EXISTING;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|i", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Move(*pt,flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Move, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetPosition, "SetPosition(pt)\n"
"\n"
"Moves the window to the specified position.");

extern "C" {static PyObject *meth_wxWindow_SetPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPosition(*pt);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ClientToScreen, "ClientToScreen(x, y) -> (x, y)\n"
"ClientToScreen(pt) -> Point\n"
"\n"
"Converts to screen coordinates from coordinates relative to this\n"
"window.\n"
"");

extern "C" {static PyObject *meth_wxWindow_ClientToScreen(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ClientToScreen(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClientToScreen(&x,&y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",x,y);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->ClientToScreen(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ClientToScreen, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ConvertDialogToPixels, "ConvertDialogToPixels(pt) -> Point\n"
"ConvertDialogToPixels(sz) -> Size\n"
"\n"
"Converts a point or size from dialog units to pixels.\n"
"");

extern "C" {static PyObject *meth_wxWindow_ConvertDialogToPixels(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ConvertDialogToPixels(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->ConvertDialogToPixels(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &sz, &szState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ConvertDialogToPixels(*sz));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ConvertDialogToPixels, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ConvertPixelsToDialog, "ConvertPixelsToDialog(pt) -> Point\n"
"ConvertPixelsToDialog(sz) -> Size\n"
"\n"
"Converts a point or size from pixels to dialog units.\n"
"");

extern "C" {static PyObject *meth_wxWindow_ConvertPixelsToDialog(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ConvertPixelsToDialog(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->ConvertPixelsToDialog(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    {
        const  ::wxSize* sz;
        int szState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSize, &sz, &szState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ConvertPixelsToDialog(*sz));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(sz), sipType_wxSize, szState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ConvertPixelsToDialog, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ScreenToClient, "ScreenToClient(x, y) -> (x, y)\n"
"ScreenToClient(pt) -> Point\n"
"\n"
"Converts from screen to client window coordinates.\n"
"");

extern "C" {static PyObject *meth_wxWindow_ScreenToClient(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ScreenToClient(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ScreenToClient(&x,&y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",x,y);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->ScreenToClient(*pt));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ScreenToClient, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ClearBackground, "ClearBackground()\n"
"\n"
"Clears the window by filling it with the current background colour.");

extern "C" {static PyObject *meth_wxWindow_ClearBackground(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ClearBackground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearBackground();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ClearBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Freeze, "Freeze()\n"
"\n"
"Freezes the window or, in other words, prevents any updates from\n"
"taking place on screen, the window is not redrawn at all.");

extern "C" {static PyObject *meth_wxWindow_Freeze(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Freeze(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Freeze();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Freeze, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Thaw, "Thaw()\n"
"\n"
"Re-enables window updating after a previous call to Freeze().");

extern "C" {static PyObject *meth_wxWindow_Thaw(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Thaw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Thaw();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Thaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsFrozen, "IsFrozen() -> bool\n"
"\n"
"Returns true if the window is currently frozen by a call to Freeze().");

extern "C" {static PyObject *meth_wxWindow_IsFrozen(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsFrozen(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsFrozen();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsFrozen, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetBackgroundColour, "GetBackgroundColour() -> Colour\n"
"\n"
"Returns the background colour of the window.");

extern "C" {static PyObject *meth_wxWindow_GetBackgroundColour(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetBackgroundColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetBackgroundColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetBackgroundStyle, "GetBackgroundStyle() -> BackgroundStyle\n"
"\n"
"Returns the background style of the window.");

extern "C" {static PyObject *meth_wxWindow_GetBackgroundStyle(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetBackgroundStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxBackgroundStyle sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetBackgroundStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBackgroundStyle);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetBackgroundStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetCharHeight, "GetCharHeight() -> int\n"
"\n"
"Returns the character height for this window.");

extern "C" {static PyObject *meth_wxWindow_GetCharHeight(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetCharHeight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCharHeight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetCharHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetCharWidth, "GetCharWidth() -> int\n"
"\n"
"Returns the average character width for this window.");

extern "C" {static PyObject *meth_wxWindow_GetCharWidth(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetCharWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCharWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetCharWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetDefaultAttributes, "GetDefaultAttributes() -> VisualAttributes\n"
"\n"
"Currently this is the same as calling\n"
"wxWindow::GetClassDefaultAttributes(wxWindow::GetWindowVariant()).");

extern "C" {static PyObject *meth_wxWindow_GetDefaultAttributes(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetDefaultAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxVisualAttributes*sipRes;
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxVisualAttributes(sipCpp->GetDefaultAttributes());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxVisualAttributes,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetDefaultAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetDPI, "GetDPI() -> Size\n"
"\n"
"Return the DPI of the display used by this window.");

extern "C" {static PyObject *meth_wxWindow_GetDPI(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetDPI(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetDPI());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetDPI, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetFont, "GetFont() -> Font\n"
"\n"
"Returns the font for this window.");

extern "C" {static PyObject *meth_wxWindow_GetFont(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetFont(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxFont*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxFont(sipCpp->GetFont());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxFont,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetForegroundColour, "GetForegroundColour() -> Colour\n"
"\n"
"Returns the foreground colour of the window.");

extern "C" {static PyObject *meth_wxWindow_GetForegroundColour(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetForegroundColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetForegroundColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetForegroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetFullTextExtent, "GetFullTextExtent(string, font=None) -> (w, h, descent, externalLeading)\n"
"\n"
"Gets the dimensions of the string as it would be drawn on the window\n"
"with the currently selected font.");

extern "C" {static PyObject *meth_wxWindow_GetFullTextExtent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetFullTextExtent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* string;
        int stringState = 0;
        int w;
        int h;
        int descent;
        int externalLeading;
        const  ::wxFont* font = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_string,
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|J8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxString, &string, &stringState, sipType_wxFont, &font))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GetTextExtent(*string,&w,&h,&descent,&externalLeading,font);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(string), sipType_wxString, stringState);

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(iiii)",w,h,descent,externalLeading);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetFullTextExtent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetTextExtent, "GetTextExtent(string) -> Size\n"
"\n"
"Gets the dimensions of the string as it would be drawn on the window\n"
"with the currently selected font.");

extern "C" {static PyObject *meth_wxWindow_GetTextExtent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetTextExtent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* string;
        int stringState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_string,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxString, &string, &stringState))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetTextExtent(*string));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(string), sipType_wxString, stringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetTextExtent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetUpdateRegion, "GetUpdateRegion() -> Region\n"
"\n"
"Returns the region specifying which parts of the window have been\n"
"damaged.");

extern "C" {static PyObject *meth_wxWindow_GetUpdateRegion(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetUpdateRegion(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxRegion*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRegion(sipCpp->GetUpdateRegion());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRegion,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetUpdateRegion, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetUpdateClientRect, "GetUpdateClientRect() -> Rect\n"
"\n"
"Get the update rectangle bounding box in client coords.");

extern "C" {static PyObject *meth_wxWindow_GetUpdateClientRect(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetUpdateClientRect(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxRect*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxRect(sipCpp->GetUpdateClientRect());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxRect,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetUpdateClientRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HasTransparentBackground, "HasTransparentBackground() -> bool\n"
"\n"
"Returns true if this window background is transparent (as, for\n"
"example, for wxStaticText) and should show the parent window\n"
"background.");

extern "C" {static PyObject *meth_wxWindow_HasTransparentBackground(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HasTransparentBackground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::HasTransparentBackground() : sipCpp->HasTransparentBackground());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HasTransparentBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Refresh, "Refresh(eraseBackground=True, rect=None)\n"
"\n"
"Causes this window, and all of its children recursively, to be\n"
"repainted.");

extern "C" {static PyObject *meth_wxWindow_Refresh(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Refresh(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool eraseBackground = 1;
        const  ::wxRect* rect = 0;
        int rectState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eraseBackground,
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|bJ0", &sipSelf, sipType_wxWindow, &sipCpp, &eraseBackground, sipType_wxRect, &rect, &rectState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Refresh(eraseBackground,rect);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Refresh, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_RefreshRect, "RefreshRect(rect, eraseBackground=True)\n"
"\n"
"Redraws the contents of the given rectangle: only the area inside it\n"
"will be repainted.");

extern "C" {static PyObject *meth_wxWindow_RefreshRect(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_RefreshRect(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxRect* rect;
        int rectState = 0;
        bool eraseBackground = 1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rect,
            sipName_eraseBackground,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|b", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxRect, &rect, &rectState, &eraseBackground))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RefreshRect(*rect,eraseBackground);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect), sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_RefreshRect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Update, "Update()\n"
"\n"
"Calling this method immediately repaints the invalidated area of the\n"
"window and all of its children recursively (this normally only happens\n"
"when the flow of control returns to the event loop).");

extern "C" {static PyObject *meth_wxWindow_Update(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Update(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Update();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Update, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetBackgroundColour, "SetBackgroundColour(colour) -> bool\n"
"\n"
"Sets the background colour of the window.");

extern "C" {static PyObject *meth_wxWindow_SetBackgroundColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetBackgroundColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetBackgroundColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetBackgroundStyle, "SetBackgroundStyle(style) -> bool\n"
"\n"
"Sets the background style of the window.");

extern "C" {static PyObject *meth_wxWindow_SetBackgroundStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetBackgroundStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxBackgroundStyle style;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxBackgroundStyle, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetBackgroundStyle(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetBackgroundStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsTransparentBackgroundSupported, "IsTransparentBackgroundSupported(reason=None) -> bool\n"
"\n"
"Checks whether using transparent background might work.");

extern "C" {static PyObject *meth_wxWindow_IsTransparentBackgroundSupported(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsTransparentBackgroundSupported(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxString* reason = 0;
        int reasonState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_reason,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|J0", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxString, &reason, &reasonState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsTransparentBackgroundSupported(reason);
            Py_END_ALLOW_THREADS
            sipReleaseType(reason, sipType_wxString, reasonState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsTransparentBackgroundSupported, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetFont, "SetFont(font) -> bool\n"
"\n"
"Sets the font for this window.");

extern "C" {static PyObject *meth_wxWindow_SetFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxFont* font;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxFont, &font))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetFont(*font);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetForegroundColour, "SetForegroundColour(colour) -> bool\n"
"\n"
"Sets the foreground colour of the window.");

extern "C" {static PyObject *meth_wxWindow_SetForegroundColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetForegroundColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetForegroundColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetForegroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetOwnBackgroundColour, "SetOwnBackgroundColour(colour)\n"
"\n"
"Sets the background colour of the window but prevents it from being\n"
"inherited by the children of this window.");

extern "C" {static PyObject *meth_wxWindow_SetOwnBackgroundColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetOwnBackgroundColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetOwnBackgroundColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetOwnBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_InheritsBackgroundColour, "InheritsBackgroundColour() -> bool\n"
"\n"
"Return true if this window inherits the background colour from its\n"
"parent.");

extern "C" {static PyObject *meth_wxWindow_InheritsBackgroundColour(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_InheritsBackgroundColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InheritsBackgroundColour();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_InheritsBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_UseBgCol, "UseBgCol() -> bool\n"
"\n"
"Return true if a background colour has been set for this window.");

extern "C" {static PyObject *meth_wxWindow_UseBgCol(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_UseBgCol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->UseBgCol();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_UseBgCol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_UseBackgroundColour, "UseBackgroundColour() -> bool\n"
"\n"
"Return true if a background colour has been set for this window.");

extern "C" {static PyObject *meth_wxWindow_UseBackgroundColour(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_UseBackgroundColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->UseBackgroundColour();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_UseBackgroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetOwnFont, "SetOwnFont(font)\n"
"\n"
"Sets the font of the window but prevents it from being inherited by\n"
"the children of this window.");

extern "C" {static PyObject *meth_wxWindow_SetOwnFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetOwnFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxFont* font;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxFont, &font))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetOwnFont(*font);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetOwnFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetOwnForegroundColour, "SetOwnForegroundColour(colour)\n"
"\n"
"Sets the foreground colour of the window but prevents it from being\n"
"inherited by the children of this window.");

extern "C" {static PyObject *meth_wxWindow_SetOwnForegroundColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetOwnForegroundColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxColour, &colour, &colourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetOwnForegroundColour(*colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour), sipType_wxColour, colourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetOwnForegroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_UseForegroundColour, "UseForegroundColour() -> bool\n"
"\n"
"Return true if a foreground colour has been set for this window.");

extern "C" {static PyObject *meth_wxWindow_UseForegroundColour(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_UseForegroundColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->UseForegroundColour();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_UseForegroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_InheritsForegroundColour, "InheritsForegroundColour() -> bool\n"
"\n"
"Return true if this window inherits the foreground colour from its\n"
"parent.");

extern "C" {static PyObject *meth_wxWindow_InheritsForegroundColour(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_InheritsForegroundColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InheritsForegroundColour();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_InheritsForegroundColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetPalette, "SetPalette(pal)");

extern "C" {static PyObject *meth_wxWindow_SetPalette(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetPalette(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPalette* pal;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pal,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPalette, &pal))
        {
            if (sipDeprecated(sipName_Window,sipName_SetPalette) < 0)
                return SIP_NULLPTR;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPalette(*pal);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetPalette, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ShouldInheritColours, "ShouldInheritColours() -> bool\n"
"\n"
"Return true from here to allow the colours of this window to be\n"
"changed by InheritAttributes().");

extern "C" {static PyObject *meth_wxWindow_ShouldInheritColours(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ShouldInheritColours(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::ShouldInheritColours() : sipCpp->ShouldInheritColours());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ShouldInheritColours, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetThemeEnabled, "SetThemeEnabled(enable)\n"
"\n"
"This function tells a window if it should use the system's \"theme\"\n"
"code to draw the windows' background instead of its own background\n"
"drawing code.");

extern "C" {static PyObject *meth_wxWindow_SetThemeEnabled(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetThemeEnabled(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxWindow, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetThemeEnabled(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetThemeEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetThemeEnabled, "GetThemeEnabled() -> bool\n"
"\n"
"Returns true if the window uses the system theme for drawing its\n"
"background.");

extern "C" {static PyObject *meth_wxWindow_GetThemeEnabled(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetThemeEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetThemeEnabled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetThemeEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_CanSetTransparent, "CanSetTransparent() -> bool\n"
"\n"
"Returns true if the system supports transparent windows and calling\n"
"SetTransparent() may succeed.");

extern "C" {static PyObject *meth_wxWindow_CanSetTransparent(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_CanSetTransparent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CanSetTransparent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_CanSetTransparent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetTransparent, "SetTransparent(alpha) -> bool\n"
"\n"
"Set the transparency of the window.");

extern "C" {static PyObject *meth_wxWindow_SetTransparent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetTransparent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxByte alpha;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BM", &sipSelf, sipType_wxWindow, &sipCpp, &alpha))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetTransparent(alpha);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetTransparent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetEventHandler, "GetEventHandler() -> EvtHandler\n"
"\n"
"Returns the event handler for this window.");

extern "C" {static PyObject *meth_wxWindow_GetEventHandler(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetEventHandler(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxEvtHandler*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetEventHandler();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxEvtHandler,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetEventHandler, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HandleAsNavigationKey, "HandleAsNavigationKey(event) -> bool\n"
"\n"
"This function will generate the appropriate call to Navigate() if the\n"
"key event is one normally used for keyboard navigation and return true\n"
"in this case.");

extern "C" {static PyObject *meth_wxWindow_HandleAsNavigationKey(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HandleAsNavigationKey(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxKeyEvent* event;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxKeyEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HandleAsNavigationKey(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HandleAsNavigationKey, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HandleWindowEvent, "HandleWindowEvent(event) -> bool\n"
"\n"
"Shorthand for:");

extern "C" {static PyObject *meth_wxWindow_HandleWindowEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HandleWindowEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEvent* event;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HandleWindowEvent(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HandleWindowEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ProcessWindowEvent, "ProcessWindowEvent(event) -> bool\n"
"\n"
"Convenient wrapper for ProcessEvent().");

extern "C" {static PyObject *meth_wxWindow_ProcessWindowEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ProcessWindowEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEvent* event;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ProcessWindowEvent(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ProcessWindowEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ProcessWindowEventLocally, "ProcessWindowEventLocally(event) -> bool\n"
"\n"
"Wrapper for wxEvtHandler::ProcessEventLocally().");

extern "C" {static PyObject *meth_wxWindow_ProcessWindowEventLocally(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ProcessWindowEventLocally(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEvent* event;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ProcessWindowEventLocally(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ProcessWindowEventLocally, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_PopEventHandler, "PopEventHandler(deleteHandler=False) -> EvtHandler\n"
"\n"
"Removes and returns the top-most event handler on the event handler\n"
"stack.");

extern "C" {static PyObject *meth_wxWindow_PopEventHandler(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_PopEventHandler(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool deleteHandler = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_deleteHandler,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxWindow, &sipCpp, &deleteHandler))
        {
             ::wxEvtHandler*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PopEventHandler(deleteHandler);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxEvtHandler,Py_None);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_PopEventHandler, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_PushEventHandler, "PushEventHandler(handler)\n"
"\n"
"Pushes this event handler onto the event stack for the window.");

extern "C" {static PyObject *meth_wxWindow_PushEventHandler(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_PushEventHandler(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEvtHandler* handler;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_handler,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvtHandler, &handler))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PushEventHandler(handler);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_PushEventHandler, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_RemoveEventHandler, "RemoveEventHandler(handler) -> bool\n"
"\n"
"Find the given handler in the windows event handler stack and removes\n"
"(but does not delete) it from the stack.");

extern "C" {static PyObject *meth_wxWindow_RemoveEventHandler(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_RemoveEventHandler(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEvtHandler* handler;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_handler,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ<", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvtHandler, &handler))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->RemoveEventHandler(handler);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_RemoveEventHandler, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetEventHandler, "SetEventHandler(handler)\n"
"\n"
"Sets the event handler for this window.");

extern "C" {static PyObject *meth_wxWindow_SetEventHandler(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetEventHandler(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEvtHandler* handler;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_handler,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvtHandler, &handler))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetEventHandler(handler);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetEventHandler, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetNextHandler, "SetNextHandler(handler)\n"
"\n"
"wxWindows cannot be used to form event handler chains; this function\n"
"thus will assert when called.");

extern "C" {static PyObject *meth_wxWindow_SetNextHandler(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetNextHandler(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEvtHandler* handler;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_handler,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvtHandler, &handler))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetNextHandler(handler);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetNextHandler, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetPreviousHandler, "SetPreviousHandler(handler)\n"
"\n"
"wxWindows cannot be used to form event handler chains; this function\n"
"thus will assert when called.");

extern "C" {static PyObject *meth_wxWindow_SetPreviousHandler(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetPreviousHandler(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxEvtHandler* handler;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_handler,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvtHandler, &handler))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPreviousHandler(handler);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetPreviousHandler, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetExtraStyle, "GetExtraStyle() -> long\n"
"\n"
"Returns the extra style bits for the window.");

extern "C" {static PyObject *meth_wxWindow_GetExtraStyle(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetExtraStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetExtraStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetExtraStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetWindowStyleFlag, "GetWindowStyleFlag() -> long\n"
"\n"
"Gets the window style that was passed to the constructor or Create()\n"
"method.");

extern "C" {static PyObject *meth_wxWindow_GetWindowStyleFlag(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetWindowStyleFlag(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWindowStyleFlag();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetWindowStyleFlag, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetWindowStyle, "GetWindowStyle() -> long\n"
"\n"
"See GetWindowStyleFlag() for more info.");

extern "C" {static PyObject *meth_wxWindow_GetWindowStyle(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetWindowStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWindowStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetWindowStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HasExtraStyle, "HasExtraStyle(exFlag) -> bool\n"
"\n"
"Returns true if the window has the given exFlag bit set in its extra\n"
"styles.");

extern "C" {static PyObject *meth_wxWindow_HasExtraStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HasExtraStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int exFlag;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_exFlag,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &exFlag))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasExtraStyle(exFlag);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HasExtraStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HasFlag, "HasFlag(flag) -> bool\n"
"\n"
"Returns true if the window has the given flag bit set.");

extern "C" {static PyObject *meth_wxWindow_HasFlag(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HasFlag(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flag;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flag,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &flag))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasFlag(flag);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HasFlag, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetExtraStyle, "SetExtraStyle(exStyle)\n"
"\n"
"Sets the extra style bits for the window.");

extern "C" {static PyObject *meth_wxWindow_SetExtraStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetExtraStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long exStyle;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_exStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxWindow, &sipCpp, &exStyle))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetExtraStyle(exStyle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetExtraStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetWindowStyleFlag, "SetWindowStyleFlag(style)\n"
"\n"
"Sets the style of the window.");

extern "C" {static PyObject *meth_wxWindow_SetWindowStyleFlag(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetWindowStyleFlag(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long style;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxWindow, &sipCpp, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWindowStyleFlag(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetWindowStyleFlag, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetWindowStyle, "SetWindowStyle(style)\n"
"\n"
"See SetWindowStyleFlag() for more info.");

extern "C" {static PyObject *meth_wxWindow_SetWindowStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetWindowStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long style;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxWindow, &sipCpp, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWindowStyle(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetWindowStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ToggleWindowStyle, "ToggleWindowStyle(flag) -> bool\n"
"\n"
"Turns the given flag on if it's currently turned off and vice versa.");

extern "C" {static PyObject *meth_wxWindow_ToggleWindowStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ToggleWindowStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flag;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flag,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &flag))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ToggleWindowStyle(flag);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ToggleWindowStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_MoveAfterInTabOrder, "MoveAfterInTabOrder(win)\n"
"\n"
"Moves this window in the tab navigation order after the specified win.");

extern "C" {static PyObject *meth_wxWindow_MoveAfterInTabOrder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_MoveAfterInTabOrder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* win;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_win,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindow, &win))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MoveAfterInTabOrder(win);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_MoveAfterInTabOrder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_MoveBeforeInTabOrder, "MoveBeforeInTabOrder(win)\n"
"\n"
"Same as MoveAfterInTabOrder() except that it inserts this window just\n"
"before win instead of putting it right after it.");

extern "C" {static PyObject *meth_wxWindow_MoveBeforeInTabOrder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_MoveBeforeInTabOrder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* win;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_win,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindow, &win))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MoveBeforeInTabOrder(win);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_MoveBeforeInTabOrder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Navigate, "Navigate(flags=NavigationKeyEvent.IsForward) -> bool\n"
"\n"
"Performs a keyboard navigation action starting from this window.");

extern "C" {static PyObject *meth_wxWindow_Navigate(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Navigate(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = wxNavigationKeyEvent::IsForward;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxWindow, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Navigate(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Navigate, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_NavigateIn, "NavigateIn(flags=NavigationKeyEvent.IsForward) -> bool\n"
"\n"
"Performs a keyboard navigation action inside this window.");

extern "C" {static PyObject *meth_wxWindow_NavigateIn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_NavigateIn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags = wxNavigationKeyEvent::IsForward;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxWindow, &sipCpp, &flags))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->NavigateIn(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_NavigateIn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Lower, "Lower()\n"
"\n"
"Lowers the window to the bottom of the window hierarchy (Z-order).");

extern "C" {static PyObject *meth_wxWindow_Lower(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Lower(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Lower();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Lower, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Raise, "Raise()\n"
"\n"
"Raises the window to the top of the window hierarchy (Z-order).");

extern "C" {static PyObject *meth_wxWindow_Raise(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Raise(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Raise();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Raise, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Hide, "Hide() -> bool\n"
"\n"
"Equivalent to calling wxWindow::Show(false).");

extern "C" {static PyObject *meth_wxWindow_Hide(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Hide(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Hide();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Hide, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HideWithEffect, "HideWithEffect(effect, timeout=0) -> bool\n"
"\n"
"This function hides a window, like Hide(), but using a special visual\n"
"effect if possible.");

extern "C" {static PyObject *meth_wxWindow_HideWithEffect(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HideWithEffect(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxShowEffect effect;
        uint timeout = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_effect,
            sipName_timeout,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE|u", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxShowEffect, &effect, &timeout))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HideWithEffect(effect,timeout);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HideWithEffect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsEnabled, "IsEnabled() -> bool\n"
"\n"
"Returns true if the window is enabled, i.e. if it accepts user input,\n"
"false otherwise.");

extern "C" {static PyObject *meth_wxWindow_IsEnabled(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEnabled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsExposed, "IsExposed(x, y) -> bool\n"
"IsExposed(pt) -> bool\n"
"IsExposed(x, y, w, h) -> bool\n"
"IsExposed(rect) -> bool\n"
"\n"
"Returns true if the given point or rectangle area has been exposed\n"
"since the last repaint.\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxWindow_IsExposed(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsExposed(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsExposed(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsExposed(*pt);
            Py_END_ALLOW_THREADS
            sipReleaseType(pt, sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        int x;
        int y;
        int w;
        int h;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_w,
            sipName_h,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y, &w, &h))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsExposed(x,y,w,h);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxRect* rect;
        int rectState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxRect, &rect, &rectState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsExposed(*rect);
            Py_END_ALLOW_THREADS
            sipReleaseType(rect, sipType_wxRect, rectState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsExposed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsShown, "IsShown() -> bool\n"
"\n"
"Returns true if the window is shown, false if it has been hidden.");

extern "C" {static PyObject *meth_wxWindow_IsShown(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsShown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsShown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsShown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsShownOnScreen, "IsShownOnScreen() -> bool\n"
"\n"
"Returns true if the window is physically visible on the screen, i.e.\n"
"it is shown and all its parents up to the toplevel window are shown as\n"
"well.");

extern "C" {static PyObject *meth_wxWindow_IsShownOnScreen(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsShownOnScreen(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsShownOnScreen();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsShownOnScreen, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Disable, "Disable() -> bool\n"
"\n"
"Disables the window.");

extern "C" {static PyObject *meth_wxWindow_Disable(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Disable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Disable();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Disable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Enable, "Enable(enable=True) -> bool\n"
"\n"
"Enable or disable the window for user input.");

extern "C" {static PyObject *meth_wxWindow_Enable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Enable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enable = 1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxWindow, &sipCpp, &enable))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Enable(enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Enable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Show, "Show(show=True) -> bool\n"
"\n"
"Shows or hides the window.");

extern "C" {static PyObject *meth_wxWindow_Show(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Show(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool show = 1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_show,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxWindow, &sipCpp, &show))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Show(show);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Show, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ShowWithEffect, "ShowWithEffect(effect, timeout=0) -> bool\n"
"\n"
"This function shows a window, like Show(), but using a special visual\n"
"effect if possible.");

extern "C" {static PyObject *meth_wxWindow_ShowWithEffect(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ShowWithEffect(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxShowEffect effect;
        uint timeout = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_effect,
            sipName_timeout,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE|u", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxShowEffect, &effect, &timeout))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ShowWithEffect(effect,timeout);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ShowWithEffect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetHelpText, "GetHelpText() -> String\n"
"\n"
"Gets the help text to be used as context-sensitive help for this\n"
"window.");

extern "C" {static PyObject *meth_wxWindow_GetHelpText(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetHelpText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetHelpText());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetHelpText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetHelpText, "SetHelpText(helpText)\n"
"\n"
"Sets the help text to be used as context-sensitive help for this\n"
"window.");

extern "C" {static PyObject *meth_wxWindow_SetHelpText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetHelpText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* helpText;
        int helpTextState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_helpText,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxString, &helpText, &helpTextState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHelpText(*helpText);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(helpText), sipType_wxString, helpTextState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetHelpText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetHelpTextAtPoint, "GetHelpTextAtPoint(point, origin) -> String\n"
"\n"
"Gets the help text to be used as context-sensitive help for this\n"
"window.");

extern "C" {static PyObject *meth_wxWindow_GetHelpTextAtPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetHelpTextAtPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* point;
        int pointState = 0;
         ::wxHelpEvent::Origin origin;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_point,
            sipName_origin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1E", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &point, &pointState, sipType_wxHelpEvent_Origin, &origin))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetHelpTextAtPoint(*point,origin));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(point), sipType_wxPoint, pointState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetHelpTextAtPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetToolTip, "GetToolTip() -> ToolTip\n"
"\n"
"Get the associated tooltip or NULL if none.");

extern "C" {static PyObject *meth_wxWindow_GetToolTip(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetToolTip(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxToolTip*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetToolTip();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxToolTip,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetToolTip, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetToolTipText, "GetToolTipText() -> String\n"
"\n"
"Get the text of the associated tooltip or empty string if none.");

extern "C" {static PyObject *meth_wxWindow_GetToolTipText(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetToolTipText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetToolTipText());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetToolTipText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetToolTip, "SetToolTip(tipString)\n"
"SetToolTip(tip)\n"
"\n"
"Attach a tooltip to the window.\n"
"");

extern "C" {static PyObject *meth_wxWindow_SetToolTip(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetToolTip(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* tipString;
        int tipStringState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_tipString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxString, &tipString, &tipStringState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetToolTip(*tipString);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(tipString), sipType_wxString, tipStringState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::wxToolTip* tip;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_tip,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxToolTip, &tip))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetToolTip(tip);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetToolTip, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_UnsetToolTip, "UnsetToolTip()\n"
"\n"
"Unset any existing tooltip.");

extern "C" {static PyObject *meth_wxWindow_UnsetToolTip(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_UnsetToolTip(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->UnsetToolTip();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_UnsetToolTip, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetPopupMenuSelectionFromUser, "GetPopupMenuSelectionFromUser(menu, pos=DefaultPosition) -> int\n"
"GetPopupMenuSelectionFromUser(menu, x, y) -> int\n"
"\n"
"This function shows a popup menu at the given position in this window\n"
"and returns the selected id.\n"
"");

extern "C" {static PyObject *meth_wxWindow_GetPopupMenuSelectionFromUser(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetPopupMenuSelectionFromUser(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMenu* menu;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menu,
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9|J1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxMenu, &menu, sipType_wxPoint, &pos, &posState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPopupMenuSelectionFromUser(*menu,*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    {
         ::wxMenu* menu;
        int x;
        int y;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menu,
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9ii", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxMenu, &menu, &x, &y))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPopupMenuSelectionFromUser(*menu,x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetPopupMenuSelectionFromUser, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_PopupMenu, "PopupMenu(menu, pos=DefaultPosition) -> bool\n"
"PopupMenu(menu, x, y) -> bool\n"
"\n"
"Pops up the given menu at the specified coordinates, relative to this\n"
"window, and returns control when the user has dismissed the menu.\n"
"");

extern "C" {static PyObject *meth_wxWindow_PopupMenu(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_PopupMenu(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxMenu* menu;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menu,
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|J1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxMenu, &menu, sipType_wxPoint, &pos, &posState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PopupMenu(menu,*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxMenu* menu;
        int x;
        int y;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menu,
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8ii", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxMenu, &menu, &x, &y))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PopupMenu(menu,x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_PopupMenu, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetValidator, "GetValidator() -> Validator\n"
"\n"
"Validator functions.");

extern "C" {static PyObject *meth_wxWindow_GetValidator(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetValidator(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxValidator*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::GetValidator() : sipCpp->GetValidator());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxValidator,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetValidator, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetValidator, "SetValidator(validator)\n"
"\n"
"Deletes the current validator (if any) and sets the window validator,\n"
"having called wxValidator::Clone to create a new validator of this\n"
"type.");

extern "C" {static PyObject *meth_wxWindow_SetValidator(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetValidator(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxValidator* validator;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_validator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxValidator, &validator))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxWindow::SetValidator(*validator) : sipCpp->SetValidator(*validator));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetValidator, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_TransferDataFromWindow, "TransferDataFromWindow() -> bool\n"
"\n"
"Transfers values from child controls to data areas specified by their\n"
"validators.");

extern "C" {static PyObject *meth_wxWindow_TransferDataFromWindow(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_TransferDataFromWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::TransferDataFromWindow() : sipCpp->TransferDataFromWindow());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_TransferDataFromWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_TransferDataToWindow, "TransferDataToWindow() -> bool\n"
"\n"
"Transfers values to child controls from data areas specified by their\n"
"validators.");

extern "C" {static PyObject *meth_wxWindow_TransferDataToWindow(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_TransferDataToWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::TransferDataToWindow() : sipCpp->TransferDataToWindow());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_TransferDataToWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Validate, "Validate() -> bool\n"
"\n"
"Validates the current values of the child controls using their\n"
"validators.");

extern "C" {static PyObject *meth_wxWindow_Validate(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Validate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::Validate() : sipCpp->Validate());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Validate, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetId, "GetId() -> WindowID\n"
"\n"
"Returns the identifier of the window.");

extern "C" {static PyObject *meth_wxWindow_GetId(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetId(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindowID sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetId();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetId, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetLabel, "GetLabel() -> String\n"
"\n"
"Generic way of getting a label from any window, for identification\n"
"purposes.");

extern "C" {static PyObject *meth_wxWindow_GetLabel(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetLabel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLabel());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetLabel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetLayoutDirection, "GetLayoutDirection() -> LayoutDirection\n"
"\n"
"Returns the layout direction for this window, Note that\n"
"wxLayout_Default is returned if layout direction is not supported.");

extern "C" {static PyObject *meth_wxWindow_GetLayoutDirection(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetLayoutDirection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxLayoutDirection sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLayoutDirection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxLayoutDirection);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetLayoutDirection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_AdjustForLayoutDirection, "AdjustForLayoutDirection(x, width, widthTotal) -> Coord\n"
"\n"
"Mirror coordinates for RTL layout if this window uses it and if the\n"
"mirroring is not done automatically like Win32.");

extern "C" {static PyObject *meth_wxWindow_AdjustForLayoutDirection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_AdjustForLayoutDirection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCoord x;
         ::wxCoord width;
         ::wxCoord widthTotal;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_width,
            sipName_widthTotal,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &width, &widthTotal))
        {
             ::wxCoord sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AdjustForLayoutDirection(x,width,widthTotal);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_AdjustForLayoutDirection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetName, "GetName() -> String\n"
"\n"
"Returns the window's name.");

extern "C" {static PyObject *meth_wxWindow_GetName(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetName());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetWindowVariant, "GetWindowVariant() -> WindowVariant\n"
"\n"
"Returns the value previously passed to SetWindowVariant().");

extern "C" {static PyObject *meth_wxWindow_GetWindowVariant(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetWindowVariant(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindowVariant sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWindowVariant();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxWindowVariant);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetWindowVariant, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetId, "SetId(winid)\n"
"\n"
"Sets the identifier of the window.");

extern "C" {static PyObject *meth_wxWindow_SetId(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetId(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindowID winid;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_winid,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &winid))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetId(winid);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetId, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetLabel, "SetLabel(label)\n"
"\n"
"Sets the window's label.");

extern "C" {static PyObject *meth_wxWindow_SetLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* label;
        int labelState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_label,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxString, &label, &labelState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLabel(*label);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(label), sipType_wxString, labelState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetLabel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetLayoutDirection, "SetLayoutDirection(dir)\n"
"\n"
"Sets the layout direction for this window.");

extern "C" {static PyObject *meth_wxWindow_SetLayoutDirection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetLayoutDirection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxLayoutDirection dir;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dir,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxLayoutDirection, &dir))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLayoutDirection(dir);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetLayoutDirection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetName, "SetName(name)\n"
"\n"
"Sets the window's name.");

extern "C" {static PyObject *meth_wxWindow_SetName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetName(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxString, &name, &nameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetName(*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetWindowVariant, "SetWindowVariant(variant)\n"
"\n"
"Chooses a different variant of the window display to use.");

extern "C" {static PyObject *meth_wxWindow_SetWindowVariant(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetWindowVariant(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindowVariant variant;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindowVariant, &variant))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWindowVariant(variant);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetWindowVariant, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetAcceleratorTable, "GetAcceleratorTable() -> AcceleratorTable\n"
"\n"
"Gets the accelerator table for this window.");

extern "C" {static PyObject *meth_wxWindow_GetAcceleratorTable(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetAcceleratorTable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxAcceleratorTable*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAcceleratorTable();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxAcceleratorTable,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetAcceleratorTable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetAccessible, "GetAccessible() -> Accessible\n"
"\n"
"Returns the accessible object for this window, if any.");

extern "C" {static PyObject *meth_wxWindow_GetAccessible(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetAccessible(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxAccessible*sipRes = 0;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxWindow_GetAccessible(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxAccessible,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetAccessible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetAcceleratorTable, "SetAcceleratorTable(accel)\n"
"\n"
"Sets the accelerator table for this window.");

extern "C" {static PyObject *meth_wxWindow_SetAcceleratorTable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetAcceleratorTable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxAcceleratorTable* accel;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_accel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxAcceleratorTable, &accel))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAcceleratorTable(*accel);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetAcceleratorTable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetAccessible, "SetAccessible(accessible)\n"
"\n"
"Sets the accessible for this window.");

extern "C" {static PyObject *meth_wxWindow_SetAccessible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetAccessible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxAccessible* accessible;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_accessible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxAccessible, &accessible))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxWindow_SetAccessible(sipCpp, accessible);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetAccessible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Close, "Close(force=False) -> bool\n"
"\n"
"This function simply generates a wxCloseEvent whose handler usually\n"
"tries to close the window.");

extern "C" {static PyObject *meth_wxWindow_Close(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Close(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool force = 0;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_force,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxWindow, &sipCpp, &force))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Close(force);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Close, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Destroy, "Destroy() -> bool\n"
"\n"
"Destroys the window safely.");

extern "C" {static PyObject *meth_wxWindow_Destroy(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Destroy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::Destroy() : sipCpp->Destroy());
            Py_END_ALLOW_THREADS

            sipTransferTo(sipSelf, SIP_NULLPTR);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Destroy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsBeingDeleted, "IsBeingDeleted() -> bool\n"
"\n"
"Returns true if this window is in process of being destroyed.");

extern "C" {static PyObject *meth_wxWindow_IsBeingDeleted(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsBeingDeleted(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsBeingDeleted();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsBeingDeleted, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetDropTarget, "GetDropTarget() -> DropTarget\n"
"\n"
"Returns the associated drop target, which may be NULL.");

extern "C" {static PyObject *meth_wxWindow_GetDropTarget(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetDropTarget(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxDropTarget*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDropTarget();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDropTarget,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetDropTarget, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetDropTarget, "SetDropTarget(target)\n"
"\n"
"Associates a drop target with this window.");

extern "C" {static PyObject *meth_wxWindow_SetDropTarget(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetDropTarget(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxDropTarget* target;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_target,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxDropTarget, &target))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDropTarget(target);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetDropTarget, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DragAcceptFiles, "DragAcceptFiles(accept)\n"
"\n"
"Enables or disables eligibility for drop file events (OnDropFiles).");

extern "C" {static PyObject *meth_wxWindow_DragAcceptFiles(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DragAcceptFiles(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool accept;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_accept,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxWindow, &sipCpp, &accept))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DragAcceptFiles(accept);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DragAcceptFiles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetContainingSizer, "GetContainingSizer() -> Sizer\n"
"\n"
"Returns the sizer of which this window is a member, if any, otherwise\n"
"NULL.");

extern "C" {static PyObject *meth_wxWindow_GetContainingSizer(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetContainingSizer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSizer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetContainingSizer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetContainingSizer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetSizer, "GetSizer() -> Sizer\n"
"\n"
"Returns the sizer associated with the window by a previous call to\n"
"SetSizer(), or NULL.");

extern "C" {static PyObject *meth_wxWindow_GetSizer(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetSizer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSizer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSizer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetSizer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetSizer, "SetSizer(sizer, deleteOld=True)\n"
"\n"
"Sets the window to have the given layout sizer.");

extern "C" {static PyObject *meth_wxWindow_SetSizer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetSizer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSizer* sizer;
        bool deleteOld = 1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_deleteOld,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:|b", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSizer, &sizer, &deleteOld))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSizer(sizer,deleteOld);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetSizer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetSizerAndFit, "SetSizerAndFit(sizer, deleteOld=True)\n"
"\n"
"Associate the sizer with the window and set the window size and\n"
"minimal size accordingly.");

extern "C" {static PyObject *meth_wxWindow_SetSizerAndFit(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetSizerAndFit(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSizer* sizer;
        bool deleteOld = 1;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_deleteOld,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:|b", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxSizer, &sizer, &deleteOld))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSizerAndFit(sizer,deleteOld);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetSizerAndFit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetConstraints, "GetConstraints() -> LayoutConstraints\n"
"\n"
"Returns a pointer to the window's layout constraints, or NULL if there\n"
"are none.");

extern "C" {static PyObject *meth_wxWindow_GetConstraints(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetConstraints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxLayoutConstraints*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetConstraints();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxLayoutConstraints,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetConstraints, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetConstraints, "SetConstraints(constraints)\n"
"\n"
"Sets the window to have the given layout constraints.");

extern "C" {static PyObject *meth_wxWindow_SetConstraints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetConstraints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxLayoutConstraints* constraints;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_constraints,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxLayoutConstraints, &constraints))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetConstraints(constraints);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetConstraints, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Layout, "Layout() -> bool\n"
"\n"
"Lays out the children of this window using the associated sizer.");

extern "C" {static PyObject *meth_wxWindow_Layout(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Layout(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Layout();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Layout, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetAutoLayout, "SetAutoLayout(autoLayout)\n"
"\n"
"Determines whether the Layout() function will be called automatically\n"
"when the window is resized.");

extern "C" {static PyObject *meth_wxWindow_SetAutoLayout(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetAutoLayout(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool autoLayout;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_autoLayout,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxWindow, &sipCpp, &autoLayout))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAutoLayout(autoLayout);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetAutoLayout, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetAutoLayout, "GetAutoLayout() -> bool\n"
"\n"
"Returns true if Layout() is called automatically when the window is\n"
"resized.");

extern "C" {static PyObject *meth_wxWindow_GetAutoLayout(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetAutoLayout(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAutoLayout();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetAutoLayout, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_CaptureMouse, "CaptureMouse()\n"
"\n"
"Directs all mouse input to this window.");

extern "C" {static PyObject *meth_wxWindow_CaptureMouse(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_CaptureMouse(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CaptureMouse();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_CaptureMouse, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetCaret, "GetCaret() -> Caret\n"
"\n"
"Returns the caret() associated with the window.");

extern "C" {static PyObject *meth_wxWindow_GetCaret(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetCaret(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxCaret*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaret();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxCaret,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetCursor, "GetCursor() -> Cursor\n"
"\n"
"Return the cursor associated with this window.");

extern "C" {static PyObject *meth_wxWindow_GetCursor(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetCursor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxCursor*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCursor(sipCpp->GetCursor());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxCursor,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HasCapture, "HasCapture() -> bool\n"
"\n"
"Returns true if this window has the current mouse capture.");

extern "C" {static PyObject *meth_wxWindow_HasCapture(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HasCapture(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasCapture();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HasCapture, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ReleaseMouse, "ReleaseMouse()\n"
"\n"
"Releases mouse input captured with CaptureMouse().");

extern "C" {static PyObject *meth_wxWindow_ReleaseMouse(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ReleaseMouse(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ReleaseMouse();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ReleaseMouse, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetCaret, "SetCaret(caret)\n"
"\n"
"Sets the caret() associated with the window.");

extern "C" {static PyObject *meth_wxWindow_SetCaret(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetCaret(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCaret* caret;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caret,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxCaret, &caret))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaret(caret);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetCursor, "SetCursor(cursor) -> bool\n"
"\n"
"Sets the window's cursor.");

extern "C" {static PyObject *meth_wxWindow_SetCursor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetCursor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxCursor* cursor;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cursor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxCursor, &cursor))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetCursor(*cursor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_WarpPointer, "WarpPointer(x, y)\n"
"\n"
"Moves the pointer to the given position on the window.");

extern "C" {static PyObject *meth_wxWindow_WarpPointer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_WarpPointer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WarpPointer(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_WarpPointer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_EnableTouchEvents, "EnableTouchEvents(eventsMask) -> bool\n"
"\n"
"Request generation of touch events for this window.");

extern "C" {static PyObject *meth_wxWindow_EnableTouchEvents(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_EnableTouchEvents(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int eventsMask;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eventsMask,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &eventsMask))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->EnableTouchEvents(eventsMask);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_EnableTouchEvents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HitTest, "HitTest(x, y) -> HitTest\n"
"HitTest(pt) -> HitTest\n"
"\n"
"Return where the given point lies, exactly.\n"
"");

extern "C" {static PyObject *meth_wxWindow_HitTest(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HitTest(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCoord x;
         ::wxCoord y;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y))
        {
             ::wxHitTest sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HitTest(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxHitTest);
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxHitTest sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HitTest(*pt);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxHitTest);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HitTest, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetBorder, "GetBorder(flags) -> Border\n"
"GetBorder() -> Border\n"
"\n"
"Get the window border style from the given flags: this is different\n"
"from simply doing flags & wxBORDER_MASK because it uses\n"
"GetDefaultBorder() to translate wxBORDER_DEFAULT to something\n"
"reasonable.\n"
"");

extern "C" {static PyObject *meth_wxWindow_GetBorder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetBorder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long flags;
        const  ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxWindow, &sipCpp, &flags))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetBorder(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    {
        const  ::wxWindow *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetBorder();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetBorder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoUpdateWindowUI, "DoUpdateWindowUI(event)\n"
"\n"
"Does the window-specific updating after processing the update event.");

extern "C" {static PyObject *meth_wxWindow_DoUpdateWindowUI(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoUpdateWindowUI(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxUpdateUIEvent* event;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxUpdateUIEvent, &event))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DoUpdateWindowUI(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoUpdateWindowUI, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetHandle, "GetHandle() -> UIntPtr\n"
"\n"
"Returns the platform-specific handle of the physical window.");

extern "C" {static PyObject *meth_wxWindow_GetHandle(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetHandle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxUIntPtr*sipRes = 0;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxWindow_GetHandle(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxUIntPtr,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetHandle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_HasMultiplePages, "HasMultiplePages() -> bool\n"
"\n"
"This method should be overridden to return true if this window has\n"
"multiple pages.");

extern "C" {static PyObject *meth_wxWindow_HasMultiplePages(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_HasMultiplePages(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasMultiplePages();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_HasMultiplePages, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_InheritAttributes, "InheritAttributes()\n"
"\n"
"This function is (or should be, in case of custom controls) called\n"
"during window creation to intelligently set up the window visual\n"
"attributes, that is the font and the foreground and background\n"
"colours.");

extern "C" {static PyObject *meth_wxWindow_InheritAttributes(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_InheritAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxWindow::InheritAttributes() : sipCpp->InheritAttributes());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_InheritAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_InitDialog, "InitDialog()\n"
"\n"
"Sends an wxEVT_INIT_DIALOG event, whose handler usually transfers data\n"
"to the dialog via validators.");

extern "C" {static PyObject *meth_wxWindow_InitDialog(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_InitDialog(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxWindow::InitDialog() : sipCpp->InitDialog());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_InitDialog, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsDoubleBuffered, "IsDoubleBuffered() -> bool\n"
"\n"
"Returns true if the window contents is double-buffered by the system,\n"
"i.e. if any drawing done on the window is really done on a temporary\n"
"backing surface and transferred to the screen all at once later.");

extern "C" {static PyObject *meth_wxWindow_IsDoubleBuffered(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsDoubleBuffered(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsDoubleBuffered();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsDoubleBuffered, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetDoubleBuffered, "SetDoubleBuffered(on)\n"
"\n"
"Turn on or off double buffering of the window if the system supports\n"
"it.");

extern "C" {static PyObject *meth_wxWindow_SetDoubleBuffered(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetDoubleBuffered(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool on;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_on,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxWindow, &sipCpp, &on))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxWindow_SetDoubleBuffered(sipCpp, on);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetDoubleBuffered, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsRetained, "IsRetained() -> bool\n"
"\n"
"Returns true if the window is retained, false otherwise.");

extern "C" {static PyObject *meth_wxWindow_IsRetained(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsRetained(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsRetained();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsRetained, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsThisEnabled, "IsThisEnabled() -> bool\n"
"\n"
"Returns true if this window is intrinsically enabled, false otherwise,\n"
"i.e. if Enable() Enable(false) had been called.");

extern "C" {static PyObject *meth_wxWindow_IsThisEnabled(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsThisEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsThisEnabled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsThisEnabled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_IsTopLevel, "IsTopLevel() -> bool\n"
"\n"
"Returns true if the given window is a top-level one.");

extern "C" {static PyObject *meth_wxWindow_IsTopLevel(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_IsTopLevel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsTopLevel();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_IsTopLevel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_OnInternalIdle, "OnInternalIdle()\n"
"\n"
"This virtual function is normally only used internally, but sometimes\n"
"an application may need it to implement functionality that should not\n"
"be disabled by an application defining an OnIdle handler in a derived\n"
"class.");

extern "C" {static PyObject *meth_wxWindow_OnInternalIdle(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_OnInternalIdle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxWindow::OnInternalIdle() : sipCpp->OnInternalIdle());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_OnInternalIdle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SendIdleEvents, "SendIdleEvents(event) -> bool\n"
"\n"
"Send idle event to window and all subwindows.");

extern "C" {static PyObject *meth_wxWindow_SendIdleEvents(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SendIdleEvents(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxIdleEvent* event;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxIdleEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SendIdleEvents(*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SendIdleEvents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_RegisterHotKey, "RegisterHotKey(hotkeyId, modifiers, virtualKeyCode) -> bool\n"
"\n"
"Registers a system wide hotkey.");

extern "C" {static PyObject *meth_wxWindow_RegisterHotKey(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_RegisterHotKey(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int hotkeyId;
        int modifiers;
        int virtualKeyCode;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_hotkeyId,
            sipName_modifiers,
            sipName_virtualKeyCode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biii", &sipSelf, sipType_wxWindow, &sipCpp, &hotkeyId, &modifiers, &virtualKeyCode))
        {
            bool sipRes = 0;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxWindow_RegisterHotKey(sipCpp, hotkeyId, modifiers, virtualKeyCode);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_RegisterHotKey, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_UnregisterHotKey, "UnregisterHotKey(hotkeyId) -> bool\n"
"\n"
"Unregisters a system wide hotkey.");

extern "C" {static PyObject *meth_wxWindow_UnregisterHotKey(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_UnregisterHotKey(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int hotkeyId;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_hotkeyId,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxWindow, &sipCpp, &hotkeyId))
        {
            bool sipRes = 0;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxWindow_UnregisterHotKey(sipCpp, hotkeyId);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_UnregisterHotKey, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_UpdateWindowUI, "UpdateWindowUI(flags=UPDATE_UI_NONE)\n"
"\n"
"This function sends one or more wxUpdateUIEvent to the window.");

extern "C" {static PyObject *meth_wxWindow_UpdateWindowUI(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_UpdateWindowUI(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long flags = wxUPDATE_UI_NONE;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|l", &sipSelf, sipType_wxWindow, &sipCpp, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->UpdateWindowUI(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_UpdateWindowUI, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetClassDefaultAttributes, "GetClassDefaultAttributes(variant=WINDOW_VARIANT_NORMAL) -> VisualAttributes\n"
"\n"
"Returns the default font and colours which are used by the control.");

extern "C" {static PyObject *meth_wxWindow_GetClassDefaultAttributes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetClassDefaultAttributes(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "|E", sipType_wxWindowVariant, &variant))
        {
             ::wxVisualAttributes*sipRes;
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxVisualAttributes( ::wxWindow::GetClassDefaultAttributes(variant));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxVisualAttributes,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetClassDefaultAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_FindFocus, "FindFocus() -> Window\n"
"\n"
"Finds the window or control which currently has the keyboard focus.");

extern "C" {static PyObject *meth_wxWindow_FindFocus(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_FindFocus(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxWindow*sipRes;
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::FindFocus();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_FindFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_FindWindowById, "FindWindowById(id, parent=None) -> Window\n"
"\n"
"Find the first window with the given id.");

extern "C" {static PyObject *meth_wxWindow_FindWindowById(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_FindWindowById(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long id;
        const  ::wxWindow* parent = 0;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_parent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "l|J8", &id, sipType_wxWindow, &parent))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::FindWindowById(id,parent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_FindWindowById, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_FindWindowByLabel, "FindWindowByLabel(label, parent=None) -> Window\n"
"\n"
"Find a window by its label.");

extern "C" {static PyObject *meth_wxWindow_FindWindowByLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_FindWindowByLabel(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* label;
        int labelState = 0;
        const  ::wxWindow* parent = 0;

        static const char *sipKwdList[] = {
            sipName_label,
            sipName_parent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1|J8", sipType_wxString, &label, &labelState, sipType_wxWindow, &parent))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::FindWindowByLabel(*label,parent);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(label), sipType_wxString, labelState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_FindWindowByLabel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_FindWindowByName, "FindWindowByName(name, parent=None) -> Window\n"
"\n"
"Find a window by its name (as given in a window constructor or\n"
"Create() function call).");

extern "C" {static PyObject *meth_wxWindow_FindWindowByName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_FindWindowByName(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
        const  ::wxWindow* parent = 0;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_parent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1|J8", sipType_wxString, &name, &nameState, sipType_wxWindow, &parent))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::FindWindowByName(*name,parent);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_FindWindowByName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetCapture, "GetCapture() -> Window\n"
"\n"
"Returns the currently captured window.");

extern "C" {static PyObject *meth_wxWindow_GetCapture(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetCapture(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxWindow*sipRes;
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::GetCapture();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetCapture, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_NewControlId, "NewControlId(count=1) -> WindowID\n"
"\n"
"Create a new ID or range of IDs that are not currently in use.");

extern "C" {static PyObject *meth_wxWindow_NewControlId(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_NewControlId(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int count = 1;

        static const char *sipKwdList[] = {
            sipName_count,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "|i", &count))
        {
             ::wxWindowID sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxWindow::NewControlId(count);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_NewControlId, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_UnreserveControlId, "UnreserveControlId(id, count=1)\n"
"\n"
"Unreserve an ID or range of IDs that was reserved by NewControlId().");

extern "C" {static PyObject *meth_wxWindow_UnreserveControlId(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_UnreserveControlId(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindowID id;
        int count = 1;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_count,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "i|i", &id, &count))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
             ::wxWindow::UnreserveControlId(id,count);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_UnreserveControlId, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_Create, "Create(parent, id=ID_ANY, pos=DefaultPosition, size=DefaultSize, style=0, name=PanelNameStr) -> bool\n"
"\n"
"Construct the actual window object after creating the C++ object.");

extern "C" {static PyObject *meth_wxWindow_Create(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_Create(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* parent;
         ::wxWindowID id = wxID_ANY;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        long style = 0;
        const  ::wxString& namedef = wxPanelNameStr;
        const  ::wxString* name = &namedef;
        int nameState = 0;
        sipWrapper *sipOwner = SIP_NULLPTR;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_parent,
            sipName_id,
            sipName_pos,
            sipName_size,
            sipName_style,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJH|iJ1J1lJ1", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindow, &parent, &sipOwner, &id, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, &style, sipType_wxString, &name, &nameState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Create(parent,id,*pos,*size,style,*name);
            Py_END_ALLOW_THREADS

            if (sipOwner)
                sipTransferTo(sipSelf, (PyObject *)sipOwner);
            else
                sipTransferBack(sipSelf);
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_Create, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetGtkWidget, "GetGtkWidget() -> void");

extern "C" {static PyObject *meth_wxWindow_GetGtkWidget(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetGtkWidget(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            void*sipRes = 0;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxWindow_GetGtkWidget(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromVoidPtr(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetGtkWidget, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_AssociateHandle, "AssociateHandle(handle)\n"
"\n"
"Associate the window with a new native handle");

extern "C" {static PyObject *meth_wxWindow_AssociateHandle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_AssociateHandle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long handle;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_handle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxWindow, &sipCpp, &handle))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxWindow_AssociateHandle(sipCpp, handle);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_AssociateHandle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DissociateHandle, "DissociateHandle()\n"
"\n"
"Dissociate the current native handle from the window");

extern "C" {static PyObject *meth_wxWindow_DissociateHandle(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DissociateHandle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxWindow_DissociateHandle(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DissociateHandle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetTopLevelParent, "GetTopLevelParent() -> Window\n"
"\n"
"Returns the first ancestor of this window which is a top-level window.");

extern "C" {static PyObject *meth_wxWindow_GetTopLevelParent(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetTopLevelParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindow*sipRes = 0;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxWindow_GetTopLevelParent(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetTopLevelParent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_MacIsWindowScrollbar, "MacIsWindowScrollbar(sb)\n"
"\n"
"Is the given widget one of this window's built-in scrollbars?  Only\n"
"applicable on Mac.");

extern "C" {static PyObject *meth_wxWindow_MacIsWindowScrollbar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_MacIsWindowScrollbar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxWindow* sb;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sb,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindow, &sb))
        {
            bool sipRes = 0;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxWindow_MacIsWindowScrollbar(sipCpp, sb);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_MacIsWindowScrollbar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SetDimensions, "SetDimensions(x, y, width, height, sizeFlags=SIZE_AUTO)");

extern "C" {static PyObject *meth_wxWindow_SetDimensions(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SetDimensions(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        int width;
        int height;
        int sizeFlags = wxSIZE_AUTO;
         ::wxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
            sipName_sizeFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii|i", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y, &width, &height, &sizeFlags))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxWindow_SetDimensions(sipCpp, x, y, width, height, sizeFlags);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SetDimensions, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetMainWindowOfCompositeControl, "GetMainWindowOfCompositeControl(self) -> Window");

extern "C" {static PyObject *meth_wxWindow_GetMainWindowOfCompositeControl(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetMainWindowOfCompositeControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxWindow::GetMainWindowOfCompositeControl() : sipCpp->GetMainWindowOfCompositeControl());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetMainWindowOfCompositeControl, doc_wxWindow_GetMainWindowOfCompositeControl);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoEnable, "DoEnable(self, enable: bool)");

extern "C" {static PyObject *meth_wxWindow_DoEnable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoEnable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool enable;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxWindow, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoEnable(sipSelfWasArg,enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoEnable, doc_wxWindow_DoEnable);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoGetPosition, "DoGetPosition(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxWindow_DoGetPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoGetPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        const sipwxWindow *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetPosition(sipSelfWasArg,&x,&y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",x,y);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoGetPosition, doc_wxWindow_DoGetPosition);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoGetSize, "DoGetSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxWindow_DoGetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoGetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxWindow *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoGetSize, doc_wxWindow_DoGetSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoGetClientSize, "DoGetClientSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxWindow_DoGetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoGetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxWindow *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetClientSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoGetClientSize, doc_wxWindow_DoGetClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoSetSize, "DoSetSize(self, x: int, y: int, width: int, height: int, sizeFlags: int)");

extern "C" {static PyObject *meth_wxWindow_DoSetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoSetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        int sizeFlags;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
            sipName_sizeFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiiii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y, &width, &height, &sizeFlags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSize(sipSelfWasArg,x,y,width,height,sizeFlags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoSetSize, doc_wxWindow_DoSetSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoSetClientSize, "DoSetClientSize(self, width: int, height: int)");

extern "C" {static PyObject *meth_wxWindow_DoSetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoSetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxWindow, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetClientSize(sipSelfWasArg,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoSetClientSize, doc_wxWindow_DoSetClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoSetSizeHints, "DoSetSizeHints(self, minW: int, minH: int, maxW: int, maxH: int, incW: int, incH: int)");

extern "C" {static PyObject *meth_wxWindow_DoSetSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoSetSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int minW;
        int minH;
        int maxW;
        int maxH;
        int incW;
        int incH;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minW,
            sipName_minH,
            sipName_maxW,
            sipName_maxH,
            sipName_incW,
            sipName_incH,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiiiii", &sipSelf, sipType_wxWindow, &sipCpp, &minW, &minH, &maxW, &maxH, &incW, &incH))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSizeHints(sipSelfWasArg,minW,minH,maxW,maxH,incW,incH);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoSetSizeHints, doc_wxWindow_DoSetSizeHints);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoMoveWindow, "DoMoveWindow(self, x: int, y: int, width: int, height: int)");

extern "C" {static PyObject *meth_wxWindow_DoMoveWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoMoveWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxWindow, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoMoveWindow(sipSelfWasArg,x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoMoveWindow, doc_wxWindow_DoMoveWindow);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoSetWindowVariant, "DoSetWindowVariant(self, variant: WindowVariant)");

extern "C" {static PyObject *meth_wxWindow_DoSetWindowVariant(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoSetWindowVariant(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowVariant variant;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxWindowVariant, &variant))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetWindowVariant(sipSelfWasArg,variant);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoSetWindowVariant, doc_wxWindow_DoSetWindowVariant);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetDefaultBorder, "GetDefaultBorder(self) -> Border");

extern "C" {static PyObject *meth_wxWindow_GetDefaultBorder(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetDefaultBorder(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorder(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetDefaultBorder, doc_wxWindow_GetDefaultBorder);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_GetDefaultBorderForControl, "GetDefaultBorderForControl(self) -> Border");

extern "C" {static PyObject *meth_wxWindow_GetDefaultBorderForControl(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_GetDefaultBorderForControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorderForControl(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_GetDefaultBorderForControl, doc_wxWindow_GetDefaultBorderForControl);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoFreeze, "DoFreeze(self)");

extern "C" {static PyObject *meth_wxWindow_DoFreeze(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoFreeze(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoFreeze(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoFreeze, doc_wxWindow_DoFreeze);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoThaw, "DoThaw(self)");

extern "C" {static PyObject *meth_wxWindow_DoThaw(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoThaw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoThaw(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoThaw, doc_wxWindow_DoThaw);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_TryBefore, "TryBefore(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxWindow_TryBefore(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_TryBefore(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryBefore(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_TryBefore, doc_wxWindow_TryBefore);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_TryAfter, "TryAfter(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxWindow_TryAfter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_TryAfter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryAfter(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_TryAfter, doc_wxWindow_TryAfter);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoGetBestSize, "DoGetBestSize() -> Size\n"
"\n"
"Implementation of GetBestSize() that can be overridden.");

extern "C" {static PyObject *meth_wxWindow_DoGetBestSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoGetBestSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoGetBestSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_DoGetBestClientSize, "DoGetBestClientSize() -> Size\n"
"\n"
"Override this method to return the best size for a custom control.");

extern "C" {static PyObject *meth_wxWindow_DoGetBestClientSize(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_DoGetBestClientSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestClientSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_DoGetBestClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_SendDestroyEvent, "SendDestroyEvent()\n"
"\n"
"Generate wxWindowDestroyEvent for this window.");

extern "C" {static PyObject *meth_wxWindow_SendDestroyEvent(PyObject *, PyObject *);}
static PyObject *meth_wxWindow_SendDestroyEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        sipwxWindow *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxWindow, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtect_SendDestroyEvent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_SendDestroyEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxWindow_ProcessEvent, "ProcessEvent(event) -> bool\n"
"\n"
"This function is public in wxEvtHandler but protected in wxWindow\n"
"because for wxWindows you should always call ProcessEvent() on the\n"
"pointer returned by GetEventHandler() and not on the wxWindow object\n"
"itself.");

extern "C" {static PyObject *meth_wxWindow_ProcessEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxWindow_ProcessEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxWindow *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxWindow, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_ProcessEvent(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Window, sipName_ProcessEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxWindow(void *, const sipTypeDef *);}
static void *cast_wxWindow(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxWindow *sipCpp = reinterpret_cast< ::wxWindow *>(sipCppV);

    if (targetType == sipType_wxWindow)
        return sipCppV;

    sipCppV = ((const sipClassTypeDef *)sipType_wxWindowBase)->ctd_cast(static_cast< ::wxWindowBase *>(sipCpp), targetType);
    if (sipCppV)
        return sipCppV;

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxWindow(void *, int);}
static void release_wxWindow(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxWindow *>(sipCppV);
    else
        delete reinterpret_cast< ::wxWindow *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void *array_wxWindow(Py_ssize_t);}
static void *array_wxWindow(Py_ssize_t sipNrElem)
{
    return new  ::wxWindow[sipNrElem];
}


extern "C" {static void dealloc_wxWindow(sipSimpleWrapper *);}
static void dealloc_wxWindow(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxWindow *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxWindow(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxWindow(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxWindow(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipwxWindow *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
         ::wxWindow* parent;
         ::wxWindowID id = wxID_ANY;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        long style = 0;
        const  ::wxString& namedef = wxPanelNameStr;
        const  ::wxString* name = &namedef;
        int nameState = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
            sipName_id,
            sipName_pos,
            sipName_size,
            sipName_style,
            sipName_name,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "JH|iJ1J1lJ1", sipType_wxWindow, &parent, sipOwner, &id, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, &style, sipType_wxString, &name, &nameState))
        {
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxWindow(parent,id,*pos,*size,style,*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxWindow[] = {{633, 255, 1}};


static PyMethodDef methods_wxWindow[] = {
    {sipName_AcceptsFocus, meth_wxWindow_AcceptsFocus, METH_VARARGS, doc_wxWindow_AcceptsFocus},
    {sipName_AcceptsFocusFromKeyboard, meth_wxWindow_AcceptsFocusFromKeyboard, METH_VARARGS, doc_wxWindow_AcceptsFocusFromKeyboard},
    {sipName_AcceptsFocusRecursively, meth_wxWindow_AcceptsFocusRecursively, METH_VARARGS, doc_wxWindow_AcceptsFocusRecursively},
    {sipName_AddChild, SIP_MLMETH_CAST(meth_wxWindow_AddChild), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_AddChild},
    {sipName_AdjustForLayoutDirection, SIP_MLMETH_CAST(meth_wxWindow_AdjustForLayoutDirection), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_AdjustForLayoutDirection},
    {sipName_AlwaysShowScrollbars, SIP_MLMETH_CAST(meth_wxWindow_AlwaysShowScrollbars), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_AlwaysShowScrollbars},
    {sipName_AssociateHandle, SIP_MLMETH_CAST(meth_wxWindow_AssociateHandle), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_AssociateHandle},
    {sipName_BeginRepositioningChildren, meth_wxWindow_BeginRepositioningChildren, METH_VARARGS, doc_wxWindow_BeginRepositioningChildren},
    {sipName_CacheBestSize, SIP_MLMETH_CAST(meth_wxWindow_CacheBestSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_CacheBestSize},
    {sipName_CanAcceptFocus, meth_wxWindow_CanAcceptFocus, METH_VARARGS, doc_wxWindow_CanAcceptFocus},
    {sipName_CanAcceptFocusFromKeyboard, meth_wxWindow_CanAcceptFocusFromKeyboard, METH_VARARGS, doc_wxWindow_CanAcceptFocusFromKeyboard},
    {sipName_CanScroll, SIP_MLMETH_CAST(meth_wxWindow_CanScroll), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_CanScroll},
    {sipName_CanSetTransparent, meth_wxWindow_CanSetTransparent, METH_VARARGS, doc_wxWindow_CanSetTransparent},
    {sipName_CaptureMouse, meth_wxWindow_CaptureMouse, METH_VARARGS, doc_wxWindow_CaptureMouse},
    {sipName_Center, SIP_MLMETH_CAST(meth_wxWindow_Center), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Center},
    {sipName_CenterOnParent, SIP_MLMETH_CAST(meth_wxWindow_CenterOnParent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_CenterOnParent},
    {sipName_Centre, SIP_MLMETH_CAST(meth_wxWindow_Centre), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Centre},
    {sipName_CentreOnParent, SIP_MLMETH_CAST(meth_wxWindow_CentreOnParent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_CentreOnParent},
    {sipName_ClearBackground, meth_wxWindow_ClearBackground, METH_VARARGS, doc_wxWindow_ClearBackground},
    {sipName_ClientToScreen, SIP_MLMETH_CAST(meth_wxWindow_ClientToScreen), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ClientToScreen},
    {sipName_ClientToWindowSize, SIP_MLMETH_CAST(meth_wxWindow_ClientToWindowSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ClientToWindowSize},
    {sipName_Close, SIP_MLMETH_CAST(meth_wxWindow_Close), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Close},
    {sipName_ConvertDialogToPixels, SIP_MLMETH_CAST(meth_wxWindow_ConvertDialogToPixels), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ConvertDialogToPixels},
    {sipName_ConvertPixelsToDialog, SIP_MLMETH_CAST(meth_wxWindow_ConvertPixelsToDialog), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ConvertPixelsToDialog},
    {sipName_Create, SIP_MLMETH_CAST(meth_wxWindow_Create), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Create},
    {sipName_Destroy, meth_wxWindow_Destroy, METH_VARARGS, doc_wxWindow_Destroy},
    {sipName_DestroyChildren, meth_wxWindow_DestroyChildren, METH_VARARGS, doc_wxWindow_DestroyChildren},
    {sipName_Disable, meth_wxWindow_Disable, METH_VARARGS, doc_wxWindow_Disable},
    {sipName_DisableFocusFromKeyboard, meth_wxWindow_DisableFocusFromKeyboard, METH_VARARGS, doc_wxWindow_DisableFocusFromKeyboard},
    {sipName_DissociateHandle, meth_wxWindow_DissociateHandle, METH_VARARGS, doc_wxWindow_DissociateHandle},
    {sipName_DoEnable, SIP_MLMETH_CAST(meth_wxWindow_DoEnable), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoEnable},
    {sipName_DoFreeze, meth_wxWindow_DoFreeze, METH_VARARGS, doc_wxWindow_DoFreeze},
    {sipName_DoGetBestClientSize, meth_wxWindow_DoGetBestClientSize, METH_VARARGS, doc_wxWindow_DoGetBestClientSize},
    {sipName_DoGetBestSize, meth_wxWindow_DoGetBestSize, METH_VARARGS, doc_wxWindow_DoGetBestSize},
    {sipName_DoGetClientSize, SIP_MLMETH_CAST(meth_wxWindow_DoGetClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoGetClientSize},
    {sipName_DoGetPosition, SIP_MLMETH_CAST(meth_wxWindow_DoGetPosition), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoGetPosition},
    {sipName_DoGetSize, SIP_MLMETH_CAST(meth_wxWindow_DoGetSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoGetSize},
    {sipName_DoMoveWindow, SIP_MLMETH_CAST(meth_wxWindow_DoMoveWindow), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoMoveWindow},
    {sipName_DoSetClientSize, SIP_MLMETH_CAST(meth_wxWindow_DoSetClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoSetClientSize},
    {sipName_DoSetSize, SIP_MLMETH_CAST(meth_wxWindow_DoSetSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoSetSize},
    {sipName_DoSetSizeHints, SIP_MLMETH_CAST(meth_wxWindow_DoSetSizeHints), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoSetSizeHints},
    {sipName_DoSetWindowVariant, SIP_MLMETH_CAST(meth_wxWindow_DoSetWindowVariant), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoSetWindowVariant},
    {sipName_DoThaw, meth_wxWindow_DoThaw, METH_VARARGS, doc_wxWindow_DoThaw},
    {sipName_DoUpdateWindowUI, SIP_MLMETH_CAST(meth_wxWindow_DoUpdateWindowUI), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DoUpdateWindowUI},
    {sipName_DragAcceptFiles, SIP_MLMETH_CAST(meth_wxWindow_DragAcceptFiles), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_DragAcceptFiles},
    {sipName_Enable, SIP_MLMETH_CAST(meth_wxWindow_Enable), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Enable},
    {sipName_EnableTouchEvents, SIP_MLMETH_CAST(meth_wxWindow_EnableTouchEvents), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_EnableTouchEvents},
    {sipName_EnableVisibleFocus, SIP_MLMETH_CAST(meth_wxWindow_EnableVisibleFocus), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_EnableVisibleFocus},
    {sipName_EndRepositioningChildren, meth_wxWindow_EndRepositioningChildren, METH_VARARGS, doc_wxWindow_EndRepositioningChildren},
    {sipName_FindFocus, meth_wxWindow_FindFocus, METH_VARARGS, doc_wxWindow_FindFocus},
    {sipName_FindWindow, SIP_MLMETH_CAST(meth_wxWindow_FindWindow), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_FindWindow},
    {sipName_FindWindowById, SIP_MLMETH_CAST(meth_wxWindow_FindWindowById), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_FindWindowById},
    {sipName_FindWindowByLabel, SIP_MLMETH_CAST(meth_wxWindow_FindWindowByLabel), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_FindWindowByLabel},
    {sipName_FindWindowByName, SIP_MLMETH_CAST(meth_wxWindow_FindWindowByName), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_FindWindowByName},
    {sipName_Fit, meth_wxWindow_Fit, METH_VARARGS, doc_wxWindow_Fit},
    {sipName_FitInside, meth_wxWindow_FitInside, METH_VARARGS, doc_wxWindow_FitInside},
    {sipName_Freeze, meth_wxWindow_Freeze, METH_VARARGS, doc_wxWindow_Freeze},
    {sipName_FromDIP, SIP_MLMETH_CAST(meth_wxWindow_FromDIP), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_FromDIP},
    {sipName_FromPhys, SIP_MLMETH_CAST(meth_wxWindow_FromPhys), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_FromPhys},
    {sipName_GetAcceleratorTable, meth_wxWindow_GetAcceleratorTable, METH_VARARGS, doc_wxWindow_GetAcceleratorTable},
    {sipName_GetAccessible, meth_wxWindow_GetAccessible, METH_VARARGS, doc_wxWindow_GetAccessible},
    {sipName_GetAutoLayout, meth_wxWindow_GetAutoLayout, METH_VARARGS, doc_wxWindow_GetAutoLayout},
    {sipName_GetBackgroundColour, meth_wxWindow_GetBackgroundColour, METH_VARARGS, doc_wxWindow_GetBackgroundColour},
    {sipName_GetBackgroundStyle, meth_wxWindow_GetBackgroundStyle, METH_VARARGS, doc_wxWindow_GetBackgroundStyle},
    {sipName_GetBestHeight, SIP_MLMETH_CAST(meth_wxWindow_GetBestHeight), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetBestHeight},
    {sipName_GetBestSize, meth_wxWindow_GetBestSize, METH_VARARGS, doc_wxWindow_GetBestSize},
    {sipName_GetBestVirtualSize, meth_wxWindow_GetBestVirtualSize, METH_VARARGS, doc_wxWindow_GetBestVirtualSize},
    {sipName_GetBestWidth, SIP_MLMETH_CAST(meth_wxWindow_GetBestWidth), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetBestWidth},
    {sipName_GetBorder, SIP_MLMETH_CAST(meth_wxWindow_GetBorder), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetBorder},
    {sipName_GetCapture, meth_wxWindow_GetCapture, METH_VARARGS, doc_wxWindow_GetCapture},
    {sipName_GetCaret, meth_wxWindow_GetCaret, METH_VARARGS, doc_wxWindow_GetCaret},
    {sipName_GetCharHeight, meth_wxWindow_GetCharHeight, METH_VARARGS, doc_wxWindow_GetCharHeight},
    {sipName_GetCharWidth, meth_wxWindow_GetCharWidth, METH_VARARGS, doc_wxWindow_GetCharWidth},
    {sipName_GetChildren, meth_wxWindow_GetChildren, METH_VARARGS, doc_wxWindow_GetChildren},
    {sipName_GetClassDefaultAttributes, SIP_MLMETH_CAST(meth_wxWindow_GetClassDefaultAttributes), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetClassDefaultAttributes},
    {sipName_GetClientAreaOrigin, meth_wxWindow_GetClientAreaOrigin, METH_VARARGS, doc_wxWindow_GetClientAreaOrigin},
    {sipName_GetClientRect, meth_wxWindow_GetClientRect, METH_VARARGS, doc_wxWindow_GetClientRect},
    {sipName_GetClientSize, meth_wxWindow_GetClientSize, METH_VARARGS, doc_wxWindow_GetClientSize},
    {sipName_GetConstraints, meth_wxWindow_GetConstraints, METH_VARARGS, doc_wxWindow_GetConstraints},
    {sipName_GetContainingSizer, meth_wxWindow_GetContainingSizer, METH_VARARGS, doc_wxWindow_GetContainingSizer},
    {sipName_GetContentScaleFactor, meth_wxWindow_GetContentScaleFactor, METH_VARARGS, doc_wxWindow_GetContentScaleFactor},
    {sipName_GetCursor, meth_wxWindow_GetCursor, METH_VARARGS, doc_wxWindow_GetCursor},
    {sipName_GetDPI, meth_wxWindow_GetDPI, METH_VARARGS, doc_wxWindow_GetDPI},
    {sipName_GetDPIScaleFactor, meth_wxWindow_GetDPIScaleFactor, METH_VARARGS, doc_wxWindow_GetDPIScaleFactor},
    {sipName_GetDefaultAttributes, meth_wxWindow_GetDefaultAttributes, METH_VARARGS, doc_wxWindow_GetDefaultAttributes},
    {sipName_GetDefaultBorder, meth_wxWindow_GetDefaultBorder, METH_VARARGS, doc_wxWindow_GetDefaultBorder},
    {sipName_GetDefaultBorderForControl, meth_wxWindow_GetDefaultBorderForControl, METH_VARARGS, doc_wxWindow_GetDefaultBorderForControl},
    {sipName_GetDropTarget, meth_wxWindow_GetDropTarget, METH_VARARGS, doc_wxWindow_GetDropTarget},
    {sipName_GetEffectiveMinSize, meth_wxWindow_GetEffectiveMinSize, METH_VARARGS, doc_wxWindow_GetEffectiveMinSize},
    {sipName_GetEventHandler, meth_wxWindow_GetEventHandler, METH_VARARGS, doc_wxWindow_GetEventHandler},
    {sipName_GetExtraStyle, meth_wxWindow_GetExtraStyle, METH_VARARGS, doc_wxWindow_GetExtraStyle},
    {sipName_GetFont, meth_wxWindow_GetFont, METH_VARARGS, doc_wxWindow_GetFont},
    {sipName_GetForegroundColour, meth_wxWindow_GetForegroundColour, METH_VARARGS, doc_wxWindow_GetForegroundColour},
    {sipName_GetFullTextExtent, SIP_MLMETH_CAST(meth_wxWindow_GetFullTextExtent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetFullTextExtent},
    {sipName_GetGrandParent, meth_wxWindow_GetGrandParent, METH_VARARGS, doc_wxWindow_GetGrandParent},
    {sipName_GetGtkWidget, meth_wxWindow_GetGtkWidget, METH_VARARGS, doc_wxWindow_GetGtkWidget},
    {sipName_GetHandle, meth_wxWindow_GetHandle, METH_VARARGS, doc_wxWindow_GetHandle},
    {sipName_GetHelpText, meth_wxWindow_GetHelpText, METH_VARARGS, doc_wxWindow_GetHelpText},
    {sipName_GetHelpTextAtPoint, SIP_MLMETH_CAST(meth_wxWindow_GetHelpTextAtPoint), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetHelpTextAtPoint},
    {sipName_GetId, meth_wxWindow_GetId, METH_VARARGS, doc_wxWindow_GetId},
    {sipName_GetLabel, meth_wxWindow_GetLabel, METH_VARARGS, doc_wxWindow_GetLabel},
    {sipName_GetLayoutDirection, meth_wxWindow_GetLayoutDirection, METH_VARARGS, doc_wxWindow_GetLayoutDirection},
    {sipName_GetMainWindowOfCompositeControl, meth_wxWindow_GetMainWindowOfCompositeControl, METH_VARARGS, doc_wxWindow_GetMainWindowOfCompositeControl},
    {sipName_GetMaxClientSize, meth_wxWindow_GetMaxClientSize, METH_VARARGS, doc_wxWindow_GetMaxClientSize},
    {sipName_GetMaxHeight, meth_wxWindow_GetMaxHeight, METH_VARARGS, doc_wxWindow_GetMaxHeight},
    {sipName_GetMaxSize, meth_wxWindow_GetMaxSize, METH_VARARGS, doc_wxWindow_GetMaxSize},
    {sipName_GetMaxWidth, meth_wxWindow_GetMaxWidth, METH_VARARGS, doc_wxWindow_GetMaxWidth},
    {sipName_GetMinClientSize, meth_wxWindow_GetMinClientSize, METH_VARARGS, doc_wxWindow_GetMinClientSize},
    {sipName_GetMinHeight, meth_wxWindow_GetMinHeight, METH_VARARGS, doc_wxWindow_GetMinHeight},
    {sipName_GetMinSize, meth_wxWindow_GetMinSize, METH_VARARGS, doc_wxWindow_GetMinSize},
    {sipName_GetMinWidth, meth_wxWindow_GetMinWidth, METH_VARARGS, doc_wxWindow_GetMinWidth},
    {sipName_GetName, meth_wxWindow_GetName, METH_VARARGS, doc_wxWindow_GetName},
    {sipName_GetNextSibling, meth_wxWindow_GetNextSibling, METH_VARARGS, doc_wxWindow_GetNextSibling},
    {sipName_GetParent, meth_wxWindow_GetParent, METH_VARARGS, doc_wxWindow_GetParent},
    {sipName_GetPopupMenuSelectionFromUser, SIP_MLMETH_CAST(meth_wxWindow_GetPopupMenuSelectionFromUser), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetPopupMenuSelectionFromUser},
    {sipName_GetPosition, meth_wxWindow_GetPosition, METH_VARARGS, doc_wxWindow_GetPosition},
    {sipName_GetPrevSibling, meth_wxWindow_GetPrevSibling, METH_VARARGS, doc_wxWindow_GetPrevSibling},
    {sipName_GetRect, meth_wxWindow_GetRect, METH_VARARGS, doc_wxWindow_GetRect},
    {sipName_GetScreenPosition, meth_wxWindow_GetScreenPosition, METH_VARARGS, doc_wxWindow_GetScreenPosition},
    {sipName_GetScreenRect, meth_wxWindow_GetScreenRect, METH_VARARGS, doc_wxWindow_GetScreenRect},
    {sipName_GetScrollPos, SIP_MLMETH_CAST(meth_wxWindow_GetScrollPos), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetScrollPos},
    {sipName_GetScrollRange, SIP_MLMETH_CAST(meth_wxWindow_GetScrollRange), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetScrollRange},
    {sipName_GetScrollThumb, SIP_MLMETH_CAST(meth_wxWindow_GetScrollThumb), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetScrollThumb},
    {sipName_GetSize, meth_wxWindow_GetSize, METH_VARARGS, doc_wxWindow_GetSize},
    {sipName_GetSizer, meth_wxWindow_GetSizer, METH_VARARGS, doc_wxWindow_GetSizer},
    {sipName_GetTextExtent, SIP_MLMETH_CAST(meth_wxWindow_GetTextExtent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_GetTextExtent},
    {sipName_GetThemeEnabled, meth_wxWindow_GetThemeEnabled, METH_VARARGS, doc_wxWindow_GetThemeEnabled},
    {sipName_GetToolTip, meth_wxWindow_GetToolTip, METH_VARARGS, doc_wxWindow_GetToolTip},
    {sipName_GetToolTipText, meth_wxWindow_GetToolTipText, METH_VARARGS, doc_wxWindow_GetToolTipText},
    {sipName_GetTopLevelParent, meth_wxWindow_GetTopLevelParent, METH_VARARGS, doc_wxWindow_GetTopLevelParent},
    {sipName_GetUpdateClientRect, meth_wxWindow_GetUpdateClientRect, METH_VARARGS, doc_wxWindow_GetUpdateClientRect},
    {sipName_GetUpdateRegion, meth_wxWindow_GetUpdateRegion, METH_VARARGS, doc_wxWindow_GetUpdateRegion},
    {sipName_GetValidator, meth_wxWindow_GetValidator, METH_VARARGS, doc_wxWindow_GetValidator},
    {sipName_GetVirtualSize, meth_wxWindow_GetVirtualSize, METH_VARARGS, doc_wxWindow_GetVirtualSize},
    {sipName_GetWindowBorderSize, meth_wxWindow_GetWindowBorderSize, METH_VARARGS, doc_wxWindow_GetWindowBorderSize},
    {sipName_GetWindowStyle, meth_wxWindow_GetWindowStyle, METH_VARARGS, doc_wxWindow_GetWindowStyle},
    {sipName_GetWindowStyleFlag, meth_wxWindow_GetWindowStyleFlag, METH_VARARGS, doc_wxWindow_GetWindowStyleFlag},
    {sipName_GetWindowVariant, meth_wxWindow_GetWindowVariant, METH_VARARGS, doc_wxWindow_GetWindowVariant},
    {sipName_HandleAsNavigationKey, SIP_MLMETH_CAST(meth_wxWindow_HandleAsNavigationKey), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_HandleAsNavigationKey},
    {sipName_HandleWindowEvent, SIP_MLMETH_CAST(meth_wxWindow_HandleWindowEvent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_HandleWindowEvent},
    {sipName_HasCapture, meth_wxWindow_HasCapture, METH_VARARGS, doc_wxWindow_HasCapture},
    {sipName_HasExtraStyle, SIP_MLMETH_CAST(meth_wxWindow_HasExtraStyle), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_HasExtraStyle},
    {sipName_HasFlag, SIP_MLMETH_CAST(meth_wxWindow_HasFlag), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_HasFlag},
    {sipName_HasFocus, meth_wxWindow_HasFocus, METH_VARARGS, doc_wxWindow_HasFocus},
    {sipName_HasMultiplePages, meth_wxWindow_HasMultiplePages, METH_VARARGS, doc_wxWindow_HasMultiplePages},
    {sipName_HasScrollbar, SIP_MLMETH_CAST(meth_wxWindow_HasScrollbar), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_HasScrollbar},
    {sipName_HasTransparentBackground, meth_wxWindow_HasTransparentBackground, METH_VARARGS, doc_wxWindow_HasTransparentBackground},
    {sipName_Hide, meth_wxWindow_Hide, METH_VARARGS, doc_wxWindow_Hide},
    {sipName_HideWithEffect, SIP_MLMETH_CAST(meth_wxWindow_HideWithEffect), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_HideWithEffect},
    {sipName_HitTest, SIP_MLMETH_CAST(meth_wxWindow_HitTest), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_HitTest},
    {sipName_InformFirstDirection, SIP_MLMETH_CAST(meth_wxWindow_InformFirstDirection), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_InformFirstDirection},
    {sipName_InheritAttributes, meth_wxWindow_InheritAttributes, METH_VARARGS, doc_wxWindow_InheritAttributes},
    {sipName_InheritsBackgroundColour, meth_wxWindow_InheritsBackgroundColour, METH_VARARGS, doc_wxWindow_InheritsBackgroundColour},
    {sipName_InheritsForegroundColour, meth_wxWindow_InheritsForegroundColour, METH_VARARGS, doc_wxWindow_InheritsForegroundColour},
    {sipName_InitDialog, meth_wxWindow_InitDialog, METH_VARARGS, doc_wxWindow_InitDialog},
    {sipName_InvalidateBestSize, meth_wxWindow_InvalidateBestSize, METH_VARARGS, doc_wxWindow_InvalidateBestSize},
    {sipName_IsBeingDeleted, meth_wxWindow_IsBeingDeleted, METH_VARARGS, doc_wxWindow_IsBeingDeleted},
    {sipName_IsDescendant, SIP_MLMETH_CAST(meth_wxWindow_IsDescendant), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_IsDescendant},
    {sipName_IsDoubleBuffered, meth_wxWindow_IsDoubleBuffered, METH_VARARGS, doc_wxWindow_IsDoubleBuffered},
    {sipName_IsEnabled, meth_wxWindow_IsEnabled, METH_VARARGS, doc_wxWindow_IsEnabled},
    {sipName_IsExposed, SIP_MLMETH_CAST(meth_wxWindow_IsExposed), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_IsExposed},
    {sipName_IsFocusable, meth_wxWindow_IsFocusable, METH_VARARGS, doc_wxWindow_IsFocusable},
    {sipName_IsFrozen, meth_wxWindow_IsFrozen, METH_VARARGS, doc_wxWindow_IsFrozen},
    {sipName_IsRetained, meth_wxWindow_IsRetained, METH_VARARGS, doc_wxWindow_IsRetained},
    {sipName_IsScrollbarAlwaysShown, SIP_MLMETH_CAST(meth_wxWindow_IsScrollbarAlwaysShown), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_IsScrollbarAlwaysShown},
    {sipName_IsShown, meth_wxWindow_IsShown, METH_VARARGS, doc_wxWindow_IsShown},
    {sipName_IsShownOnScreen, meth_wxWindow_IsShownOnScreen, METH_VARARGS, doc_wxWindow_IsShownOnScreen},
    {sipName_IsThisEnabled, meth_wxWindow_IsThisEnabled, METH_VARARGS, doc_wxWindow_IsThisEnabled},
    {sipName_IsTopLevel, meth_wxWindow_IsTopLevel, METH_VARARGS, doc_wxWindow_IsTopLevel},
    {sipName_IsTransparentBackgroundSupported, SIP_MLMETH_CAST(meth_wxWindow_IsTransparentBackgroundSupported), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_IsTransparentBackgroundSupported},
    {sipName_Layout, meth_wxWindow_Layout, METH_VARARGS, doc_wxWindow_Layout},
    {sipName_LineDown, meth_wxWindow_LineDown, METH_VARARGS, doc_wxWindow_LineDown},
    {sipName_LineUp, meth_wxWindow_LineUp, METH_VARARGS, doc_wxWindow_LineUp},
    {sipName_Lower, meth_wxWindow_Lower, METH_VARARGS, doc_wxWindow_Lower},
    {sipName_MacIsWindowScrollbar, SIP_MLMETH_CAST(meth_wxWindow_MacIsWindowScrollbar), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_MacIsWindowScrollbar},
    {sipName_Move, SIP_MLMETH_CAST(meth_wxWindow_Move), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Move},
    {sipName_MoveAfterInTabOrder, SIP_MLMETH_CAST(meth_wxWindow_MoveAfterInTabOrder), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_MoveAfterInTabOrder},
    {sipName_MoveBeforeInTabOrder, SIP_MLMETH_CAST(meth_wxWindow_MoveBeforeInTabOrder), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_MoveBeforeInTabOrder},
    {sipName_Navigate, SIP_MLMETH_CAST(meth_wxWindow_Navigate), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Navigate},
    {sipName_NavigateIn, SIP_MLMETH_CAST(meth_wxWindow_NavigateIn), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_NavigateIn},
    {sipName_NewControlId, SIP_MLMETH_CAST(meth_wxWindow_NewControlId), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_NewControlId},
    {sipName_OnInternalIdle, meth_wxWindow_OnInternalIdle, METH_VARARGS, doc_wxWindow_OnInternalIdle},
    {sipName_PageDown, meth_wxWindow_PageDown, METH_VARARGS, doc_wxWindow_PageDown},
    {sipName_PageUp, meth_wxWindow_PageUp, METH_VARARGS, doc_wxWindow_PageUp},
    {sipName_PopEventHandler, SIP_MLMETH_CAST(meth_wxWindow_PopEventHandler), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_PopEventHandler},
    {sipName_PopupMenu, SIP_MLMETH_CAST(meth_wxWindow_PopupMenu), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_PopupMenu},
    {sipName_PostSizeEvent, meth_wxWindow_PostSizeEvent, METH_VARARGS, doc_wxWindow_PostSizeEvent},
    {sipName_PostSizeEventToParent, meth_wxWindow_PostSizeEventToParent, METH_VARARGS, doc_wxWindow_PostSizeEventToParent},
    {sipName_ProcessEvent, SIP_MLMETH_CAST(meth_wxWindow_ProcessEvent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ProcessEvent},
    {sipName_ProcessWindowEvent, SIP_MLMETH_CAST(meth_wxWindow_ProcessWindowEvent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ProcessWindowEvent},
    {sipName_ProcessWindowEventLocally, SIP_MLMETH_CAST(meth_wxWindow_ProcessWindowEventLocally), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ProcessWindowEventLocally},
    {sipName_PushEventHandler, SIP_MLMETH_CAST(meth_wxWindow_PushEventHandler), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_PushEventHandler},
    {sipName_Raise, meth_wxWindow_Raise, METH_VARARGS, doc_wxWindow_Raise},
    {sipName_Refresh, SIP_MLMETH_CAST(meth_wxWindow_Refresh), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Refresh},
    {sipName_RefreshRect, SIP_MLMETH_CAST(meth_wxWindow_RefreshRect), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_RefreshRect},
    {sipName_RegisterHotKey, SIP_MLMETH_CAST(meth_wxWindow_RegisterHotKey), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_RegisterHotKey},
    {sipName_ReleaseMouse, meth_wxWindow_ReleaseMouse, METH_VARARGS, doc_wxWindow_ReleaseMouse},
    {sipName_RemoveChild, SIP_MLMETH_CAST(meth_wxWindow_RemoveChild), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_RemoveChild},
    {sipName_RemoveEventHandler, SIP_MLMETH_CAST(meth_wxWindow_RemoveEventHandler), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_RemoveEventHandler},
    {sipName_Reparent, SIP_MLMETH_CAST(meth_wxWindow_Reparent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Reparent},
    {sipName_ScreenToClient, SIP_MLMETH_CAST(meth_wxWindow_ScreenToClient), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ScreenToClient},
    {sipName_ScrollLines, SIP_MLMETH_CAST(meth_wxWindow_ScrollLines), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ScrollLines},
    {sipName_ScrollPages, SIP_MLMETH_CAST(meth_wxWindow_ScrollPages), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ScrollPages},
    {sipName_ScrollWindow, SIP_MLMETH_CAST(meth_wxWindow_ScrollWindow), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ScrollWindow},
    {sipName_SendDestroyEvent, meth_wxWindow_SendDestroyEvent, METH_VARARGS, doc_wxWindow_SendDestroyEvent},
    {sipName_SendIdleEvents, SIP_MLMETH_CAST(meth_wxWindow_SendIdleEvents), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SendIdleEvents},
    {sipName_SendSizeEvent, SIP_MLMETH_CAST(meth_wxWindow_SendSizeEvent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SendSizeEvent},
    {sipName_SendSizeEventToParent, SIP_MLMETH_CAST(meth_wxWindow_SendSizeEventToParent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SendSizeEventToParent},
    {sipName_SetAcceleratorTable, SIP_MLMETH_CAST(meth_wxWindow_SetAcceleratorTable), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetAcceleratorTable},
    {sipName_SetAccessible, SIP_MLMETH_CAST(meth_wxWindow_SetAccessible), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetAccessible},
    {sipName_SetAutoLayout, SIP_MLMETH_CAST(meth_wxWindow_SetAutoLayout), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetAutoLayout},
    {sipName_SetBackgroundColour, SIP_MLMETH_CAST(meth_wxWindow_SetBackgroundColour), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetBackgroundColour},
    {sipName_SetBackgroundStyle, SIP_MLMETH_CAST(meth_wxWindow_SetBackgroundStyle), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetBackgroundStyle},
    {sipName_SetCanFocus, SIP_MLMETH_CAST(meth_wxWindow_SetCanFocus), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetCanFocus},
    {sipName_SetCaret, SIP_MLMETH_CAST(meth_wxWindow_SetCaret), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetCaret},
    {sipName_SetClientSize, SIP_MLMETH_CAST(meth_wxWindow_SetClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetClientSize},
    {sipName_SetConstraints, SIP_MLMETH_CAST(meth_wxWindow_SetConstraints), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetConstraints},
    {sipName_SetContainingSizer, SIP_MLMETH_CAST(meth_wxWindow_SetContainingSizer), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetContainingSizer},
    {sipName_SetCursor, SIP_MLMETH_CAST(meth_wxWindow_SetCursor), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetCursor},
    {sipName_SetDimensions, SIP_MLMETH_CAST(meth_wxWindow_SetDimensions), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetDimensions},
    {sipName_SetDoubleBuffered, SIP_MLMETH_CAST(meth_wxWindow_SetDoubleBuffered), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetDoubleBuffered},
    {sipName_SetDropTarget, SIP_MLMETH_CAST(meth_wxWindow_SetDropTarget), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetDropTarget},
    {sipName_SetEventHandler, SIP_MLMETH_CAST(meth_wxWindow_SetEventHandler), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetEventHandler},
    {sipName_SetExtraStyle, SIP_MLMETH_CAST(meth_wxWindow_SetExtraStyle), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetExtraStyle},
    {sipName_SetFocus, meth_wxWindow_SetFocus, METH_VARARGS, doc_wxWindow_SetFocus},
    {sipName_SetFocusFromKbd, meth_wxWindow_SetFocusFromKbd, METH_VARARGS, doc_wxWindow_SetFocusFromKbd},
    {sipName_SetFont, SIP_MLMETH_CAST(meth_wxWindow_SetFont), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetFont},
    {sipName_SetForegroundColour, SIP_MLMETH_CAST(meth_wxWindow_SetForegroundColour), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetForegroundColour},
    {sipName_SetHelpText, SIP_MLMETH_CAST(meth_wxWindow_SetHelpText), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetHelpText},
    {sipName_SetId, SIP_MLMETH_CAST(meth_wxWindow_SetId), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetId},
    {sipName_SetInitialSize, SIP_MLMETH_CAST(meth_wxWindow_SetInitialSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetInitialSize},
    {sipName_SetLabel, SIP_MLMETH_CAST(meth_wxWindow_SetLabel), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetLabel},
    {sipName_SetLayoutDirection, SIP_MLMETH_CAST(meth_wxWindow_SetLayoutDirection), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetLayoutDirection},
    {sipName_SetMaxClientSize, SIP_MLMETH_CAST(meth_wxWindow_SetMaxClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetMaxClientSize},
    {sipName_SetMaxSize, SIP_MLMETH_CAST(meth_wxWindow_SetMaxSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetMaxSize},
    {sipName_SetMinClientSize, SIP_MLMETH_CAST(meth_wxWindow_SetMinClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetMinClientSize},
    {sipName_SetMinSize, SIP_MLMETH_CAST(meth_wxWindow_SetMinSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetMinSize},
    {sipName_SetName, SIP_MLMETH_CAST(meth_wxWindow_SetName), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetName},
    {sipName_SetNextHandler, SIP_MLMETH_CAST(meth_wxWindow_SetNextHandler), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetNextHandler},
    {sipName_SetOwnBackgroundColour, SIP_MLMETH_CAST(meth_wxWindow_SetOwnBackgroundColour), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetOwnBackgroundColour},
    {sipName_SetOwnFont, SIP_MLMETH_CAST(meth_wxWindow_SetOwnFont), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetOwnFont},
    {sipName_SetOwnForegroundColour, SIP_MLMETH_CAST(meth_wxWindow_SetOwnForegroundColour), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetOwnForegroundColour},
    {sipName_SetPalette, SIP_MLMETH_CAST(meth_wxWindow_SetPalette), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetPalette},
    {sipName_SetPosition, SIP_MLMETH_CAST(meth_wxWindow_SetPosition), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetPosition},
    {sipName_SetPreviousHandler, SIP_MLMETH_CAST(meth_wxWindow_SetPreviousHandler), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetPreviousHandler},
    {sipName_SetScrollPos, SIP_MLMETH_CAST(meth_wxWindow_SetScrollPos), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetScrollPos},
    {sipName_SetScrollbar, SIP_MLMETH_CAST(meth_wxWindow_SetScrollbar), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetScrollbar},
    {sipName_SetSize, SIP_MLMETH_CAST(meth_wxWindow_SetSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetSize},
    {sipName_SetSizeHints, SIP_MLMETH_CAST(meth_wxWindow_SetSizeHints), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetSizeHints},
    {sipName_SetSizer, SIP_MLMETH_CAST(meth_wxWindow_SetSizer), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetSizer},
    {sipName_SetSizerAndFit, SIP_MLMETH_CAST(meth_wxWindow_SetSizerAndFit), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetSizerAndFit},
    {sipName_SetThemeEnabled, SIP_MLMETH_CAST(meth_wxWindow_SetThemeEnabled), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetThemeEnabled},
    {sipName_SetToolTip, SIP_MLMETH_CAST(meth_wxWindow_SetToolTip), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetToolTip},
    {sipName_SetTransparent, SIP_MLMETH_CAST(meth_wxWindow_SetTransparent), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetTransparent},
    {sipName_SetValidator, SIP_MLMETH_CAST(meth_wxWindow_SetValidator), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetValidator},
    {sipName_SetVirtualSize, SIP_MLMETH_CAST(meth_wxWindow_SetVirtualSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetVirtualSize},
    {sipName_SetWindowStyle, SIP_MLMETH_CAST(meth_wxWindow_SetWindowStyle), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetWindowStyle},
    {sipName_SetWindowStyleFlag, SIP_MLMETH_CAST(meth_wxWindow_SetWindowStyleFlag), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetWindowStyleFlag},
    {sipName_SetWindowVariant, SIP_MLMETH_CAST(meth_wxWindow_SetWindowVariant), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_SetWindowVariant},
    {sipName_ShouldInheritColours, meth_wxWindow_ShouldInheritColours, METH_VARARGS, doc_wxWindow_ShouldInheritColours},
    {sipName_Show, SIP_MLMETH_CAST(meth_wxWindow_Show), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_Show},
    {sipName_ShowWithEffect, SIP_MLMETH_CAST(meth_wxWindow_ShowWithEffect), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ShowWithEffect},
    {sipName_Thaw, meth_wxWindow_Thaw, METH_VARARGS, doc_wxWindow_Thaw},
    {sipName_ToDIP, SIP_MLMETH_CAST(meth_wxWindow_ToDIP), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ToDIP},
    {sipName_ToPhys, SIP_MLMETH_CAST(meth_wxWindow_ToPhys), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ToPhys},
    {sipName_ToggleWindowStyle, SIP_MLMETH_CAST(meth_wxWindow_ToggleWindowStyle), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_ToggleWindowStyle},
    {sipName_TransferDataFromWindow, meth_wxWindow_TransferDataFromWindow, METH_VARARGS, doc_wxWindow_TransferDataFromWindow},
    {sipName_TransferDataToWindow, meth_wxWindow_TransferDataToWindow, METH_VARARGS, doc_wxWindow_TransferDataToWindow},
    {sipName_TryAfter, SIP_MLMETH_CAST(meth_wxWindow_TryAfter), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_TryAfter},
    {sipName_TryBefore, SIP_MLMETH_CAST(meth_wxWindow_TryBefore), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_TryBefore},
    {sipName_UnregisterHotKey, SIP_MLMETH_CAST(meth_wxWindow_UnregisterHotKey), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_UnregisterHotKey},
    {sipName_UnreserveControlId, SIP_MLMETH_CAST(meth_wxWindow_UnreserveControlId), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_UnreserveControlId},
    {sipName_UnsetToolTip, meth_wxWindow_UnsetToolTip, METH_VARARGS, doc_wxWindow_UnsetToolTip},
    {sipName_Update, meth_wxWindow_Update, METH_VARARGS, doc_wxWindow_Update},
    {sipName_UpdateWindowUI, SIP_MLMETH_CAST(meth_wxWindow_UpdateWindowUI), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_UpdateWindowUI},
    {sipName_UseBackgroundColour, meth_wxWindow_UseBackgroundColour, METH_VARARGS, doc_wxWindow_UseBackgroundColour},
    {sipName_UseBgCol, meth_wxWindow_UseBgCol, METH_VARARGS, doc_wxWindow_UseBgCol},
    {sipName_UseForegroundColour, meth_wxWindow_UseForegroundColour, METH_VARARGS, doc_wxWindow_UseForegroundColour},
    {sipName_Validate, meth_wxWindow_Validate, METH_VARARGS, doc_wxWindow_Validate},
    {sipName_WarpPointer, SIP_MLMETH_CAST(meth_wxWindow_WarpPointer), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_WarpPointer},
    {sipName_WindowToClientSize, SIP_MLMETH_CAST(meth_wxWindow_WindowToClientSize), METH_VARARGS|METH_KEYWORDS, doc_wxWindow_WindowToClientSize}
};

sipVariableDef variables_wxWindow[] = {
    {PropertyVariable, sipName_MaxClientSize, &methods_wxWindow[103], &methods_wxWindow[233], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MinClientSize, &methods_wxWindow[107], &methods_wxWindow[235], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TopLevel, &methods_wxWindow[168], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Enabled, &methods_wxWindow[159], &methods_wxWindow[45], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Shown, &methods_wxWindow[165], &methods_wxWindow[260], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WindowVariant, &methods_wxWindow[137], &methods_wxWindow[258], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WindowStyleFlag, &methods_wxWindow[136], &methods_wxWindow[257], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WindowStyle, &methods_wxWindow[135], &methods_wxWindow[256], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_VirtualSize, &methods_wxWindow[133], &methods_wxWindow[255], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Validator, &methods_wxWindow[132], &methods_wxWindow[254], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_UpdateRegion, &methods_wxWindow[131], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_UpdateClientRect, &methods_wxWindow[130], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ToolTip, &methods_wxWindow[127], &methods_wxWindow[252], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ThemeEnabled, &methods_wxWindow[126], &methods_wxWindow[251], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Sizer, &methods_wxWindow[124], &methods_wxWindow[249], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Size, &methods_wxWindow[123], &methods_wxWindow[247], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ScreenRect, &methods_wxWindow[119], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ScreenPosition, &methods_wxWindow[118], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Position, &methods_wxWindow[115], &methods_wxWindow[243], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Parent, &methods_wxWindow[113], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Name, &methods_wxWindow[111], &methods_wxWindow[237], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MinWidth, &methods_wxWindow[110], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MinSize, &methods_wxWindow[109], &methods_wxWindow[236], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MinHeight, &methods_wxWindow[108], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MaxWidth, &methods_wxWindow[106], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MaxSize, &methods_wxWindow[105], &methods_wxWindow[234], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MaxHeight, &methods_wxWindow[104], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LayoutDirection, &methods_wxWindow[101], &methods_wxWindow[232], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Label, &methods_wxWindow[100], &methods_wxWindow[231], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Id, &methods_wxWindow[99], &methods_wxWindow[229], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_HelpText, &methods_wxWindow[97], &methods_wxWindow[228], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Handle, &methods_wxWindow[96], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TopLevelParent, &methods_wxWindow[129], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GrandParent, &methods_wxWindow[94], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ForegroundColour, &methods_wxWindow[92], &methods_wxWindow[227], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Font, &methods_wxWindow[91], &methods_wxWindow[226], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ExtraStyle, &methods_wxWindow[90], &methods_wxWindow[223], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_EventHandler, &methods_wxWindow[89], &methods_wxWindow[222], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DropTarget, &methods_wxWindow[87], &methods_wxWindow[221], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultAttributes, &methods_wxWindow[84], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Cursor, &methods_wxWindow[81], &methods_wxWindow[218], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ContainingSizer, &methods_wxWindow[79], &methods_wxWindow[217], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Constraints, &methods_wxWindow[78], &methods_wxWindow[216], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ClientSize, &methods_wxWindow[77], &methods_wxWindow[215], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ClientAreaOrigin, &methods_wxWindow[75], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Children, &methods_wxWindow[73], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CharWidth, &methods_wxWindow[72], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CharHeight, &methods_wxWindow[71], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Caret, &methods_wxWindow[70], &methods_wxWindow[214], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Border, &methods_wxWindow[68], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_BestVirtualSize, &methods_wxWindow[66], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_BestSize, &methods_wxWindow[65], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_EffectiveMinSize, &methods_wxWindow[88], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_BackgroundStyle, &methods_wxWindow[63], &methods_wxWindow[212], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_BackgroundColour, &methods_wxWindow[62], &methods_wxWindow[211], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AutoLayout, &methods_wxWindow[61], &methods_wxWindow[210], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AcceleratorTable, &methods_wxWindow[59], &methods_wxWindow[208], SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxWindow, "Window()\n"
"Window(parent, id=ID_ANY, pos=DefaultPosition, size=DefaultSize, style=0, name=PanelNameStr)\n"
"\n"
"wxWindow is the base class for all windows and represents any visible\n"
"object on screen.");


sipClassTypeDef sipTypeDef__core_wxWindow = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxWindow,
        SIP_NULLPTR,
        SIP_NULLPTR
    },
    {
        sipNameNr_Window,
        {0, 0, 1},
        281, methods_wxWindow,
        0, SIP_NULLPTR,
        57, variables_wxWindow,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxWindow,
    -1,
    -1,
    supers_wxWindow,
    SIP_NULLPTR,
    init_type_wxWindow,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    dealloc_wxWindow,
    SIP_NULLPTR,
    array_wxWindow,
    SIP_NULLPTR,
    release_wxWindow,
    cast_wxWindow,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
};
