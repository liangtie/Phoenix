/*
 * Interface wrapper code.
 *
 * Generated by SIP 6.7.9
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_stc.h"
        #include <wx/stc/stc.h>
        #include <wx/window.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/textctrl.h>
        #include <wx/textcompleter.h>
        #include <wx/window.h>
        #include <wx/versioninfo.h>
        #include <wx/bitmap.h>
        #include <wx/scrolbar.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/font.h>
        #include <wx/colour.h>
        #include <wx/dc.h>
        #include <wx/gdicmn.h>
        #include <wx/event.h>
        #include <wx/validate.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/cursor.h>
        #include <wx/caret.h>
        #include <wx/layout.h>
        #include <wx/sizer.h>
        #include <wx/dnd.h>
        #include <wx/access.h>
        #include <wx/accel.h>
        #include <wx/menu.h>
        #include <wx/tooltip.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/palette.h>
        #include <wx/region.h>
        #include <wx/eventfilter.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>
    void _wxStyledTextCtrl_MarkerDefineRGBAImage(wxStyledTextCtrl* self, int markerNumber, wxPyBuffer* pixels)
    {
        self->MarkerDefineRGBAImage(markerNumber, (unsigned char*)pixels->m_ptr);
    }
    void _wxStyledTextCtrl_RegisterRGBAImage(wxStyledTextCtrl* self, int type, wxPyBuffer* pixels)
    {
        self->RegisterRGBAImage(type, (unsigned char*)pixels->m_ptr);
    }
    PyObject* _wxStyledTextCtrl_GetCharacterPointer(wxStyledTextCtrl* self)
    {
        
                    const char* ptr = self->GetCharacterPointer();
                    Py_ssize_t len = self->GetLength();
                    PyObject* rv;
                    wxPyBLOCK_THREADS( rv = wxPyMakeBuffer((void*)ptr, len, true) );
                    return rv;
    }
    PyObject* _wxStyledTextCtrl_GetRangePointer(wxStyledTextCtrl* self, int position, int rangeLength)
    {
        
                    const char* ptr = self->GetRangePointer(position, rangeLength);
                    Py_ssize_t len = rangeLength;
                    PyObject* rv;
                    wxPyBLOCK_THREADS( rv = wxPyMakeBuffer((void*)ptr, len, true) );
                    return rv;
    }
    void _wxStyledTextCtrl_write(wxStyledTextCtrl* self, const wxString* text)
    {
        self->AppendText(*text);
    }
    void _wxStyledTextCtrl_flush(wxStyledTextCtrl* self)
    {
        
    }


class sipwxStyledTextCtrl : public  ::wxStyledTextCtrl
{
public:
    sipwxStyledTextCtrl( ::wxWindow*, ::wxWindowID,const  ::wxPoint&,const  ::wxSize&,long,const  ::wxString&);
    sipwxStyledTextCtrl();
    virtual ~sipwxStyledTextCtrl();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    void sipProtect_SendDestroyEvent();
    bool sipProtectVirt_ProcessEvent(bool, ::wxEvent&);
    void sipProtectVirt_DoEnable(bool,bool);
    void sipProtectVirt_DoGetPosition(bool,int*,int*) const;
    void sipProtectVirt_DoGetSize(bool,int*,int*) const;
    void sipProtectVirt_DoGetClientSize(bool,int*,int*) const;
     ::wxSize sipProtectVirt_DoGetBestSize(bool) const;
     ::wxSize sipProtectVirt_DoGetBestClientSize(bool) const;
    void sipProtectVirt_DoSetSize(bool,int,int,int,int,int);
    void sipProtectVirt_DoSetClientSize(bool,int,int);
    void sipProtectVirt_DoSetSizeHints(bool,int,int,int,int,int,int);
    void sipProtectVirt_DoMoveWindow(bool,int,int,int,int);
    void sipProtectVirt_DoSetWindowVariant(bool, ::wxWindowVariant);
     ::wxBorder sipProtectVirt_GetDefaultBorder(bool) const;
     ::wxBorder sipProtectVirt_GetDefaultBorderForControl(bool) const;
    void sipProtectVirt_DoFreeze(bool);
    void sipProtectVirt_DoThaw(bool);
    bool sipProtectVirt_HasTransparentBackground(bool);
    bool sipProtectVirt_TryBefore(bool, ::wxEvent&);
    bool sipProtectVirt_TryAfter(bool, ::wxEvent&);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool CanCut() const SIP_OVERRIDE;
    bool CanCopy() const SIP_OVERRIDE;
     ::wxTextCtrlHitTestResult HitTest(const  ::wxPoint&, ::wxTextCoord*, ::wxTextCoord*) const SIP_OVERRIDE;
     ::wxTextCtrlHitTestResult HitTest(const  ::wxPoint&,long*) const SIP_OVERRIDE;
    void ShowPosition(long) SIP_OVERRIDE;
    bool PositionToXY(long,long*,long*) const SIP_OVERRIDE;
    long XYToPosition(long,long) const SIP_OVERRIDE;
    bool SetDefaultStyle(const  ::wxTextAttr&) SIP_OVERRIDE;
    bool GetStyle(long, ::wxTextAttr&) SIP_OVERRIDE;
    bool SetStyle(long,long,const  ::wxTextAttr&) SIP_OVERRIDE;
    void DiscardEdits() SIP_OVERRIDE;
    void MarkDirty() SIP_OVERRIDE;
    bool IsModified() const SIP_OVERRIDE;
    int GetNumberOfLines() const SIP_OVERRIDE;
     ::wxString GetLineText(long) const SIP_OVERRIDE;
    int GetLineLength(long) const SIP_OVERRIDE;
    void SetEditable(bool) SIP_OVERRIDE;
    bool IsEditable() const SIP_OVERRIDE;
    void GetSelection(long*,long*) const SIP_OVERRIDE;
    void SelectNone() SIP_OVERRIDE;
    void SetSelection(long,long) SIP_OVERRIDE;
    long GetLastPosition() const SIP_OVERRIDE;
    long GetInsertionPoint() const SIP_OVERRIDE;
    void SetInsertionPoint(long) SIP_OVERRIDE;
    void Replace(long,long,const  ::wxString&) SIP_OVERRIDE;
    void Remove(long,long) SIP_OVERRIDE;
    void WriteText(const  ::wxString&) SIP_OVERRIDE;
    void SelectAll() SIP_OVERRIDE;
    void Undo() SIP_OVERRIDE;
    bool CanUndo() const SIP_OVERRIDE;
    bool CanRedo() const SIP_OVERRIDE;
    void Redo() SIP_OVERRIDE;
    void Clear() SIP_OVERRIDE;
    void Paste() SIP_OVERRIDE;
    void Copy() SIP_OVERRIDE;
    void Cut() SIP_OVERRIDE;
    bool CanPaste() const SIP_OVERRIDE;
    void AppendText(const  ::wxString&) SIP_OVERRIDE;
     ::wxSize DoGetBestClientSize() const SIP_OVERRIDE;
     ::wxSize DoGetBestSize() const SIP_OVERRIDE;
    void DoThaw() SIP_OVERRIDE;
    void DoFreeze() SIP_OVERRIDE;
     ::wxBorder GetDefaultBorderForControl() const SIP_OVERRIDE;
     ::wxBorder GetDefaultBorder() const SIP_OVERRIDE;
    void DoSetWindowVariant( ::wxWindowVariant) SIP_OVERRIDE;
    void DoMoveWindow(int,int,int,int) SIP_OVERRIDE;
    void DoSetSizeHints(int,int,int,int,int,int) SIP_OVERRIDE;
    void DoSetClientSize(int,int) SIP_OVERRIDE;
    void DoSetSize(int,int,int,int,int) SIP_OVERRIDE;
    void DoGetClientSize(int*,int*) const SIP_OVERRIDE;
    void DoGetSize(int*,int*) const SIP_OVERRIDE;
    void DoGetPosition(int*,int*) const SIP_OVERRIDE;
    void DoEnable(bool) SIP_OVERRIDE;
     ::wxWindow* GetMainWindowOfCompositeControl() SIP_OVERRIDE;
    void OnInternalIdle() SIP_OVERRIDE;
    void InitDialog() SIP_OVERRIDE;
    void InheritAttributes() SIP_OVERRIDE;
    bool Destroy() SIP_OVERRIDE;
    bool Validate() SIP_OVERRIDE;
    bool TransferDataToWindow() SIP_OVERRIDE;
    bool TransferDataFromWindow() SIP_OVERRIDE;
    void SetValidator(const  ::wxValidator&) SIP_OVERRIDE;
     ::wxValidator* GetValidator() SIP_OVERRIDE;
    bool ShouldInheritColours() const SIP_OVERRIDE;
    bool HasTransparentBackground() SIP_OVERRIDE;
     ::wxPoint GetClientAreaOrigin() const SIP_OVERRIDE;
    bool InformFirstDirection(int,int,int) SIP_OVERRIDE;
    void EnableVisibleFocus(bool) SIP_OVERRIDE;
    void SetCanFocus(bool) SIP_OVERRIDE;
    bool AcceptsFocusRecursively() const SIP_OVERRIDE;
    bool AcceptsFocusFromKeyboard() const SIP_OVERRIDE;
    bool AcceptsFocus() const SIP_OVERRIDE;
    bool TryAfter( ::wxEvent&) SIP_OVERRIDE;
    bool TryBefore( ::wxEvent&) SIP_OVERRIDE;
    bool ProcessEvent( ::wxEvent&) SIP_OVERRIDE;
    void AddChild( ::wxWindowBase*) SIP_OVERRIDE;
    void RemoveChild( ::wxWindowBase*) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxStyledTextCtrl(const sipwxStyledTextCtrl &);
    sipwxStyledTextCtrl &operator = (const sipwxStyledTextCtrl &);

    char sipPyMethods[77];
};

sipwxStyledTextCtrl::sipwxStyledTextCtrl( ::wxWindow*parent, ::wxWindowID id,const  ::wxPoint& pos,const  ::wxSize& size,long style,const  ::wxString& name):  ::wxStyledTextCtrl(parent,id,pos,size,style,name), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxStyledTextCtrl::sipwxStyledTextCtrl():  ::wxStyledTextCtrl(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxStyledTextCtrl::~sipwxStyledTextCtrl()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipwxStyledTextCtrl::CanCut() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[0]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanCut);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::CanCut();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::CanCopy() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[1]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanCopy);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::CanCopy();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxTextCtrlHitTestResult sipwxStyledTextCtrl::HitTest(const  ::wxPoint& pt, ::wxTextCoord*col, ::wxTextCoord*row) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[2]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_HitTest);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::HitTest(pt,col,row);

    extern  ::wxTextCtrlHitTestResult sipVH__stc_33(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxPoint&, ::wxTextCoord*, ::wxTextCoord*);

    return sipVH__stc_33(sipGILState, 0, sipPySelf, sipMeth, pt, col, row);
}

 ::wxTextCtrlHitTestResult sipwxStyledTextCtrl::HitTest(const  ::wxPoint& pt,long*pos) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[3]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_HitTestPos);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::HitTest(pt,pos);

    extern  ::wxTextCtrlHitTestResult sipVH__stc_32(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxPoint&,long*);

    return sipVH__stc_32(sipGILState, 0, sipPySelf, sipMeth, pt, pos);
}

void sipwxStyledTextCtrl::ShowPosition(long pos)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[4], &sipPySelf, SIP_NULLPTR, sipName_ShowPosition);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::ShowPosition(pos);
        return;
    }

    extern void sipVH__stc_21(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long);

    sipVH__stc_21(sipGILState, 0, sipPySelf, sipMeth, pos);
}

bool sipwxStyledTextCtrl::PositionToXY(long pos,long*x,long*y) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[5]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_PositionToXY);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::PositionToXY(pos,x,y);

    extern bool sipVH__stc_31(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long,long*,long*);

    return sipVH__stc_31(sipGILState, 0, sipPySelf, sipMeth, pos, x, y);
}

long sipwxStyledTextCtrl::XYToPosition(long x,long y) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[6]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_XYToPosition);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::XYToPosition(x,y);

    extern long sipVH__stc_30(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long,long);

    return sipVH__stc_30(sipGILState, 0, sipPySelf, sipMeth, x, y);
}

bool sipwxStyledTextCtrl::SetDefaultStyle(const  ::wxTextAttr& style)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[7], &sipPySelf, SIP_NULLPTR, sipName_SetDefaultStyle);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::SetDefaultStyle(style);

    extern bool sipVH__stc_29(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxTextAttr&);

    return sipVH__stc_29(sipGILState, 0, sipPySelf, sipMeth, style);
}

bool sipwxStyledTextCtrl::GetStyle(long position, ::wxTextAttr& style)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[8], &sipPySelf, SIP_NULLPTR, sipName_GetStyle);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetStyle(position,style);

    extern bool sipVH__stc_28(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long, ::wxTextAttr&);

    return sipVH__stc_28(sipGILState, 0, sipPySelf, sipMeth, position, style);
}

bool sipwxStyledTextCtrl::SetStyle(long start,long end,const  ::wxTextAttr& style)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[9], &sipPySelf, SIP_NULLPTR, sipName_SetStyle);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::SetStyle(start,end,style);

    extern bool sipVH__stc_27(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long,long,const  ::wxTextAttr&);

    return sipVH__stc_27(sipGILState, 0, sipPySelf, sipMeth, start, end, style);
}

void sipwxStyledTextCtrl::DiscardEdits()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[10], &sipPySelf, SIP_NULLPTR, sipName_DiscardEdits);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DiscardEdits();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::MarkDirty()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[11], &sipPySelf, SIP_NULLPTR, sipName_MarkDirty);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::MarkDirty();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::IsModified() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[12]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_IsModified);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::IsModified();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipwxStyledTextCtrl::GetNumberOfLines() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[13]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetNumberOfLines);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetNumberOfLines();

    extern int sipVH__stc_26(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_26(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxString sipwxStyledTextCtrl::GetLineText(long lineNo) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[14]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetLineText);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetLineText(lineNo);

    extern  ::wxString sipVH__stc_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long);

    return sipVH__stc_25(sipGILState, 0, sipPySelf, sipMeth, lineNo);
}

int sipwxStyledTextCtrl::GetLineLength(long lineNo) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[15]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetLineLength);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetLineLength(lineNo);

    extern int sipVH__stc_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long);

    return sipVH__stc_24(sipGILState, 0, sipPySelf, sipMeth, lineNo);
}

void sipwxStyledTextCtrl::SetEditable(bool editable)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[16], &sipPySelf, SIP_NULLPTR, sipName_SetEditable);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::SetEditable(editable);
        return;
    }

    extern void sipVH__stc_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__stc_3(sipGILState, 0, sipPySelf, sipMeth, editable);
}

bool sipwxStyledTextCtrl::IsEditable() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[17]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_IsEditable);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::IsEditable();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::GetSelection(long*from_,long*to_) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[18]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetSelection);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::GetSelection(from_,to_);
        return;
    }

    extern void sipVH__stc_23(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long*,long*);

    sipVH__stc_23(sipGILState, 0, sipPySelf, sipMeth, from_, to_);
}

void sipwxStyledTextCtrl::SelectNone()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[19], &sipPySelf, SIP_NULLPTR, sipName_SelectNone);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::SelectNone();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::SetSelection(long from_,long to_)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[20], &sipPySelf, SIP_NULLPTR, sipName_SetSelection);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::SetSelection(from_,to_);
        return;
    }

    extern void sipVH__stc_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long,long);

    sipVH__stc_19(sipGILState, 0, sipPySelf, sipMeth, from_, to_);
}

long sipwxStyledTextCtrl::GetLastPosition() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[21]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetLastPosition);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetLastPosition();

    extern long sipVH__stc_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_22(sipGILState, 0, sipPySelf, sipMeth);
}

long sipwxStyledTextCtrl::GetInsertionPoint() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[22]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetInsertionPoint);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetInsertionPoint();

    extern long sipVH__stc_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_22(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::SetInsertionPoint(long pos)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[23], &sipPySelf, SIP_NULLPTR, sipName_SetInsertionPoint);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::SetInsertionPoint(pos);
        return;
    }

    extern void sipVH__stc_21(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long);

    sipVH__stc_21(sipGILState, 0, sipPySelf, sipMeth, pos);
}

void sipwxStyledTextCtrl::Replace(long from_,long to_,const  ::wxString& value)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[24], &sipPySelf, SIP_NULLPTR, sipName_Replace);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::Replace(from_,to_,value);
        return;
    }

    extern void sipVH__stc_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long,long,const  ::wxString&);

    sipVH__stc_20(sipGILState, 0, sipPySelf, sipMeth, from_, to_, value);
}

void sipwxStyledTextCtrl::Remove(long from_,long to_)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[25], &sipPySelf, SIP_NULLPTR, sipName_Remove);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::Remove(from_,to_);
        return;
    }

    extern void sipVH__stc_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long,long);

    sipVH__stc_19(sipGILState, 0, sipPySelf, sipMeth, from_, to_);
}

void sipwxStyledTextCtrl::WriteText(const  ::wxString& text)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[26], &sipPySelf, SIP_NULLPTR, sipName_WriteText);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::WriteText(text);
        return;
    }

    extern void sipVH__stc_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxString&);

    sipVH__stc_18(sipGILState, 0, sipPySelf, sipMeth, text);
}

void sipwxStyledTextCtrl::SelectAll()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[27], &sipPySelf, SIP_NULLPTR, sipName_SelectAll);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::SelectAll();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::Undo()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[28], &sipPySelf, SIP_NULLPTR, sipName_Undo);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::Undo();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::CanUndo() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[29]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanUndo);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::CanUndo();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::CanRedo() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[30]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanRedo);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::CanRedo();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::Redo()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[31], &sipPySelf, SIP_NULLPTR, sipName_Redo);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::Redo();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::Clear()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[32], &sipPySelf, SIP_NULLPTR, sipName_Clear);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::Clear();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::Paste()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[33], &sipPySelf, SIP_NULLPTR, sipName_Paste);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::Paste();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::Copy()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[34], &sipPySelf, SIP_NULLPTR, sipName_Copy);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::Copy();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::Cut()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[35], &sipPySelf, SIP_NULLPTR, sipName_Cut);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::Cut();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::CanPaste() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[36]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_CanPaste);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::CanPaste();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::AppendText(const  ::wxString& text)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[37], &sipPySelf, SIP_NULLPTR, sipName_AppendText);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::AppendText(text);
        return;
    }

    extern void sipVH__stc_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxString&);

    sipVH__stc_18(sipGILState, 0, sipPySelf, sipMeth, text);
}

 ::wxSize sipwxStyledTextCtrl::DoGetBestClientSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[38]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetBestClientSize);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::DoGetBestClientSize();

    extern  ::wxSize sipVH__stc_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_17(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxSize sipwxStyledTextCtrl::DoGetBestSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[39]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetBestSize);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::DoGetBestSize();

    extern  ::wxSize sipVH__stc_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_17(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::DoThaw()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[40], &sipPySelf, SIP_NULLPTR, sipName_DoThaw);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoThaw();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::DoFreeze()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[41], &sipPySelf, SIP_NULLPTR, sipName_DoFreeze);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoFreeze();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxStyledTextCtrl::GetDefaultBorderForControl() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[42]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetDefaultBorderForControl);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetDefaultBorderForControl();

    extern  ::wxBorder sipVH__stc_16(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_16(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxStyledTextCtrl::GetDefaultBorder() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[43]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetDefaultBorder);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetDefaultBorder();

    extern  ::wxBorder sipVH__stc_16(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_16(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::DoSetWindowVariant( ::wxWindowVariant variant)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[44], &sipPySelf, SIP_NULLPTR, sipName_DoSetWindowVariant);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoSetWindowVariant(variant);
        return;
    }

    extern void sipVH__stc_15(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowVariant);

    sipVH__stc_15(sipGILState, 0, sipPySelf, sipMeth, variant);
}

void sipwxStyledTextCtrl::DoMoveWindow(int x,int y,int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[45], &sipPySelf, SIP_NULLPTR, sipName_DoMoveWindow);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoMoveWindow(x,y,width,height);
        return;
    }

    extern void sipVH__stc_14(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int);

    sipVH__stc_14(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height);
}

void sipwxStyledTextCtrl::DoSetSizeHints(int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[46], &sipPySelf, SIP_NULLPTR, sipName_DoSetSizeHints);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH);
        return;
    }

    extern void sipVH__stc_13(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int,int);

    sipVH__stc_13(sipGILState, 0, sipPySelf, sipMeth, minW, minH, maxW, maxH, incW, incH);
}

void sipwxStyledTextCtrl::DoSetClientSize(int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[47], &sipPySelf, SIP_NULLPTR, sipName_DoSetClientSize);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoSetClientSize(width,height);
        return;
    }

    extern void sipVH__stc_12(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int);

    sipVH__stc_12(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxStyledTextCtrl::DoSetSize(int x,int y,int width,int height,int sizeFlags)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[48], &sipPySelf, SIP_NULLPTR, sipName_DoSetSize);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoSetSize(x,y,width,height,sizeFlags);
        return;
    }

    extern void sipVH__stc_11(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int);

    sipVH__stc_11(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height, sizeFlags);
}

void sipwxStyledTextCtrl::DoGetClientSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[49]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetClientSize);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoGetClientSize(width,height);
        return;
    }

    extern void sipVH__stc_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__stc_10(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxStyledTextCtrl::DoGetSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[50]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetSize);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoGetSize(width,height);
        return;
    }

    extern void sipVH__stc_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__stc_10(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxStyledTextCtrl::DoGetPosition(int*x,int*y) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[51]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_DoGetPosition);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoGetPosition(x,y);
        return;
    }

    extern void sipVH__stc_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__stc_10(sipGILState, 0, sipPySelf, sipMeth, x, y);
}

void sipwxStyledTextCtrl::DoEnable(bool enable)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[52], &sipPySelf, SIP_NULLPTR, sipName_DoEnable);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::DoEnable(enable);
        return;
    }

    extern void sipVH__stc_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__stc_3(sipGILState, 0, sipPySelf, sipMeth, enable);
}

 ::wxWindow* sipwxStyledTextCtrl::GetMainWindowOfCompositeControl()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[53], &sipPySelf, SIP_NULLPTR, sipName_GetMainWindowOfCompositeControl);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetMainWindowOfCompositeControl();

    extern  ::wxWindow* sipVH__stc_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_9(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::OnInternalIdle()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[54], &sipPySelf, SIP_NULLPTR, sipName_OnInternalIdle);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::OnInternalIdle();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::InitDialog()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[55], &sipPySelf, SIP_NULLPTR, sipName_InitDialog);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::InitDialog();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::InheritAttributes()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[56], &sipPySelf, SIP_NULLPTR, sipName_InheritAttributes);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::InheritAttributes();
        return;
    }

    extern void sipVH__stc_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__stc_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::Destroy()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[57], &sipPySelf, SIP_NULLPTR, sipName_Destroy);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::Destroy();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::Validate()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[58], &sipPySelf, SIP_NULLPTR, sipName_Validate);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::Validate();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::TransferDataToWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[59], &sipPySelf, SIP_NULLPTR, sipName_TransferDataToWindow);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::TransferDataToWindow();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::TransferDataFromWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[60], &sipPySelf, SIP_NULLPTR, sipName_TransferDataFromWindow);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::TransferDataFromWindow();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxStyledTextCtrl::SetValidator(const  ::wxValidator& validator)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[61], &sipPySelf, SIP_NULLPTR, sipName_SetValidator);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::SetValidator(validator);
        return;
    }

    extern void sipVH__stc_7(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxValidator&);

    sipVH__stc_7(sipGILState, 0, sipPySelf, sipMeth, validator);
}

 ::wxValidator* sipwxStyledTextCtrl::GetValidator()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[62], &sipPySelf, SIP_NULLPTR, sipName_GetValidator);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetValidator();

    extern  ::wxValidator* sipVH__stc_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_6(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::ShouldInheritColours() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[63]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_ShouldInheritColours);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::ShouldInheritColours();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::HasTransparentBackground()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[64], &sipPySelf, SIP_NULLPTR, sipName_HasTransparentBackground);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::HasTransparentBackground();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxPoint sipwxStyledTextCtrl::GetClientAreaOrigin() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[65]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_GetClientAreaOrigin);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::GetClientAreaOrigin();

    extern  ::wxPoint sipVH__stc_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_5(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::InformFirstDirection(int direction,int size,int availableOtherDir)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[66], &sipPySelf, SIP_NULLPTR, sipName_InformFirstDirection);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::InformFirstDirection(direction,size,availableOtherDir);

    extern bool sipVH__stc_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int);

    return sipVH__stc_4(sipGILState, 0, sipPySelf, sipMeth, direction, size, availableOtherDir);
}

void sipwxStyledTextCtrl::EnableVisibleFocus(bool enabled)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[67], &sipPySelf, SIP_NULLPTR, sipName_EnableVisibleFocus);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::EnableVisibleFocus(enabled);
        return;
    }

    extern void sipVH__stc_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__stc_3(sipGILState, 0, sipPySelf, sipMeth, enabled);
}

void sipwxStyledTextCtrl::SetCanFocus(bool canFocus)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[68], &sipPySelf, SIP_NULLPTR, sipName_SetCanFocus);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::SetCanFocus(canFocus);
        return;
    }

    extern void sipVH__stc_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__stc_3(sipGILState, 0, sipPySelf, sipMeth, canFocus);
}

bool sipwxStyledTextCtrl::AcceptsFocusRecursively() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[69]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocusRecursively);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::AcceptsFocusRecursively();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::AcceptsFocusFromKeyboard() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[70]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocusFromKeyboard);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::AcceptsFocusFromKeyboard();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::AcceptsFocus() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, const_cast<char *>(&sipPyMethods[71]), const_cast<sipSimpleWrapper **>(&sipPySelf), SIP_NULLPTR, sipName_AcceptsFocus);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::AcceptsFocus();

    extern bool sipVH__stc_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__stc_2(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxStyledTextCtrl::TryAfter( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[72], &sipPySelf, SIP_NULLPTR, sipName_TryAfter);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::TryAfter(event);

    extern bool sipVH__stc_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__stc_1(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxStyledTextCtrl::TryBefore( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[73], &sipPySelf, SIP_NULLPTR, sipName_TryBefore);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::TryBefore(event);

    extern bool sipVH__stc_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__stc_1(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxStyledTextCtrl::ProcessEvent( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[74], &sipPySelf, SIP_NULLPTR, sipName_ProcessEvent);

    if (!sipMeth)
        return  ::wxStyledTextCtrl::ProcessEvent(event);

    extern bool sipVH__stc_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__stc_1(sipGILState, 0, sipPySelf, sipMeth, event);
}

void sipwxStyledTextCtrl::AddChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[75], &sipPySelf, SIP_NULLPTR, sipName_AddChild);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::AddChild(child);
        return;
    }

    extern void sipVH__stc_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__stc_0(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxStyledTextCtrl::RemoveChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState, &sipPyMethods[76], &sipPySelf, SIP_NULLPTR, sipName_RemoveChild);

    if (!sipMeth)
    {
         ::wxStyledTextCtrl::RemoveChild(child);
        return;
    }

    extern void sipVH__stc_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__stc_0(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxStyledTextCtrl::sipProtect_SendDestroyEvent()
{
     ::wxWindow::SendDestroyEvent();
}

bool sipwxStyledTextCtrl::sipProtectVirt_ProcessEvent(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxControl::ProcessEvent(event) : ProcessEvent(event));
}

void sipwxStyledTextCtrl::sipProtectVirt_DoEnable(bool sipSelfWasArg,bool enable)
{
    (sipSelfWasArg ?  ::wxControl::DoEnable(enable) : DoEnable(enable));
}

void sipwxStyledTextCtrl::sipProtectVirt_DoGetPosition(bool sipSelfWasArg,int*x,int*y) const
{
    (sipSelfWasArg ?  ::wxControl::DoGetPosition(x,y) : DoGetPosition(x,y));
}

void sipwxStyledTextCtrl::sipProtectVirt_DoGetSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxControl::DoGetSize(width,height) : DoGetSize(width,height));
}

void sipwxStyledTextCtrl::sipProtectVirt_DoGetClientSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxControl::DoGetClientSize(width,height) : DoGetClientSize(width,height));
}

 ::wxSize sipwxStyledTextCtrl::sipProtectVirt_DoGetBestSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxControl::DoGetBestSize() : DoGetBestSize());
}

 ::wxSize sipwxStyledTextCtrl::sipProtectVirt_DoGetBestClientSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxControl::DoGetBestClientSize() : DoGetBestClientSize());
}

void sipwxStyledTextCtrl::sipProtectVirt_DoSetSize(bool sipSelfWasArg,int x,int y,int width,int height,int sizeFlags)
{
    (sipSelfWasArg ?  ::wxControl::DoSetSize(x,y,width,height,sizeFlags) : DoSetSize(x,y,width,height,sizeFlags));
}

void sipwxStyledTextCtrl::sipProtectVirt_DoSetClientSize(bool sipSelfWasArg,int width,int height)
{
    (sipSelfWasArg ?  ::wxControl::DoSetClientSize(width,height) : DoSetClientSize(width,height));
}

void sipwxStyledTextCtrl::sipProtectVirt_DoSetSizeHints(bool sipSelfWasArg,int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    (sipSelfWasArg ?  ::wxControl::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH) : DoSetSizeHints(minW,minH,maxW,maxH,incW,incH));
}

void sipwxStyledTextCtrl::sipProtectVirt_DoMoveWindow(bool sipSelfWasArg,int x,int y,int width,int height)
{
    (sipSelfWasArg ?  ::wxControl::DoMoveWindow(x,y,width,height) : DoMoveWindow(x,y,width,height));
}

void sipwxStyledTextCtrl::sipProtectVirt_DoSetWindowVariant(bool sipSelfWasArg, ::wxWindowVariant variant)
{
    (sipSelfWasArg ?  ::wxControl::DoSetWindowVariant(variant) : DoSetWindowVariant(variant));
}

 ::wxBorder sipwxStyledTextCtrl::sipProtectVirt_GetDefaultBorder(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxControl::GetDefaultBorder() : GetDefaultBorder());
}

 ::wxBorder sipwxStyledTextCtrl::sipProtectVirt_GetDefaultBorderForControl(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxControl::GetDefaultBorderForControl() : GetDefaultBorderForControl());
}

void sipwxStyledTextCtrl::sipProtectVirt_DoFreeze(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxControl::DoFreeze() : DoFreeze());
}

void sipwxStyledTextCtrl::sipProtectVirt_DoThaw(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxControl::DoThaw() : DoThaw());
}

bool sipwxStyledTextCtrl::sipProtectVirt_HasTransparentBackground(bool sipSelfWasArg)
{
    return (sipSelfWasArg ?  ::wxControl::HasTransparentBackground() : HasTransparentBackground());
}

bool sipwxStyledTextCtrl::sipProtectVirt_TryBefore(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxControl::TryBefore(event) : TryBefore(event));
}

bool sipwxStyledTextCtrl::sipProtectVirt_TryAfter(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxControl::TryAfter(event) : TryAfter(event));
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SendDestroyEvent, "SendDestroyEvent()\n"
"\n"
"Generate wxWindowDestroyEvent for this window.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SendDestroyEvent(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SendDestroyEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        sipwxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtect_SendDestroyEvent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SendDestroyEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ProcessEvent, "ProcessEvent(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ProcessEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ProcessEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_ProcessEvent(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ProcessEvent, doc_wxStyledTextCtrl_ProcessEvent);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoEnable, "DoEnable(self, enable: bool)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoEnable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoEnable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool enable;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoEnable(sipSelfWasArg,enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoEnable, doc_wxStyledTextCtrl_DoEnable);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoGetPosition, "DoGetPosition(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoGetPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoGetPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        const sipwxStyledTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetPosition(sipSelfWasArg,&x,&y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",x,y);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoGetPosition, doc_wxStyledTextCtrl_DoGetPosition);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoGetSize, "DoGetSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoGetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoGetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxStyledTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoGetSize, doc_wxStyledTextCtrl_DoGetSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoGetClientSize, "DoGetClientSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoGetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoGetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxStyledTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetClientSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoGetClientSize, doc_wxStyledTextCtrl_DoGetClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoGetBestSize, "DoGetBestSize(self) -> Size");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoGetBestSize(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoGetBestSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoGetBestSize, doc_wxStyledTextCtrl_DoGetBestSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoGetBestClientSize, "DoGetBestClientSize(self) -> Size");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoGetBestClientSize(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoGetBestClientSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestClientSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoGetBestClientSize, doc_wxStyledTextCtrl_DoGetBestClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoSetSize, "DoSetSize(self, x: int, y: int, width: int, height: int, sizeFlags: int)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoSetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoSetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        int sizeFlags;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
            sipName_sizeFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiiii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y, &width, &height, &sizeFlags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSize(sipSelfWasArg,x,y,width,height,sizeFlags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoSetSize, doc_wxStyledTextCtrl_DoSetSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoSetClientSize, "DoSetClientSize(self, width: int, height: int)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoSetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoSetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetClientSize(sipSelfWasArg,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoSetClientSize, doc_wxStyledTextCtrl_DoSetClientSize);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoSetSizeHints, "DoSetSizeHints(self, minW: int, minH: int, maxW: int, maxH: int, incW: int, incH: int)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoSetSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoSetSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int minW;
        int minH;
        int maxW;
        int maxH;
        int incW;
        int incH;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minW,
            sipName_minH,
            sipName_maxW,
            sipName_maxH,
            sipName_incW,
            sipName_incH,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiiiii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &minW, &minH, &maxW, &maxH, &incW, &incH))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSizeHints(sipSelfWasArg,minW,minH,maxW,maxH,incW,incH);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoSetSizeHints, doc_wxStyledTextCtrl_DoSetSizeHints);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoMoveWindow, "DoMoveWindow(self, x: int, y: int, width: int, height: int)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoMoveWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoMoveWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoMoveWindow(sipSelfWasArg,x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoMoveWindow, doc_wxStyledTextCtrl_DoMoveWindow);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoSetWindowVariant, "DoSetWindowVariant(self, variant: WindowVariant)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoSetWindowVariant(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoSetWindowVariant(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowVariant variant;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxWindowVariant, &variant))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetWindowVariant(sipSelfWasArg,variant);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoSetWindowVariant, doc_wxStyledTextCtrl_DoSetWindowVariant);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetDefaultBorder, "GetDefaultBorder(self) -> Border");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetDefaultBorder(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetDefaultBorder(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorder(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetDefaultBorder, doc_wxStyledTextCtrl_GetDefaultBorder);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetDefaultBorderForControl, "GetDefaultBorderForControl(self) -> Border");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetDefaultBorderForControl(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetDefaultBorderForControl(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorderForControl(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetDefaultBorderForControl, doc_wxStyledTextCtrl_GetDefaultBorderForControl);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoFreeze, "DoFreeze(self)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoFreeze(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoFreeze(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoFreeze(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoFreeze, doc_wxStyledTextCtrl_DoFreeze);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoThaw, "DoThaw(self)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoThaw(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoThaw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoThaw(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoThaw, doc_wxStyledTextCtrl_DoThaw);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HasTransparentBackground, "HasTransparentBackground(self) -> bool");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HasTransparentBackground(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HasTransparentBackground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_HasTransparentBackground(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HasTransparentBackground, doc_wxStyledTextCtrl_HasTransparentBackground);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_TryBefore, "TryBefore(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxStyledTextCtrl_TryBefore(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_TryBefore(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryBefore(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_TryBefore, doc_wxStyledTextCtrl_TryBefore);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_TryAfter, "TryAfter(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxStyledTextCtrl_TryAfter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_TryAfter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryAfter(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_TryAfter, doc_wxStyledTextCtrl_TryAfter);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Create, "Create(parent, id=ID_ANY, pos=DefaultPosition, size=DefaultSize, style=0, name=STCNameStr) -> bool\n"
"\n"
"Create the UI elements for a STC that was created with the default\n"
"ctor.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Create(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Create(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* parent;
         ::wxWindowID id = wxID_ANY;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        long style = 0;
        const  ::wxString& namedef = wxSTCNameStr;
        const  ::wxString* name = &namedef;
        int nameState = 0;
        sipWrapper *sipOwner = SIP_NULLPTR;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_parent,
            sipName_id,
            sipName_pos,
            sipName_size,
            sipName_style,
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJH|iJ1J1lJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxWindow, &parent, &sipOwner, &id, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, &style, sipType_wxString, &name, &nameState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Create(parent,id,*pos,*size,style,*name);
            Py_END_ALLOW_THREADS

            if (sipOwner)
                sipTransferTo(sipSelf, (PyObject *)sipOwner);
            else
                sipTransferBack(sipSelf);
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Create, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AddText, "AddText(text)\n"
"\n"
"Add text to the document at current position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AddText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AddText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AddText(*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AddText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AddStyledText, "AddStyledText(data)\n"
"\n"
"Add array of cells to document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AddStyledText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AddStyledText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxMemoryBuffer* data;
        int dataState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_data,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxMemoryBuffer, &data, &dataState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AddStyledText(*data);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxMemoryBuffer *>(data), sipType_wxMemoryBuffer, dataState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AddStyledText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_InsertText, "InsertText(pos, text)\n"
"\n"
"Insert string at a position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_InsertText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_InsertText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->InsertText(pos,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_InsertText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ChangeInsertion, "ChangeInsertion(length, text)\n"
"\n"
"Change the text that is being inserted in response to\n"
"wxSTC_MOD_INSERTCHECK.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ChangeInsertion(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ChangeInsertion(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int length;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_length,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &length, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ChangeInsertion(length,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ChangeInsertion, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ClearAll, "ClearAll()\n"
"\n"
"Delete all text in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ClearAll(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ClearAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearAll();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ClearAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DeleteRange, "DeleteRange(start, lengthDelete)\n"
"\n"
"Delete a range of text in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DeleteRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DeleteRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int lengthDelete;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_lengthDelete,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &lengthDelete))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DeleteRange(start,lengthDelete);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DeleteRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ClearDocumentStyle, "ClearDocumentStyle()\n"
"\n"
"Set all style bytes to 0, remove all folding information.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ClearDocumentStyle(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ClearDocumentStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearDocumentStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ClearDocumentStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCharAt, "GetCharAt(pos) -> int\n"
"\n"
"Returns the character byte at the position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCharAt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCharAt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCharAt(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCharAt, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetStyleAt, "GetStyleAt(pos) -> int\n"
"\n"
"Returns the style byte at the position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetStyleAt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetStyleAt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyleAt(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetStyleAt, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSavePoint, "SetSavePoint()\n"
"\n"
"Remember the current position in the undo history as the position at\n"
"which the document was saved.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSavePoint(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSavePoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSavePoint();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSavePoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetStyledText, "GetStyledText(startPos, endPos) -> MemoryBuffer\n"
"\n"
"Retrieve a buffer of cells.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetStyledText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetStyledText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int startPos;
        int endPos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_startPos,
            sipName_endPos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &startPos, &endPos))
        {
             ::wxMemoryBuffer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxMemoryBuffer(sipCpp->GetStyledText(startPos,endPos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxMemoryBuffer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetStyledText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetReadOnly, "GetReadOnly() -> bool\n"
"\n"
"In read-only mode?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetReadOnly(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetReadOnly(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetReadOnly();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetReadOnly, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLine, "GetLine(line) -> String\n"
"\n"
"Retrieve the contents of a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLine(line));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTextRange, "GetTextRange(startPos, endPos) -> String\n"
"\n"
"Retrieve a range of text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTextRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTextRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int startPos;
        int endPos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_startPos,
            sipName_endPos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &startPos, &endPos))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetTextRange(startPos,endPos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTextRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ReplaceSelection, "ReplaceSelection(text)\n"
"\n"
"Replace the selected text with the argument text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ReplaceSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ReplaceSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ReplaceSelection(*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ReplaceSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetReadOnly, "SetReadOnly(readOnly)\n"
"\n"
"Set to read only or read write.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetReadOnly(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetReadOnly(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool readOnly;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_readOnly,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &readOnly))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetReadOnly(readOnly);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetReadOnly, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetText, "SetText(text)\n"
"\n"
"Replace the contents of the document with the argument text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetText(*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetText, "GetText() -> String\n"
"\n"
"Retrieve all the text in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetText(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetText());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AppendText, "AppendText(text)\n"
"\n"
"Append a string to the end of the document without changing the\n"
"selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AppendText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AppendText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::AppendText(*text) : sipCpp->AppendText(*text));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AppendText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Allocate, "Allocate(bytes)\n"
"\n"
"Enlarge the document to a particular size of text bytes.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Allocate(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Allocate(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int bytes;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bytes,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &bytes))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Allocate(bytes);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Allocate, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ReleaseAllExtendedStyles, "ReleaseAllExtendedStyles()\n"
"\n"
"Release all extended (>255) style numbers.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ReleaseAllExtendedStyles(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ReleaseAllExtendedStyles(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ReleaseAllExtendedStyles();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ReleaseAllExtendedStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AllocateExtendedStyles, "AllocateExtendedStyles(numberStyles) -> int\n"
"\n"
"Allocate some extended (>255) style numbers and return the start of\n"
"the range.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AllocateExtendedStyles(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AllocateExtendedStyles(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int numberStyles;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_numberStyles,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &numberStyles))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AllocateExtendedStyles(numberStyles);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AllocateExtendedStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FindText, "FindText(minPos, maxPos, text, flags=0) -> (int, findEnd)\n"
"\n"
"Find some text in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FindText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FindText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int minPos;
        int maxPos;
        const  ::wxString* text;
        int textState = 0;
        int flags = 0;
        int findEnd;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minPos,
            sipName_maxPos,
            sipName_text,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ1|i", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &minPos, &maxPos, sipType_wxString, &text, &textState, &flags))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindText(minPos,maxPos,*text,flags,&findEnd);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",sipRes,findEnd);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FindText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTargetStart, "SetTargetStart(start)\n"
"\n"
"Sets the position that starts the target which is used for updating\n"
"the document without affecting the scroll position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTargetStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTargetStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTargetStart(start);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTargetStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTargetStart, "GetTargetStart() -> int\n"
"\n"
"Get the position that starts the target.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTargetStart(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTargetStart(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTargetStart();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTargetStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTargetEnd, "SetTargetEnd(end)\n"
"\n"
"Sets the position that ends the target which is used for updating the\n"
"document without affecting the scroll position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTargetEnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTargetEnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int end;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_end,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &end))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTargetEnd(end);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTargetEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTargetEnd, "GetTargetEnd() -> int\n"
"\n"
"Get the position that ends the target.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTargetEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTargetEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTargetEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTargetEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTargetRange, "SetTargetRange(start, end)\n"
"\n"
"Sets both the start and end of the target in one call.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTargetRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTargetRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int end;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &end))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTargetRange(start,end);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTargetRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTargetText, "GetTargetText() -> String\n"
"\n"
"Retrieve the text in the target.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTargetText(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTargetText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetTargetText());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTargetText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_TargetFromSelection, "TargetFromSelection()\n"
"\n"
"Make the target range start and end be the same as the selection range\n"
"start and end.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_TargetFromSelection(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_TargetFromSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->TargetFromSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_TargetFromSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_TargetWholeDocument, "TargetWholeDocument()\n"
"\n"
"Sets the target to the whole document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_TargetWholeDocument(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_TargetWholeDocument(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->TargetWholeDocument();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_TargetWholeDocument, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ReplaceTarget, "ReplaceTarget(text) -> int\n"
"\n"
"Replace the target text with the argument text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ReplaceTarget(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ReplaceTarget(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ReplaceTarget(*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ReplaceTarget, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ReplaceTargetRE, "ReplaceTargetRE(text) -> int\n"
"\n"
"Replace the target text with the argument text after \\d processing.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ReplaceTargetRE(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ReplaceTargetRE(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ReplaceTargetRE(*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ReplaceTargetRE, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SearchInTarget, "SearchInTarget(text) -> int\n"
"\n"
"Search for a counted string in the target and set the target to the\n"
"found range.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SearchInTarget(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SearchInTarget(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SearchInTarget(*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SearchInTarget, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSearchFlags, "SetSearchFlags(searchFlags)\n"
"\n"
"Set the search flags used by SearchInTarget.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSearchFlags(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSearchFlags(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int searchFlags;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_searchFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &searchFlags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSearchFlags(searchFlags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSearchFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSearchFlags, "GetSearchFlags() -> int\n"
"\n"
"Get the search flags used by SearchInTarget.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSearchFlags(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSearchFlags(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSearchFlags();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSearchFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTag, "GetTag(tagNumber) -> String\n"
"\n"
"Retrieve the value of a tag from a regular expression search.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTag(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTag(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int tagNumber;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_tagNumber,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &tagNumber))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetTag(tagNumber));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTag, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SearchAnchor, "SearchAnchor()\n"
"\n"
"Sets the current caret position to be the search anchor.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SearchAnchor(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SearchAnchor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SearchAnchor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SearchAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SearchNext, "SearchNext(searchFlags, text) -> int\n"
"\n"
"Find some text starting at the search anchor.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SearchNext(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SearchNext(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int searchFlags;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_searchFlags,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &searchFlags, sipType_wxString, &text, &textState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SearchNext(searchFlags,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SearchNext, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SearchPrev, "SearchPrev(searchFlags, text) -> int\n"
"\n"
"Find some text starting at the search anchor and moving backwards.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SearchPrev(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SearchPrev(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int searchFlags;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_searchFlags,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &searchFlags, sipType_wxString, &text, &textState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SearchPrev(searchFlags,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SearchPrev, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetOvertype, "SetOvertype(overType)\n"
"\n"
"Set to overtype (true) or insert mode.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetOvertype(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetOvertype(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool overType;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_overType,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &overType))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetOvertype(overType);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetOvertype, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetOvertype, "GetOvertype() -> bool\n"
"\n"
"Returns true if overtype mode is active otherwise false is returned.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetOvertype(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetOvertype(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetOvertype();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetOvertype, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CanPaste, "CanPaste() -> bool\n"
"\n"
"Will a paste succeed?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CanPaste(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CanPaste(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::CanPaste() : sipCpp->CanPaste());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CanPaste, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Cut, "Cut()\n"
"\n"
"Cut the selection to the clipboard.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Cut(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Cut(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::Cut() : sipCpp->Cut());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Cut, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Copy, "Copy()\n"
"\n"
"Copy the selection to the clipboard.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Copy(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Copy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::Copy() : sipCpp->Copy());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Copy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Paste, "Paste()\n"
"\n"
"Paste the contents of the clipboard into the document replacing the\n"
"selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Paste(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Paste(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::Paste() : sipCpp->Paste());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Paste, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Clear, "Clear()\n"
"\n"
"Clear the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Clear(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Clear(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::Clear() : sipCpp->Clear());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Clear, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CopyRange, "CopyRange(start, end)\n"
"\n"
"Copy a range of text to the clipboard.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CopyRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CopyRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int end;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &end))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CopyRange(start,end);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CopyRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CopyText, "CopyText(length, text)\n"
"\n"
"Copy argument text to the clipboard.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CopyText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CopyText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int length;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_length,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &length, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CopyText(length,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CopyText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetPasteConvertEndings, "SetPasteConvertEndings(convert)\n"
"\n"
"Enable/Disable convert-on-paste for line endings.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetPasteConvertEndings(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetPasteConvertEndings(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool convert;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_convert,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &convert))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPasteConvertEndings(convert);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetPasteConvertEndings, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPasteConvertEndings, "GetPasteConvertEndings() -> bool\n"
"\n"
"Get convert-on-paste setting.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPasteConvertEndings(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPasteConvertEndings(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPasteConvertEndings();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPasteConvertEndings, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CopyAllowLine, "CopyAllowLine()\n"
"\n"
"Copy the selection, if selection empty copy the line with the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CopyAllowLine(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CopyAllowLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CopyAllowLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CopyAllowLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetStatus, "SetStatus(status)\n"
"\n"
"Change error status - 0 = OK.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetStatus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetStatus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int status;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_status,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &status))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetStatus(status);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetStatus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetStatus, "GetStatus() -> int\n"
"\n"
"Get error status.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetStatus(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetStatus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStatus();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetStatus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Redo, "Redo()\n"
"\n"
"Redoes the next action on the undo history.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Redo(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Redo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::Redo() : sipCpp->Redo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Redo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetUndoCollection, "SetUndoCollection(collectUndo)\n"
"\n"
"Choose between collecting actions into the undo history and discarding\n"
"them.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetUndoCollection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetUndoCollection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool collectUndo;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_collectUndo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &collectUndo))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetUndoCollection(collectUndo);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetUndoCollection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CanRedo, "CanRedo() -> bool\n"
"\n"
"Are there any redoable actions in the undo history?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CanRedo(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CanRedo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::CanRedo() : sipCpp->CanRedo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CanRedo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetUndoCollection, "GetUndoCollection() -> bool\n"
"\n"
"Is undo history being collected?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetUndoCollection(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetUndoCollection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetUndoCollection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetUndoCollection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_BeginUndoAction, "BeginUndoAction()\n"
"\n"
"Start a sequence of actions that is undone and redone as a unit.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_BeginUndoAction(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_BeginUndoAction(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->BeginUndoAction();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_BeginUndoAction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_EndUndoAction, "EndUndoAction()\n"
"\n"
"End a sequence of actions that is undone and redone as a unit.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_EndUndoAction(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_EndUndoAction(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EndUndoAction();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_EndUndoAction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CanUndo, "CanUndo() -> bool\n"
"\n"
"Are there any undoable actions in the undo history?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CanUndo(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CanUndo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::CanUndo() : sipCpp->CanUndo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CanUndo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_EmptyUndoBuffer, "EmptyUndoBuffer()\n"
"\n"
"Delete the undo history.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_EmptyUndoBuffer(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_EmptyUndoBuffer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EmptyUndoBuffer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_EmptyUndoBuffer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Undo, "Undo()\n"
"\n"
"Undo one action in the undo history.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Undo(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Undo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::Undo() : sipCpp->Undo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Undo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AddUndoAction, "AddUndoAction(token, flags)\n"
"\n"
"Add a container action to the undo stack.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AddUndoAction(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AddUndoAction(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int token;
        int flags;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_token,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &token, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AddUndoAction(token,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AddUndoAction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLength, "GetLength() -> int\n"
"\n"
"Returns the number of bytes in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLength(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLength(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLength();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLength, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCurrentPos, "GetCurrentPos() -> int\n"
"\n"
"Returns the position of the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCurrentPos(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCurrentPos(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCurrentPos();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCurrentPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetAnchor, "GetAnchor() -> int\n"
"\n"
"Returns the position of the opposite end of the selection to the\n"
"caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetAnchor(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetAnchor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAnchor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SelectAll, "SelectAll()\n"
"\n"
"Select all the text in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SelectAll(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SelectAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::SelectAll() : sipCpp->SelectAll());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SelectAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PositionFromPoint, "PositionFromPoint(pt) -> int\n"
"\n"
"Find the position from a point within the window.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PositionFromPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PositionFromPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxPoint* pt;
        int ptState = 0;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PositionFromPoint(*pt);
            Py_END_ALLOW_THREADS
            sipReleaseType(pt, sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PositionFromPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PositionFromPointClose, "PositionFromPointClose(x, y) -> int\n"
"\n"
"Find the position from a point within the window but return\n"
"wxSTC_INVALID_POSITION if not close to text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PositionFromPointClose(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PositionFromPointClose(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PositionFromPointClose(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PositionFromPointClose, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GotoLine, "GotoLine(line)\n"
"\n"
"Set caret to start of a line and ensure it is visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GotoLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GotoLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GotoLine(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GotoLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GotoPos, "GotoPos(caret)\n"
"\n"
"Set caret to a position and ensure it is visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GotoPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GotoPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caret;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caret,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caret))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GotoPos(caret);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GotoPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAnchor, "SetAnchor(anchor)\n"
"\n"
"Set the selection anchor to a position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAnchor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAnchor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int anchor;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_anchor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &anchor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAnchor(anchor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCurLine, "GetCurLine() -> (String, linePos)\n"
"\n"
"Retrieve the text of the line containing the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCurLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCurLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int linePos;
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetCurLine(&linePos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            PyObject *sipResObj = sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
            return sipBuildResult(0,"(Ri)",sipResObj,linePos);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCurLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetColumn, "GetColumn(pos) -> int\n"
"\n"
"Retrieve the column number of a position, taking tab width into\n"
"account.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColumn(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CountCharacters, "CountCharacters(start, end) -> int\n"
"\n"
"Count characters between two positions.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CountCharacters(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CountCharacters(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int end;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &end))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CountCharacters(start,end);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CountCharacters, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineEndPosition, "GetLineEndPosition(line) -> int\n"
"\n"
"Get the position after the last visible characters on a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineEndPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineEndPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineEndPosition(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineEndPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCurrentPos, "SetCurrentPos(caret)\n"
"\n"
"Sets the position of the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCurrentPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCurrentPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caret;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caret,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caret))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCurrentPos(caret);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCurrentPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionStart, "SetSelectionStart(anchor)\n"
"\n"
"Sets the position that starts the selection - this becomes the anchor.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int anchor;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_anchor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &anchor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionStart(anchor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionStart, "GetSelectionStart() -> int\n"
"\n"
"Returns the position at the start of the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionStart(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionStart(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionStart();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionEnd, "SetSelectionEnd(caret)\n"
"\n"
"Sets the position that ends the selection - this becomes the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionEnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionEnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caret;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caret,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caret))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionEnd(caret);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionEnd, "GetSelectionEnd() -> int\n"
"\n"
"Returns the position at the end of the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetEmptySelection, "SetEmptySelection(caret)\n"
"\n"
"Set caret to a position, while removing any existing selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetEmptySelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetEmptySelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caret;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caret,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caret))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetEmptySelection(caret);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetEmptySelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineCount, "GetLineCount() -> int\n"
"\n"
"Returns the number of lines in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineCount(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineCount();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineCount, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetModify, "GetModify() -> bool\n"
"\n"
"Is the document different from when it was last saved?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetModify(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetModify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetModify();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetModify, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectedText, "GetSelectedText() -> String\n"
"\n"
"Retrieve the selected text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectedText(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectedText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetSelectedText());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectedText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HideSelection, "HideSelection(hide)\n"
"\n"
"Draw the selection in normal style or with selection highlighted.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HideSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HideSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool hide;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_hide,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &hide))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HideSelection(hide);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HideSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PointFromPosition, "PointFromPosition(pos) -> Point\n"
"\n"
"Retrieve the point in the window where a position is displayed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PointFromPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PointFromPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->PointFromPosition(pos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PointFromPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineFromPosition, "LineFromPosition(pos) -> int\n"
"\n"
"Retrieve the line containing a position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineFromPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineFromPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LineFromPosition(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineFromPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PositionFromLine, "PositionFromLine(line) -> int\n"
"\n"
"Retrieve the position at the start of a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PositionFromLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PositionFromLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PositionFromLine(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PositionFromLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTextLength, "GetTextLength() -> int\n"
"\n"
"Retrieve the number of characters in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTextLength(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTextLength(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTextLength();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTextLength, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_TextWidth, "TextWidth(style, text) -> int\n"
"\n"
"Measure the pixel width of some text in a particular style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_TextWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_TextWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, sipType_wxString, &text, &textState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->TextWidth(style,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_TextWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_TextHeight, "TextHeight(line) -> int\n"
"\n"
"Retrieve the height of a particular line of text in pixels.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_TextHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_TextHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->TextHeight(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_TextHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MoveCaretInsideView, "MoveCaretInsideView()\n"
"\n"
"Move the caret inside current view if it's not there already.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MoveCaretInsideView(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MoveCaretInsideView(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MoveCaretInsideView();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MoveCaretInsideView, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineLength, "LineLength(line) -> int\n"
"\n"
"How many characters are on a line, including end of line characters?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineLength(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineLength(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LineLength(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineLength, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LinesOnScreen, "LinesOnScreen() -> int\n"
"\n"
"Retrieves the number of lines completely visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LinesOnScreen(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LinesOnScreen(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LinesOnScreen();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LinesOnScreen, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SelectionIsRectangle, "SelectionIsRectangle() -> bool\n"
"\n"
"Is the selection rectangular? The alternative is the more common\n"
"stream selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SelectionIsRectangle(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SelectionIsRectangle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SelectionIsRectangle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SelectionIsRectangle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ChooseCaretX, "ChooseCaretX()\n"
"\n"
"Set the last x chosen value to be the caret x position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ChooseCaretX(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ChooseCaretX(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ChooseCaretX();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ChooseCaretX, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PositionBefore, "PositionBefore(pos) -> int\n"
"\n"
"Given a valid document position, return the previous position taking\n"
"code page into account.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PositionBefore(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PositionBefore(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PositionBefore(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PositionBefore, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PositionAfter, "PositionAfter(pos) -> int\n"
"\n"
"Given a valid document position, return the next position taking code\n"
"page into account.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PositionAfter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PositionAfter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PositionAfter(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PositionAfter, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PositionRelative, "PositionRelative(pos, relative) -> int\n"
"\n"
"Given a valid document position, return a position that differs in a\n"
"number of characters.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PositionRelative(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PositionRelative(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        int relative;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_relative,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos, &relative))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PositionRelative(pos,relative);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PositionRelative, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionMode, "SetSelectionMode(selectionMode)\n"
"\n"
"Set the selection mode to stream (wxSTC_SEL_STREAM) or rectangular\n"
"(wxSTC_SEL_RECTANGLE/wxSTC_SEL_THIN) or by lines (wxSTC_SEL_LINES).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selectionMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selectionMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selectionMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionMode(selectionMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionMode, "GetSelectionMode() -> int\n"
"\n"
"Get the mode of the current selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionMode(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineSelStartPosition, "GetLineSelStartPosition(line) -> int\n"
"\n"
"Retrieve the position of the start of the selection at the given line\n"
"(wxSTC_INVALID_POSITION if no selection on this line).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineSelStartPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineSelStartPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineSelStartPosition(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineSelStartPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineSelEndPosition, "GetLineSelEndPosition(line) -> int\n"
"\n"
"Retrieve the position of the end of the selection at the given line\n"
"(wxSTC_INVALID_POSITION if no selection on this line).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineSelEndPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineSelEndPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineSelEndPosition(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineSelEndPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FindColumn, "FindColumn(line, column) -> int\n"
"\n"
"Find the position of a column on a line taking into account tabs and\n"
"multi-byte characters.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FindColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FindColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int column;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &column))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindColumn(line,column);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FindColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CharPositionFromPoint, "CharPositionFromPoint(x, y) -> int\n"
"\n"
"Find the position of a character from a point within the window.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CharPositionFromPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CharPositionFromPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CharPositionFromPoint(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CharPositionFromPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CharPositionFromPointClose, "CharPositionFromPointClose(x, y) -> int\n"
"\n"
"Find the position of a character from a point within the window.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CharPositionFromPointClose(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CharPositionFromPointClose(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CharPositionFromPointClose(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CharPositionFromPointClose, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMouseSelectionRectangularSwitch, "SetMouseSelectionRectangularSwitch(mouseSelectionRectangularSwitch)\n"
"\n"
"Set whether switching to rectangular mode while selecting with the\n"
"mouse is allowed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMouseSelectionRectangularSwitch(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMouseSelectionRectangularSwitch(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool mouseSelectionRectangularSwitch;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_mouseSelectionRectangularSwitch,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &mouseSelectionRectangularSwitch))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMouseSelectionRectangularSwitch(mouseSelectionRectangularSwitch);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMouseSelectionRectangularSwitch, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMouseSelectionRectangularSwitch, "GetMouseSelectionRectangularSwitch() -> bool\n"
"\n"
"Whether switching to rectangular mode while selecting with the mouse\n"
"is allowed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMouseSelectionRectangularSwitch(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMouseSelectionRectangularSwitch(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMouseSelectionRectangularSwitch();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMouseSelectionRectangularSwitch, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MoveSelectedLinesUp, "MoveSelectedLinesUp()\n"
"\n"
"Move the selected lines up one line, shifting the line above after the\n"
"selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MoveSelectedLinesUp(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MoveSelectedLinesUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MoveSelectedLinesUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MoveSelectedLinesUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MoveSelectedLinesDown, "MoveSelectedLinesDown()\n"
"\n"
"Move the selected lines down one line, shifting the line below before\n"
"the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MoveSelectedLinesDown(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MoveSelectedLinesDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MoveSelectedLinesDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MoveSelectedLinesDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMultiPaste, "SetMultiPaste(multiPaste)\n"
"\n"
"Change the effect of pasting when there are multiple selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMultiPaste(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMultiPaste(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int multiPaste;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_multiPaste,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &multiPaste))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMultiPaste(multiPaste);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMultiPaste, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMultiPaste, "GetMultiPaste() -> int\n"
"\n"
"Retrieve the effect of pasting when there are multiple selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMultiPaste(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMultiPaste(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMultiPaste();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMultiPaste, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMultipleSelection, "SetMultipleSelection(multipleSelection)\n"
"\n"
"Set whether multiple selections can be made.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMultipleSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMultipleSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool multipleSelection;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_multipleSelection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &multipleSelection))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMultipleSelection(multipleSelection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMultipleSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMultipleSelection, "GetMultipleSelection() -> bool\n"
"\n"
"Whether multiple selections can be made.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMultipleSelection(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMultipleSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMultipleSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMultipleSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAdditionalSelectionTyping, "SetAdditionalSelectionTyping(additionalSelectionTyping)\n"
"\n"
"Set whether typing can be performed into multiple selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAdditionalSelectionTyping(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAdditionalSelectionTyping(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool additionalSelectionTyping;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_additionalSelectionTyping,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &additionalSelectionTyping))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAdditionalSelectionTyping(additionalSelectionTyping);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAdditionalSelectionTyping, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetAdditionalSelectionTyping, "GetAdditionalSelectionTyping() -> bool\n"
"\n"
"Whether typing can be performed into multiple selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetAdditionalSelectionTyping(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetAdditionalSelectionTyping(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAdditionalSelectionTyping();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetAdditionalSelectionTyping, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAdditionalCaretsBlink, "SetAdditionalCaretsBlink(additionalCaretsBlink)\n"
"\n"
"Set whether additional carets will blink.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAdditionalCaretsBlink(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAdditionalCaretsBlink(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool additionalCaretsBlink;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_additionalCaretsBlink,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &additionalCaretsBlink))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAdditionalCaretsBlink(additionalCaretsBlink);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAdditionalCaretsBlink, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetAdditionalCaretsBlink, "GetAdditionalCaretsBlink() -> bool\n"
"\n"
"Whether additional carets will blink.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetAdditionalCaretsBlink(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetAdditionalCaretsBlink(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAdditionalCaretsBlink();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetAdditionalCaretsBlink, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAdditionalCaretsVisible, "SetAdditionalCaretsVisible(additionalCaretsVisible)\n"
"\n"
"Set whether additional carets are visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAdditionalCaretsVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAdditionalCaretsVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool additionalCaretsVisible;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_additionalCaretsVisible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &additionalCaretsVisible))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAdditionalCaretsVisible(additionalCaretsVisible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAdditionalCaretsVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetAdditionalCaretsVisible, "GetAdditionalCaretsVisible() -> bool\n"
"\n"
"Whether additional carets are visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetAdditionalCaretsVisible(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetAdditionalCaretsVisible(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAdditionalCaretsVisible();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetAdditionalCaretsVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelections, "GetSelections() -> int\n"
"\n"
"How many selections are there?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelections(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelections(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelections();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelections, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionEmpty, "GetSelectionEmpty() -> bool\n"
"\n"
"Is every selected range empty?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionEmpty(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionEmpty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionEmpty();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionEmpty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ClearSelections, "ClearSelections()\n"
"\n"
"Clear selections to a single empty stream selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ClearSelections(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ClearSelections(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearSelections();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ClearSelections, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AddSelection, "AddSelection(caret, anchor) -> int\n"
"\n"
"Add a selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AddSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AddSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caret;
        int anchor;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caret,
            sipName_anchor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caret, &anchor))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AddSelection(caret,anchor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AddSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DropSelectionN, "DropSelectionN(selection)\n"
"\n"
"Drop one selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DropSelectionN(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DropSelectionN(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DropSelectionN(selection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DropSelectionN, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMainSelection, "SetMainSelection(selection)\n"
"\n"
"Set the main selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMainSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMainSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMainSelection(selection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMainSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMainSelection, "GetMainSelection() -> int\n"
"\n"
"Which selection is the main selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMainSelection(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMainSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMainSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMainSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionNCaret, "SetSelectionNCaret(selection, caret)\n"
"\n"
"Set the caret position of the nth selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionNCaret(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionNCaret(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        int caret;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
            sipName_caret,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection, &caret))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionNCaret(selection,caret);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionNCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionNCaret, "GetSelectionNCaret(selection) -> int\n"
"\n"
"Return the caret position of the nth selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionNCaret(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionNCaret(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionNCaret(selection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionNCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionNAnchor, "SetSelectionNAnchor(selection, anchor)\n"
"\n"
"Set the anchor position of the nth selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionNAnchor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionNAnchor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        int anchor;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
            sipName_anchor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection, &anchor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionNAnchor(selection,anchor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionNAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionNAnchor, "GetSelectionNAnchor(selection) -> int\n"
"\n"
"Return the anchor position of the nth selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionNAnchor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionNAnchor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionNAnchor(selection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionNAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionNCaretVirtualSpace, "SetSelectionNCaretVirtualSpace(selection, space)\n"
"\n"
"Set the virtual space of the caret of the nth selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionNCaretVirtualSpace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionNCaretVirtualSpace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        int space;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
            sipName_space,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection, &space))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionNCaretVirtualSpace(selection,space);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionNCaretVirtualSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionNCaretVirtualSpace, "GetSelectionNCaretVirtualSpace(selection) -> int\n"
"\n"
"Return the virtual space of the caret of the nth selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionNCaretVirtualSpace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionNCaretVirtualSpace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionNCaretVirtualSpace(selection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionNCaretVirtualSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionNAnchorVirtualSpace, "SetSelectionNAnchorVirtualSpace(selection, space)\n"
"\n"
"Set the virtual space of the anchor of the nth selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionNAnchorVirtualSpace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionNAnchorVirtualSpace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        int space;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
            sipName_space,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection, &space))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionNAnchorVirtualSpace(selection,space);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionNAnchorVirtualSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionNAnchorVirtualSpace, "GetSelectionNAnchorVirtualSpace(selection) -> int\n"
"\n"
"Return the virtual space of the anchor of the nth selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionNAnchorVirtualSpace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionNAnchorVirtualSpace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionNAnchorVirtualSpace(selection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionNAnchorVirtualSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionNStart, "SetSelectionNStart(selection, anchor)\n"
"\n"
"Sets the position that starts the selection - this becomes the anchor.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionNStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionNStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        int anchor;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
            sipName_anchor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection, &anchor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionNStart(selection,anchor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionNStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionNStart, "GetSelectionNStart(selection) -> int\n"
"\n"
"Returns the position at the start of the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionNStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionNStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionNStart(selection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionNStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelectionNEnd, "SetSelectionNEnd(selection, caret)\n"
"\n"
"Sets the position that ends the selection - this becomes the\n"
"currentPosition.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelectionNEnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelectionNEnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        int caret;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
            sipName_caret,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection, &caret))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelectionNEnd(selection,caret);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelectionNEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectionNEnd, "GetSelectionNEnd(selection) -> int\n"
"\n"
"Returns the position at the end of the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectionNEnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectionNEnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int selection;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_selection,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &selection))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelectionNEnd(selection);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectionNEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetRectangularSelectionCaret, "SetRectangularSelectionCaret(caret)\n"
"\n"
"Set the caret position of the rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionCaret(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionCaret(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caret;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caret,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caret))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRectangularSelectionCaret(caret);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetRectangularSelectionCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetRectangularSelectionCaret, "GetRectangularSelectionCaret() -> int\n"
"\n"
"Return the caret position of the rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionCaret(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionCaret(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRectangularSelectionCaret();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetRectangularSelectionCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetRectangularSelectionAnchor, "SetRectangularSelectionAnchor(anchor)\n"
"\n"
"Set the anchor position of the rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionAnchor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionAnchor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int anchor;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_anchor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &anchor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRectangularSelectionAnchor(anchor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetRectangularSelectionAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetRectangularSelectionAnchor, "GetRectangularSelectionAnchor() -> int\n"
"\n"
"Return the anchor position of the rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionAnchor(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionAnchor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRectangularSelectionAnchor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetRectangularSelectionAnchor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetRectangularSelectionCaretVirtualSpace, "SetRectangularSelectionCaretVirtualSpace(space)\n"
"\n"
"Set the virtual space of the caret of the rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionCaretVirtualSpace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionCaretVirtualSpace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int space;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_space,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &space))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRectangularSelectionCaretVirtualSpace(space);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetRectangularSelectionCaretVirtualSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetRectangularSelectionCaretVirtualSpace, "GetRectangularSelectionCaretVirtualSpace() -> int\n"
"\n"
"Return the virtual space of the caret of the rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionCaretVirtualSpace(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionCaretVirtualSpace(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRectangularSelectionCaretVirtualSpace();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetRectangularSelectionCaretVirtualSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetRectangularSelectionAnchorVirtualSpace, "SetRectangularSelectionAnchorVirtualSpace(space)\n"
"\n"
"Set the virtual space of the anchor of the rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionAnchorVirtualSpace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionAnchorVirtualSpace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int space;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_space,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &space))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRectangularSelectionAnchorVirtualSpace(space);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetRectangularSelectionAnchorVirtualSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetRectangularSelectionAnchorVirtualSpace, "GetRectangularSelectionAnchorVirtualSpace() -> int\n"
"\n"
"Return the virtual space of the anchor of the rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionAnchorVirtualSpace(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionAnchorVirtualSpace(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRectangularSelectionAnchorVirtualSpace();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetRectangularSelectionAnchorVirtualSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetVirtualSpaceOptions, "SetVirtualSpaceOptions(virtualSpaceOptions)\n"
"\n"
"Set options for virtual space behaviour.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetVirtualSpaceOptions(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetVirtualSpaceOptions(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int virtualSpaceOptions;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_virtualSpaceOptions,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &virtualSpaceOptions))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetVirtualSpaceOptions(virtualSpaceOptions);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetVirtualSpaceOptions, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetVirtualSpaceOptions, "GetVirtualSpaceOptions() -> int\n"
"\n"
"Return options for virtual space behaviour.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetVirtualSpaceOptions(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetVirtualSpaceOptions(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetVirtualSpaceOptions();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetVirtualSpaceOptions, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetRectangularSelectionModifier, "SetRectangularSelectionModifier(modifier)\n"
"\n"
"On GTK+, allow selecting the modifier key to use for mouse-based\n"
"rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionModifier(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetRectangularSelectionModifier(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int modifier;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_modifier,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &modifier))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRectangularSelectionModifier(modifier);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetRectangularSelectionModifier, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetRectangularSelectionModifier, "GetRectangularSelectionModifier() -> int\n"
"\n"
"Get the modifier key used for rectangular selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionModifier(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetRectangularSelectionModifier(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetRectangularSelectionModifier();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetRectangularSelectionModifier, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAdditionalSelForeground, "SetAdditionalSelForeground(fore)\n"
"\n"
"Set the foreground colour of additional selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAdditionalSelForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAdditionalSelForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAdditionalSelForeground(*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAdditionalSelForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAdditionalSelBackground, "SetAdditionalSelBackground(back)\n"
"\n"
"Set the background colour of additional selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAdditionalSelBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAdditionalSelBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAdditionalSelBackground(*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAdditionalSelBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAdditionalSelAlpha, "SetAdditionalSelAlpha(alpha)\n"
"\n"
"Set the alpha of the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAdditionalSelAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAdditionalSelAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int alpha;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &alpha))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAdditionalSelAlpha(alpha);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAdditionalSelAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetAdditionalSelAlpha, "GetAdditionalSelAlpha() -> int\n"
"\n"
"Get the alpha of the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetAdditionalSelAlpha(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetAdditionalSelAlpha(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAdditionalSelAlpha();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetAdditionalSelAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAdditionalCaretForeground, "SetAdditionalCaretForeground(fore)\n"
"\n"
"Set the foreground colour of additional carets.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAdditionalCaretForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAdditionalCaretForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAdditionalCaretForeground(*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAdditionalCaretForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetAdditionalCaretForeground, "GetAdditionalCaretForeground() -> Colour\n"
"\n"
"Get the foreground colour of additional carets.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetAdditionalCaretForeground(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetAdditionalCaretForeground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetAdditionalCaretForeground());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetAdditionalCaretForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_RotateSelection, "RotateSelection()\n"
"\n"
"Set the main selection to the next selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_RotateSelection(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_RotateSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RotateSelection();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_RotateSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SwapMainAnchorCaret, "SwapMainAnchorCaret()\n"
"\n"
"Swap that caret and anchor of the main selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SwapMainAnchorCaret(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SwapMainAnchorCaret(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SwapMainAnchorCaret();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SwapMainAnchorCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MultipleSelectAddNext, "MultipleSelectAddNext()\n"
"\n"
"Add the next occurrence of the main selection to the set of selections\n"
"as main.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MultipleSelectAddNext(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MultipleSelectAddNext(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MultipleSelectAddNext();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MultipleSelectAddNext, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MultipleSelectAddEach, "MultipleSelectAddEach()\n"
"\n"
"Add each occurrence of the main selection in the target to the set of\n"
"selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MultipleSelectAddEach(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MultipleSelectAddEach(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MultipleSelectAddEach();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MultipleSelectAddEach, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetUseHorizontalScrollBar, "SetUseHorizontalScrollBar(visible)\n"
"\n"
"Show or hide the horizontal scroll bar.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetUseHorizontalScrollBar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetUseHorizontalScrollBar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool visible;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_visible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &visible))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetUseHorizontalScrollBar(visible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetUseHorizontalScrollBar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetUseHorizontalScrollBar, "GetUseHorizontalScrollBar() -> bool\n"
"\n"
"Is the horizontal scroll bar visible?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetUseHorizontalScrollBar(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetUseHorizontalScrollBar(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetUseHorizontalScrollBar();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetUseHorizontalScrollBar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetFirstVisibleLine, "GetFirstVisibleLine() -> int\n"
"\n"
"Retrieve the display line at the top of the display.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetFirstVisibleLine(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetFirstVisibleLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFirstVisibleLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetFirstVisibleLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineScroll, "LineScroll(columns, lines)\n"
"\n"
"Scroll horizontally and vertically.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineScroll(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineScroll(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int columns;
        int lines;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_columns,
            sipName_lines,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &columns, &lines))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineScroll(columns,lines);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineScroll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_EnsureCaretVisible, "EnsureCaretVisible()\n"
"\n"
"Ensure the caret is visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_EnsureCaretVisible(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_EnsureCaretVisible(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnsureCaretVisible();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_EnsureCaretVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ScrollRange, "ScrollRange(secondary, primary)\n"
"\n"
"Scroll the argument positions and the range between them into view\n"
"giving priority to the primary position then the secondary position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ScrollRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ScrollRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int secondary;
        int primary;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_secondary,
            sipName_primary,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &secondary, &primary))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ScrollRange(secondary,primary);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ScrollRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetScrollWidth, "SetScrollWidth(pixelWidth)\n"
"\n"
"Sets the document width assumed for scrolling.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetScrollWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetScrollWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pixelWidth;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pixelWidth,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pixelWidth))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetScrollWidth(pixelWidth);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetScrollWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetScrollWidth, "GetScrollWidth() -> int\n"
"\n"
"Retrieve the document width assumed for scrolling.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetScrollWidth(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetScrollWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetScrollWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetScrollWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetScrollWidthTracking, "SetScrollWidthTracking(tracking)\n"
"\n"
"Sets whether the maximum width line displayed is used to set scroll\n"
"width.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetScrollWidthTracking(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetScrollWidthTracking(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool tracking;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_tracking,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &tracking))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetScrollWidthTracking(tracking);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetScrollWidthTracking, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetScrollWidthTracking, "GetScrollWidthTracking() -> bool\n"
"\n"
"Retrieve whether the scroll width tracks wide lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetScrollWidthTracking(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetScrollWidthTracking(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetScrollWidthTracking();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetScrollWidthTracking, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetEndAtLastLine, "SetEndAtLastLine(endAtLastLine)\n"
"\n"
"Sets the scroll range so that maximum scroll position has the last\n"
"line at the bottom of the view (default).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetEndAtLastLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetEndAtLastLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool endAtLastLine;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_endAtLastLine,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &endAtLastLine))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetEndAtLastLine(endAtLastLine);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetEndAtLastLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetEndAtLastLine, "GetEndAtLastLine() -> bool\n"
"\n"
"Retrieve whether the maximum scroll position has the last line at the\n"
"bottom of the view.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetEndAtLastLine(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetEndAtLastLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetEndAtLastLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetEndAtLastLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetUseVerticalScrollBar, "SetUseVerticalScrollBar(visible)\n"
"\n"
"Show or hide the vertical scroll bar.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetUseVerticalScrollBar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetUseVerticalScrollBar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool visible;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_visible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &visible))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetUseVerticalScrollBar(visible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetUseVerticalScrollBar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetUseVerticalScrollBar, "GetUseVerticalScrollBar() -> bool\n"
"\n"
"Is the vertical scroll bar visible?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetUseVerticalScrollBar(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetUseVerticalScrollBar(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetUseVerticalScrollBar();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetUseVerticalScrollBar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetFirstVisibleLine, "SetFirstVisibleLine(displayLine)\n"
"\n"
"Scroll so that a display line is at the top of the display.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetFirstVisibleLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetFirstVisibleLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int displayLine;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_displayLine,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &displayLine))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFirstVisibleLine(displayLine);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetFirstVisibleLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetVisiblePolicy, "SetVisiblePolicy(visiblePolicy, visibleSlop)\n"
"\n"
"Set the way the display area is determined when a particular line is\n"
"to be moved to by Find, FindNext, GotoLine, etc.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetVisiblePolicy(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetVisiblePolicy(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int visiblePolicy;
        int visibleSlop;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_visiblePolicy,
            sipName_visibleSlop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &visiblePolicy, &visibleSlop))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetVisiblePolicy(visiblePolicy,visibleSlop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetVisiblePolicy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetXOffset, "SetXOffset(xOffset)\n"
"\n"
"Set the xOffset (ie, horizontal scroll position).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetXOffset(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetXOffset(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int xOffset;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_xOffset,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &xOffset))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetXOffset(xOffset);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetXOffset, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetXOffset, "GetXOffset() -> int\n"
"\n"
"Get the xOffset (ie, horizontal scroll position).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetXOffset(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetXOffset(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetXOffset();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetXOffset, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetXCaretPolicy, "SetXCaretPolicy(caretPolicy, caretSlop)\n"
"\n"
"Set the way the caret is kept visible when going sideways.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetXCaretPolicy(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetXCaretPolicy(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caretPolicy;
        int caretSlop;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caretPolicy,
            sipName_caretSlop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caretPolicy, &caretSlop))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetXCaretPolicy(caretPolicy,caretSlop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetXCaretPolicy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetYCaretPolicy, "SetYCaretPolicy(caretPolicy, caretSlop)\n"
"\n"
"Set the way the line the caret is on is kept visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetYCaretPolicy(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetYCaretPolicy(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caretPolicy;
        int caretSlop;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caretPolicy,
            sipName_caretSlop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caretPolicy, &caretSlop))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetYCaretPolicy(caretPolicy,caretSlop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetYCaretPolicy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetViewWhiteSpace, "GetViewWhiteSpace() -> int\n"
"\n"
"Are white space characters currently visible? Returns one of\n"
"wxSTC_WS_* constants.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetViewWhiteSpace(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetViewWhiteSpace(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetViewWhiteSpace();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetViewWhiteSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetViewWhiteSpace, "SetViewWhiteSpace(viewWS)\n"
"\n"
"Make white space characters invisible, always visible or visible\n"
"outside indentation.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetViewWhiteSpace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetViewWhiteSpace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int viewWS;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_viewWS,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &viewWS))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetViewWhiteSpace(viewWS);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetViewWhiteSpace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTabDrawMode, "GetTabDrawMode() -> int\n"
"\n"
"Retrieve the current tab draw mode.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTabDrawMode(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTabDrawMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTabDrawMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTabDrawMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTabDrawMode, "SetTabDrawMode(tabDrawMode)\n"
"\n"
"Set how tabs are drawn when visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTabDrawMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTabDrawMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int tabDrawMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_tabDrawMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &tabDrawMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTabDrawMode(tabDrawMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTabDrawMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWhitespaceForeground, "SetWhitespaceForeground(useSetting, fore)\n"
"\n"
"Set the foreground colour of all whitespace and whether to use this\n"
"setting.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWhitespaceForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWhitespaceForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWhitespaceForeground(useSetting,*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWhitespaceForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWhitespaceBackground, "SetWhitespaceBackground(useSetting, back)\n"
"\n"
"Set the background colour of all whitespace and whether to use this\n"
"setting.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWhitespaceBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWhitespaceBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWhitespaceBackground(useSetting,*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWhitespaceBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWhitespaceSize, "SetWhitespaceSize(size)\n"
"\n"
"Set the size of the dots used to mark space characters.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWhitespaceSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWhitespaceSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int size;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &size))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWhitespaceSize(size);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWhitespaceSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetWhitespaceSize, "GetWhitespaceSize() -> int\n"
"\n"
"Get the size of the dots used to mark space characters.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetWhitespaceSize(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetWhitespaceSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWhitespaceSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetWhitespaceSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetExtraAscent, "SetExtraAscent(extraAscent)\n"
"\n"
"Set extra ascent for each line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetExtraAscent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetExtraAscent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int extraAscent;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_extraAscent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &extraAscent))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetExtraAscent(extraAscent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetExtraAscent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetExtraAscent, "GetExtraAscent() -> int\n"
"\n"
"Get extra ascent for each line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetExtraAscent(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetExtraAscent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetExtraAscent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetExtraAscent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetExtraDescent, "SetExtraDescent(extraDescent)\n"
"\n"
"Set extra descent for each line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetExtraDescent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetExtraDescent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int extraDescent;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_extraDescent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &extraDescent))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetExtraDescent(extraDescent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetExtraDescent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetExtraDescent, "GetExtraDescent() -> int\n"
"\n"
"Get extra descent for each line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetExtraDescent(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetExtraDescent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetExtraDescent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetExtraDescent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSTCCursor, "SetSTCCursor(cursorType)\n"
"\n"
"Sets the cursor to one of the wxSTC_CURSOR* values.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSTCCursor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSTCCursor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int cursorType;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cursorType,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &cursorType))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSTCCursor(cursorType);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSTCCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSTCCursor, "GetSTCCursor() -> int\n"
"\n"
"Get cursor type.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSTCCursor(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSTCCursor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSTCCursor();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSTCCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMouseDownCaptures, "SetMouseDownCaptures(captures)\n"
"\n"
"Set whether the mouse is captured when its button is pressed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMouseDownCaptures(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMouseDownCaptures(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool captures;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_captures,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &captures))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMouseDownCaptures(captures);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMouseDownCaptures, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMouseDownCaptures, "GetMouseDownCaptures() -> bool\n"
"\n"
"Get whether mouse gets captured.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMouseDownCaptures(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMouseDownCaptures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMouseDownCaptures();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMouseDownCaptures, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMouseWheelCaptures, "SetMouseWheelCaptures(captures)\n"
"\n"
"Set whether the mouse wheel can be active outside the window.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMouseWheelCaptures(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMouseWheelCaptures(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool captures;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_captures,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &captures))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMouseWheelCaptures(captures);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMouseWheelCaptures, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMouseWheelCaptures, "GetMouseWheelCaptures() -> bool\n"
"\n"
"Get whether mouse wheel can be active outside the window.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMouseWheelCaptures(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMouseWheelCaptures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMouseWheelCaptures();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMouseWheelCaptures, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ConvertEOLs, "ConvertEOLs(eolMode)\n"
"\n"
"Convert all line endings in the document to one mode.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ConvertEOLs(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ConvertEOLs(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int eolMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eolMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &eolMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ConvertEOLs(eolMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ConvertEOLs, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetEOLMode, "GetEOLMode() -> int\n"
"\n"
"Retrieve the current end of line mode - one of wxSTC_EOL_CRLF,\n"
"wxSTC_EOL_CR, or wxSTC_EOL_LF.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetEOLMode(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetEOLMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetEOLMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetEOLMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetEOLMode, "SetEOLMode(eolMode)\n"
"\n"
"Set the current end of line mode.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetEOLMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetEOLMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int eolMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eolMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &eolMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetEOLMode(eolMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetEOLMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetViewEOL, "GetViewEOL() -> bool\n"
"\n"
"Are the end of line characters visible?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetViewEOL(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetViewEOL(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetViewEOL();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetViewEOL, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetViewEOL, "SetViewEOL(visible)\n"
"\n"
"Make the end of line characters visible or invisible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetViewEOL(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetViewEOL(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool visible;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_visible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &visible))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetViewEOL(visible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetViewEOL, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetLineEndTypesAllowed, "SetLineEndTypesAllowed(lineEndBitSet)\n"
"\n"
"Set the line end types that the application wants to use.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetLineEndTypesAllowed(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetLineEndTypesAllowed(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lineEndBitSet;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineEndBitSet,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lineEndBitSet))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLineEndTypesAllowed(lineEndBitSet);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetLineEndTypesAllowed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineEndTypesAllowed, "GetLineEndTypesAllowed() -> int\n"
"\n"
"Get the line end types currently allowed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineEndTypesAllowed(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineEndTypesAllowed(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineEndTypesAllowed();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineEndTypesAllowed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineEndTypesActive, "GetLineEndTypesActive() -> int\n"
"\n"
"Get the line end types currently recognised.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineEndTypesActive(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineEndTypesActive(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineEndTypesActive();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineEndTypesActive, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineEndTypesSupported, "GetLineEndTypesSupported() -> int\n"
"\n"
"Bit set of LineEndType enumertion for which line ends beyond the\n"
"standard LF, CR, and CRLF are supported by the lexer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineEndTypesSupported(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineEndTypesSupported(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineEndTypesSupported();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineEndTypesSupported, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWordChars, "SetWordChars(characters)\n"
"\n"
"Set the set of characters making up words for when moving or selecting\n"
"by word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWordChars(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWordChars(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* characters;
        int charactersState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_characters,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &characters, &charactersState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWordChars(*characters);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(characters), sipType_wxString, charactersState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWordChars, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetWordChars, "GetWordChars() -> String\n"
"\n"
"Get the set of characters making up words for when moving or selecting\n"
"by word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetWordChars(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetWordChars(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetWordChars());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetWordChars, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordStartPosition, "WordStartPosition(pos, onlyWordCharacters) -> int\n"
"\n"
"Get position of start of word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordStartPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordStartPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        bool onlyWordCharacters;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_onlyWordCharacters,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos, &onlyWordCharacters))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WordStartPosition(pos,onlyWordCharacters);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordStartPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordEndPosition, "WordEndPosition(pos, onlyWordCharacters) -> int\n"
"\n"
"Get position of end of word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordEndPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordEndPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        bool onlyWordCharacters;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_onlyWordCharacters,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos, &onlyWordCharacters))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WordEndPosition(pos,onlyWordCharacters);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordEndPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IsRangeWord, "IsRangeWord(start, end) -> bool\n"
"\n"
"Is the range start..end considered a word?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IsRangeWord(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IsRangeWord(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int end;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &end))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsRangeWord(start,end);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IsRangeWord, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWhitespaceChars, "SetWhitespaceChars(characters)\n"
"\n"
"Set the set of characters making up whitespace for when moving or\n"
"selecting by word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWhitespaceChars(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWhitespaceChars(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* characters;
        int charactersState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_characters,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &characters, &charactersState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWhitespaceChars(*characters);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(characters), sipType_wxString, charactersState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWhitespaceChars, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetWhitespaceChars, "GetWhitespaceChars() -> String\n"
"\n"
"Get the set of characters making up whitespace for when moving or\n"
"selecting by word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetWhitespaceChars(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetWhitespaceChars(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetWhitespaceChars());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetWhitespaceChars, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetPunctuationChars, "SetPunctuationChars(characters)\n"
"\n"
"Set the set of characters making up punctuation characters Should be\n"
"called after SetWordChars.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetPunctuationChars(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetPunctuationChars(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* characters;
        int charactersState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_characters,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &characters, &charactersState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPunctuationChars(*characters);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(characters), sipType_wxString, charactersState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetPunctuationChars, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPunctuationChars, "GetPunctuationChars() -> String\n"
"\n"
"Get the set of characters making up punctuation characters.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPunctuationChars(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPunctuationChars(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetPunctuationChars());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPunctuationChars, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCharsDefault, "SetCharsDefault()\n"
"\n"
"Reset the set of characters for whitespace and word characters to the\n"
"defaults.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCharsDefault(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCharsDefault(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCharsDefault();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCharsDefault, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetEndStyled, "GetEndStyled() -> int\n"
"\n"
"Retrieve the position of the last correctly styled character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetEndStyled(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetEndStyled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetEndStyled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetEndStyled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StartStyling, "StartStyling(start)\n"
"\n"
"Set the current styling position to start.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StartStyling(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StartStyling(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StartStyling(start);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StartStyling, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetStyling, "SetStyling(length, style)\n"
"\n"
"Change style from current styling position for length characters to a\n"
"style and move the current styling position to after this newly styled\n"
"segment.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetStyling(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetStyling(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int length;
        int style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_length,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &length, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetStyling(length,style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetStyling, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetStyleBytes, "SetStyleBytes(length, styleBytes)\n"
"\n"
"Set the styles for a segment of the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetStyleBytes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetStyleBytes(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int length;
        char* styleBytes;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_length,
            sipName_styleBytes,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bis", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &length, &styleBytes))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetStyleBytes(length,styleBytes);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetStyleBytes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetLineState, "SetLineState(line, state)\n"
"\n"
"Used to hold extra styling information for each line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetLineState(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetLineState(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int state;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_state,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &state))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLineState(line,state);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetLineState, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineState, "GetLineState(line) -> int\n"
"\n"
"Retrieve the extra styling information for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineState(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineState(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineState(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineState, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMaxLineState, "GetMaxLineState() -> int\n"
"\n"
"Retrieve the last line number that has line state.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMaxLineState(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMaxLineState(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMaxLineState();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMaxLineState, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetIdleStyling, "SetIdleStyling(idleStyling)\n"
"\n"
"Sets limits to idle styling.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetIdleStyling(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetIdleStyling(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int idleStyling;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_idleStyling,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &idleStyling))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIdleStyling(idleStyling);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetIdleStyling, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetIdleStyling, "GetIdleStyling() -> int\n"
"\n"
"Retrieve the limits to idle styling.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetIdleStyling(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetIdleStyling(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIdleStyling();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetIdleStyling, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleClearAll, "StyleClearAll()\n"
"\n"
"Clear all the styles and make equivalent to the global default style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleClearAll(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleClearAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleClearAll();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleClearAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetForeground, "StyleSetForeground(style, fore)\n"
"\n"
"Set the foreground colour of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetForeground(style,*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetBackground, "StyleSetBackground(style, back)\n"
"\n"
"Set the background colour of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetBackground(style,*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetBold, "StyleSetBold(style, bold)\n"
"\n"
"Set a style to be bold or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetBold(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetBold(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        bool bold;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_bold,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &bold))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetBold(style,bold);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetBold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetItalic, "StyleSetItalic(style, italic)\n"
"\n"
"Set a style to be italic or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetItalic(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetItalic(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        bool italic;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_italic,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &italic))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetItalic(style,italic);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetItalic, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetSize, "StyleSetSize(style, sizePoints)\n"
"\n"
"Set the size of characters of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        int sizePoints;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_sizePoints,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &sizePoints))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetSize(style,sizePoints);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetFaceName, "StyleSetFaceName(style, fontName)\n"
"\n"
"Set the font of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetFaceName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetFaceName(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxString* fontName;
        int fontNameState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_fontName,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, sipType_wxString, &fontName, &fontNameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetFaceName(style,*fontName);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(fontName), sipType_wxString, fontNameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetFaceName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetEOLFilled, "StyleSetEOLFilled(style, eolFilled)\n"
"\n"
"Set a style to have its end of line filled or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetEOLFilled(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetEOLFilled(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        bool eolFilled;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_eolFilled,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &eolFilled))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetEOLFilled(style,eolFilled);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetEOLFilled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleResetDefault, "StyleResetDefault()\n"
"\n"
"Reset the default style to its state at startup.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleResetDefault(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleResetDefault(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleResetDefault();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleResetDefault, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetUnderline, "StyleSetUnderline(style, underline)\n"
"\n"
"Set a style to be underlined or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetUnderline(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetUnderline(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        bool underline;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_underline,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &underline))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetUnderline(style,underline);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetUnderline, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetForeground, "StyleGetForeground(style) -> Colour\n"
"\n"
"Get the foreground colour of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->StyleGetForeground(style));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetBackground, "StyleGetBackground(style) -> Colour\n"
"\n"
"Get the background colour of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->StyleGetBackground(style));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetBold, "StyleGetBold(style) -> bool\n"
"\n"
"Get is a style bold or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetBold(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetBold(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetBold(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetBold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetItalic, "StyleGetItalic(style) -> bool\n"
"\n"
"Get is a style italic or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetItalic(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetItalic(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetItalic(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetItalic, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetSize, "StyleGetSize(style) -> int\n"
"\n"
"Get the size of characters of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetSize(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetFaceName, "StyleGetFaceName(style) -> String\n"
"\n"
"Get the font facename of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetFaceName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetFaceName(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->StyleGetFaceName(style));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetFaceName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetEOLFilled, "StyleGetEOLFilled(style) -> bool\n"
"\n"
"Get is a style to have its end of line filled or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetEOLFilled(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetEOLFilled(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetEOLFilled(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetEOLFilled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetUnderline, "StyleGetUnderline(style) -> bool\n"
"\n"
"Get is a style underlined or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetUnderline(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetUnderline(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetUnderline(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetUnderline, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetCase, "StyleGetCase(style) -> int\n"
"\n"
"Get is a style mixed case, or to force upper or lower case.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetCase(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetCase(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetCase(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetCase, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetCharacterSet, "StyleGetCharacterSet(style) -> int\n"
"\n"
"Get the character get of the font in a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetCharacterSet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetCharacterSet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetCharacterSet(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetCharacterSet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetVisible, "StyleGetVisible(style) -> bool\n"
"\n"
"Get is a style visible or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetVisible(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetChangeable, "StyleGetChangeable(style) -> bool\n"
"\n"
"Get is a style changeable or not (read only).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetChangeable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetChangeable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetChangeable(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetChangeable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetHotSpot, "StyleGetHotSpot(style) -> bool\n"
"\n"
"Get is a style a hotspot or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetHotSpot(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetHotSpot(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetHotSpot(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetHotSpot, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetCase, "StyleSetCase(style, caseVisible)\n"
"\n"
"Set a style to be mixed case, or to force upper or lower case.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetCase(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetCase(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        int caseVisible;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_caseVisible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &caseVisible))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetCase(style,caseVisible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetCase, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetSizeFractional, "StyleSetSizeFractional(style, sizeHundredthPoints)\n"
"\n"
"Set the size of characters of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetSizeFractional(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetSizeFractional(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        int sizeHundredthPoints;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_sizeHundredthPoints,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &sizeHundredthPoints))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetSizeFractional(style,sizeHundredthPoints);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetSizeFractional, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetSizeFractional, "StyleGetSizeFractional(style) -> int\n"
"\n"
"Get the size of characters of a style in points multiplied by 100.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetSizeFractional(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetSizeFractional(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetSizeFractional(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetSizeFractional, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetWeight, "StyleSetWeight(style, weight)\n"
"\n"
"Set the weight of characters of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetWeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetWeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        int weight;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_weight,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &weight))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetWeight(style,weight);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetWeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetWeight, "StyleGetWeight(style) -> int\n"
"\n"
"Get the weight of characters of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetWeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetWeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StyleGetWeight(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetWeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetCharacterSet, "StyleSetCharacterSet(style, characterSet)\n"
"\n"
"Set the character set of the font in a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetCharacterSet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetCharacterSet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        int characterSet;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_characterSet,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &characterSet))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetCharacterSet(style,characterSet);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetCharacterSet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetHotSpot, "StyleSetHotSpot(style, hotspot)\n"
"\n"
"Set a style to be a hotspot or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetHotSpot(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetHotSpot(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        bool hotspot;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_hotspot,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &hotspot))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetHotSpot(style,hotspot);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetHotSpot, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetVisible, "StyleSetVisible(style, visible)\n"
"\n"
"Set a style to be visible or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        bool visible;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_visible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &visible))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetVisible(style,visible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetChangeable, "StyleSetChangeable(style, changeable)\n"
"\n"
"Set a style to be changeable or not (read only).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetChangeable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetChangeable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        bool changeable;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_changeable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, &changeable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetChangeable(style,changeable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetChangeable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelForeground, "SetSelForeground(useSetting, fore)\n"
"\n"
"Set the foreground colour of the main and additional selections and\n"
"whether to use this setting.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelForeground(useSetting,*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelBackground, "SetSelBackground(useSetting, back)\n"
"\n"
"Set the background colour of the main and additional selections and\n"
"whether to use this setting.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelBackground(useSetting,*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelAlpha, "GetSelAlpha() -> int\n"
"\n"
"Get the alpha of the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelAlpha(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelAlpha(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelAlpha();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelAlpha, "SetSelAlpha(alpha)\n"
"\n"
"Set the alpha of the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int alpha;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &alpha))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelAlpha(alpha);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelEOLFilled, "GetSelEOLFilled() -> bool\n"
"\n"
"Is the selection end of line filled?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelEOLFilled(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelEOLFilled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSelEOLFilled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelEOLFilled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelEOLFilled, "SetSelEOLFilled(filled)\n"
"\n"
"Set the selection to have its end of line filled or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelEOLFilled(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelEOLFilled(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool filled;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_filled,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &filled))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSelEOLFilled(filled);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelEOLFilled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretForeground, "SetCaretForeground(fore)\n"
"\n"
"Set the foreground colour of the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretForeground(*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretPeriod, "GetCaretPeriod() -> int\n"
"\n"
"Get the time in milliseconds that the caret is on and off.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretPeriod(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretPeriod(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretPeriod();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretPeriod, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretPeriod, "SetCaretPeriod(periodMilliseconds)\n"
"\n"
"Get the time in milliseconds that the caret is on and off.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretPeriod(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretPeriod(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int periodMilliseconds;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_periodMilliseconds,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &periodMilliseconds))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretPeriod(periodMilliseconds);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretPeriod, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretLineVisible, "GetCaretLineVisible() -> bool\n"
"\n"
"Is the background of the line containing the caret in a different\n"
"colour?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretLineVisible(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretLineVisible(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretLineVisible();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretLineVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretLineVisible, "SetCaretLineVisible(show)\n"
"\n"
"Display the background of the line containing the caret in a different\n"
"colour.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretLineVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretLineVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool show;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_show,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &show))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretLineVisible(show);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretLineVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretLineBackground, "GetCaretLineBackground() -> Colour\n"
"\n"
"Get the colour of the background of the line containing the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretLineBackground(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretLineBackground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetCaretLineBackground());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretLineBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretLineBackground, "SetCaretLineBackground(back)\n"
"\n"
"Set the colour of the background of the line containing the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretLineBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretLineBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretLineBackground(*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretLineBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretForeground, "GetCaretForeground() -> Colour\n"
"\n"
"Get the foreground colour of the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretForeground(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretForeground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetCaretForeground());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretWidth, "SetCaretWidth(pixelWidth)\n"
"\n"
"Set the width of the insert mode caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pixelWidth;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pixelWidth,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pixelWidth))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretWidth(pixelWidth);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretWidth, "GetCaretWidth() -> int\n"
"\n"
"Returns the width of the insert mode caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretWidth(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetHotspotActiveForeground, "SetHotspotActiveForeground(useSetting, fore)\n"
"\n"
"Set a fore colour for active hotspots.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetHotspotActiveForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetHotspotActiveForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHotspotActiveForeground(useSetting,*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetHotspotActiveForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetHotspotActiveForeground, "GetHotspotActiveForeground() -> Colour\n"
"\n"
"Get the fore colour for active hotspots.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetHotspotActiveForeground(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetHotspotActiveForeground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetHotspotActiveForeground());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetHotspotActiveForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetHotspotActiveBackground, "SetHotspotActiveBackground(useSetting, back)\n"
"\n"
"Set a back colour for active hotspots.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetHotspotActiveBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetHotspotActiveBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHotspotActiveBackground(useSetting,*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetHotspotActiveBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetHotspotActiveBackground, "GetHotspotActiveBackground() -> Colour\n"
"\n"
"Get the back colour for active hotspots.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetHotspotActiveBackground(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetHotspotActiveBackground(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetHotspotActiveBackground());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetHotspotActiveBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetHotspotActiveUnderline, "SetHotspotActiveUnderline(underline)\n"
"\n"
"Enable / Disable underlining active hotspots.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetHotspotActiveUnderline(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetHotspotActiveUnderline(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool underline;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_underline,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &underline))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHotspotActiveUnderline(underline);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetHotspotActiveUnderline, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetHotspotActiveUnderline, "GetHotspotActiveUnderline() -> bool\n"
"\n"
"Get whether underlining for active hotspots.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetHotspotActiveUnderline(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetHotspotActiveUnderline(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetHotspotActiveUnderline();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetHotspotActiveUnderline, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetHotspotSingleLine, "SetHotspotSingleLine(singleLine)\n"
"\n"
"Limit hotspots to single line so hotspots on two lines don't merge.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetHotspotSingleLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetHotspotSingleLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool singleLine;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_singleLine,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &singleLine))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHotspotSingleLine(singleLine);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetHotspotSingleLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetHotspotSingleLine, "GetHotspotSingleLine() -> bool\n"
"\n"
"Get the HotspotSingleLine property.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetHotspotSingleLine(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetHotspotSingleLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetHotspotSingleLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetHotspotSingleLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretSticky, "GetCaretSticky() -> int\n"
"\n"
"Can the caret preferred x position only be changed by explicit\n"
"movement commands?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretSticky(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretSticky(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretSticky();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretSticky, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretSticky, "SetCaretSticky(useCaretStickyBehaviour)\n"
"\n"
"Stop the caret preferred x position changing when the user types.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretSticky(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretSticky(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int useCaretStickyBehaviour;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useCaretStickyBehaviour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useCaretStickyBehaviour))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretSticky(useCaretStickyBehaviour);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretSticky, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ToggleCaretSticky, "ToggleCaretSticky()\n"
"\n"
"Switch between sticky and non-sticky: meant to be bound to a key.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ToggleCaretSticky(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ToggleCaretSticky(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ToggleCaretSticky();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ToggleCaretSticky, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretLineBackAlpha, "SetCaretLineBackAlpha(alpha)\n"
"\n"
"Set background alpha of the caret line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretLineBackAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretLineBackAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int alpha;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &alpha))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretLineBackAlpha(alpha);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretLineBackAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretLineBackAlpha, "GetCaretLineBackAlpha() -> int\n"
"\n"
"Get the background alpha of the caret line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretLineBackAlpha(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretLineBackAlpha(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretLineBackAlpha();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretLineBackAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretStyle, "SetCaretStyle(caretStyle)\n"
"\n"
"Set the style of the caret to be drawn.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int caretStyle;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_caretStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &caretStyle))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretStyle(caretStyle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretStyle, "GetCaretStyle() -> int\n"
"\n"
"Returns the current style of the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretStyle(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCaretLineVisibleAlways, "GetCaretLineVisibleAlways() -> bool\n"
"\n"
"Is the caret line always visible?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCaretLineVisibleAlways(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCaretLineVisibleAlways(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCaretLineVisibleAlways();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCaretLineVisibleAlways, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCaretLineVisibleAlways, "SetCaretLineVisibleAlways(alwaysVisible)\n"
"\n"
"Sets the caret line to always visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCaretLineVisibleAlways(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCaretLineVisibleAlways(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool alwaysVisible;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alwaysVisible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &alwaysVisible))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCaretLineVisibleAlways(alwaysVisible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCaretLineVisibleAlways, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetControlCharSymbol, "SetControlCharSymbol(symbol)\n"
"\n"
"Change the way control characters are displayed: If symbol is < 32,\n"
"keep the drawn way, else, use the given character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetControlCharSymbol(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetControlCharSymbol(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int symbol;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_symbol,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &symbol))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetControlCharSymbol(symbol);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetControlCharSymbol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetControlCharSymbol, "GetControlCharSymbol() -> int\n"
"\n"
"Get the way control characters are displayed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetControlCharSymbol(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetControlCharSymbol(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetControlCharSymbol();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetControlCharSymbol, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetRepresentation, "SetRepresentation(encodedCharacter, representation)\n"
"\n"
"Set the way a character is drawn.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetRepresentation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetRepresentation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* encodedCharacter;
        int encodedCharacterState = 0;
        const  ::wxString* representation;
        int representationState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_encodedCharacter,
            sipName_representation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &encodedCharacter, &encodedCharacterState, sipType_wxString, &representation, &representationState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRepresentation(*encodedCharacter,*representation);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(encodedCharacter), sipType_wxString, encodedCharacterState);
            sipReleaseType(const_cast< ::wxString *>(representation), sipType_wxString, representationState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetRepresentation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetRepresentation, "GetRepresentation(encodedCharacter) -> String\n"
"\n"
"Set the way a character is drawn.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetRepresentation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetRepresentation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* encodedCharacter;
        int encodedCharacterState = 0;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_encodedCharacter,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &encodedCharacter, &encodedCharacterState))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetRepresentation(*encodedCharacter));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(encodedCharacter), sipType_wxString, encodedCharacterState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetRepresentation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ClearRepresentation, "ClearRepresentation(encodedCharacter)\n"
"\n"
"Remove a character representation.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ClearRepresentation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ClearRepresentation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* encodedCharacter;
        int encodedCharacterState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_encodedCharacter,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &encodedCharacter, &encodedCharacterState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearRepresentation(*encodedCharacter);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(encodedCharacter), sipType_wxString, encodedCharacterState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ClearRepresentation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginType, "SetMarginType(margin, marginType)\n"
"\n"
"Set a margin to be either numeric or symbolic.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginType(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginType(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        int marginType;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
            sipName_marginType,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin, &marginType))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginType(margin,marginType);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginType, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginType, "GetMarginType(margin) -> int\n"
"\n"
"Retrieve the type of a margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginType(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginType(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginType(margin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginType, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginWidth, "SetMarginWidth(margin, pixelWidth)\n"
"\n"
"Set the width of a margin to a width expressed in pixels.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        int pixelWidth;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
            sipName_pixelWidth,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin, &pixelWidth))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginWidth(margin,pixelWidth);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginWidth, "GetMarginWidth(margin) -> int\n"
"\n"
"Retrieve the width of a margin in pixels.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginWidth(margin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginMask, "SetMarginMask(margin, mask)\n"
"\n"
"Set a mask that determines which markers are displayed in a margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginMask(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginMask(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        int mask;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
            sipName_mask,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin, &mask))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginMask(margin,mask);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginMask, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginMask, "GetMarginMask(margin) -> int\n"
"\n"
"Retrieve the marker mask of a margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginMask(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginMask(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginMask(margin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginMask, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginSensitive, "SetMarginSensitive(margin, sensitive)\n"
"\n"
"Make a margin sensitive or insensitive to mouse clicks.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginSensitive(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginSensitive(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        bool sensitive;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
            sipName_sensitive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin, &sensitive))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginSensitive(margin,sensitive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginSensitive, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginSensitive, "GetMarginSensitive(margin) -> bool\n"
"\n"
"Retrieve the mouse click sensitivity of a margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginSensitive(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginSensitive(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginSensitive(margin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginSensitive, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginCursor, "SetMarginCursor(margin, cursor)\n"
"\n"
"Set the cursor shown when the mouse is inside a margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginCursor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginCursor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        int cursor;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
            sipName_cursor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin, &cursor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginCursor(margin,cursor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginCursor, "GetMarginCursor(margin) -> int\n"
"\n"
"Retrieve the cursor shown in a margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginCursor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginCursor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginCursor(margin);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginCursor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginBackground, "SetMarginBackground(margin, back)\n"
"\n"
"Set the background colour of a margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginBackground(margin,*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginBackground, "GetMarginBackground(margin) -> Colour\n"
"\n"
"Retrieve the background colour of a margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margin;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margin))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetMarginBackground(margin));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginCount, "SetMarginCount(margins)\n"
"\n"
"Allocate a non-standard number of margins.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginCount(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginCount(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int margins;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_margins,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &margins))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginCount(margins);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginCount, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginCount, "GetMarginCount() -> int\n"
"\n"
"How many margins are there?.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginCount(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginCount();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginCount, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginLeft, "SetMarginLeft(pixelWidth)\n"
"\n"
"Sets the size in pixels of the left margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginLeft(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginLeft(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pixelWidth;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pixelWidth,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pixelWidth))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginLeft(pixelWidth);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginLeft, "GetMarginLeft() -> int\n"
"\n"
"Returns the size in pixels of the left margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginLeft(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginLeft(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginLeft();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginRight, "SetMarginRight(pixelWidth)\n"
"\n"
"Sets the size in pixels of the right margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginRight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginRight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pixelWidth;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pixelWidth,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pixelWidth))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginRight(pixelWidth);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginRight, "GetMarginRight() -> int\n"
"\n"
"Returns the size in pixels of the right margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginRight(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginRight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginRight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetFoldMarginColour, "SetFoldMarginColour(useSetting, back)\n"
"\n"
"Set one of the colours used as a chequerboard pattern in the fold\n"
"margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetFoldMarginColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetFoldMarginColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFoldMarginColour(useSetting,*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetFoldMarginColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetFoldMarginHiColour, "SetFoldMarginHiColour(useSetting, fore)\n"
"\n"
"Set the other colour used as a chequerboard pattern in the fold\n"
"margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetFoldMarginHiColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetFoldMarginHiColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFoldMarginHiColour(useSetting,*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetFoldMarginHiColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginSetText, "MarginSetText(line, text)\n"
"\n"
"Set the text in the text margin for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginSetText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginSetText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarginSetText(line,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginSetText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginGetText, "MarginGetText(line) -> String\n"
"\n"
"Get the text in the text margin for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginGetText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginGetText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->MarginGetText(line));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginGetText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginSetStyle, "MarginSetStyle(line, style)\n"
"\n"
"Set the style number for the text margin for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginSetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginSetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarginSetStyle(line,style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginSetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginGetStyle, "MarginGetStyle(line) -> int\n"
"\n"
"Get the style number for the text margin for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginGetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginGetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MarginGetStyle(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginGetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginSetStyles, "MarginSetStyles(line, styles)\n"
"\n"
"Set the style in the text margin for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginSetStyles(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginSetStyles(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxString* styles;
        int stylesState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_styles,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, sipType_wxString, &styles, &stylesState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarginSetStyles(line,*styles);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(styles), sipType_wxString, stylesState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginSetStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginGetStyles, "MarginGetStyles(line) -> String\n"
"\n"
"Get the styles in the text margin for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginGetStyles(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginGetStyles(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->MarginGetStyles(line));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginGetStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginTextClearAll, "MarginTextClearAll()\n"
"\n"
"Clear the margin text on all lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginTextClearAll(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginTextClearAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarginTextClearAll();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginTextClearAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginSetStyleOffset, "MarginSetStyleOffset(style)\n"
"\n"
"Get the start of the range of style numbers used for margin text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginSetStyleOffset(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginSetStyleOffset(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarginSetStyleOffset(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginSetStyleOffset, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarginGetStyleOffset, "MarginGetStyleOffset() -> int\n"
"\n"
"Get the start of the range of style numbers used for margin text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarginGetStyleOffset(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarginGetStyleOffset(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MarginGetStyleOffset();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarginGetStyleOffset, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMarginOptions, "SetMarginOptions(marginOptions)\n"
"\n"
"Set the margin options.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMarginOptions(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMarginOptions(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int marginOptions;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_marginOptions,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &marginOptions))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMarginOptions(marginOptions);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMarginOptions, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarginOptions, "GetMarginOptions() -> int\n"
"\n"
"Get the margin options.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarginOptions(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarginOptions(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarginOptions();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarginOptions, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationSetText, "AnnotationSetText(line, text)\n"
"\n"
"Set the annotation text for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationSetText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationSetText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AnnotationSetText(line,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationSetText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationGetText, "AnnotationGetText(line) -> String\n"
"\n"
"Get the annotation text for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationGetText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationGetText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->AnnotationGetText(line));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationGetText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationSetStyle, "AnnotationSetStyle(line, style)\n"
"\n"
"Set the style number for the annotations for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationSetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationSetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AnnotationSetStyle(line,style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationSetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationGetStyle, "AnnotationGetStyle(line) -> int\n"
"\n"
"Get the style number for the annotations for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationGetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationGetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AnnotationGetStyle(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationGetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationSetStyles, "AnnotationSetStyles(line, styles)\n"
"\n"
"Set the annotation styles for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationSetStyles(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationSetStyles(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxString* styles;
        int stylesState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_styles,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, sipType_wxString, &styles, &stylesState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AnnotationSetStyles(line,*styles);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(styles), sipType_wxString, stylesState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationSetStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationGetStyles, "AnnotationGetStyles(line) -> String\n"
"\n"
"Get the annotation styles for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationGetStyles(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationGetStyles(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->AnnotationGetStyles(line));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationGetStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationGetLines, "AnnotationGetLines(line) -> int\n"
"\n"
"Get the number of annotation lines for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationGetLines(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationGetLines(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AnnotationGetLines(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationGetLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationClearAll, "AnnotationClearAll()\n"
"\n"
"Clear the annotations from all lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationClearAll(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationClearAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AnnotationClearAll();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationClearAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationSetVisible, "AnnotationSetVisible(visible)\n"
"\n"
"Set the visibility for the annotations for a view.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationSetVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationSetVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int visible;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_visible,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &visible))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AnnotationSetVisible(visible);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationSetVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationGetVisible, "AnnotationGetVisible() -> int\n"
"\n"
"Get the visibility for the annotations for a view.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationGetVisible(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationGetVisible(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AnnotationGetVisible();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationGetVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationSetStyleOffset, "AnnotationSetStyleOffset(style)\n"
"\n"
"Get the start of the range of style numbers used for annotations.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationSetStyleOffset(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationSetStyleOffset(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AnnotationSetStyleOffset(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationSetStyleOffset, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationGetStyleOffset, "AnnotationGetStyleOffset() -> int\n"
"\n"
"Get the start of the range of style numbers used for annotations.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationGetStyleOffset(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationGetStyleOffset(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AnnotationGetStyleOffset();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationGetStyleOffset, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetBufferedDraw, "GetBufferedDraw() -> bool\n"
"\n"
"Is drawing done first into a buffer or direct to the screen?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetBufferedDraw(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetBufferedDraw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetBufferedDraw();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetBufferedDraw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetBufferedDraw, "SetBufferedDraw(buffered)\n"
"\n"
"If drawing is buffered then each line of text is drawn into a bitmap\n"
"buffer before drawing it to the screen to avoid flicker.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetBufferedDraw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetBufferedDraw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool buffered;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_buffered,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &buffered))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetBufferedDraw(buffered);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetBufferedDraw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetCodePage, "SetCodePage(codePage)\n"
"\n"
"Set the code page used to interpret the bytes of the document as\n"
"characters.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetCodePage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetCodePage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int codePage;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_codePage,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &codePage))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCodePage(codePage);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetCodePage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetIMEInteraction, "GetIMEInteraction() -> int\n"
"\n"
"Is the IME displayed in a window or inline?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetIMEInteraction(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetIMEInteraction(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIMEInteraction();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetIMEInteraction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetIMEInteraction, "SetIMEInteraction(imeInteraction)\n"
"\n"
"Choose to display the IME in a winow or inline.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetIMEInteraction(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetIMEInteraction(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int imeInteraction;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_imeInteraction,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &imeInteraction))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIMEInteraction(imeInteraction);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetIMEInteraction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCodePage, "GetCodePage() -> int\n"
"\n"
"Get the code page used to interpret the bytes of the document as\n"
"characters.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCodePage(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCodePage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCodePage();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCodePage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetLayoutCache, "SetLayoutCache(cacheMode)\n"
"\n"
"Sets the degree of caching of layout information.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetLayoutCache(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetLayoutCache(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int cacheMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cacheMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &cacheMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLayoutCache(cacheMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetLayoutCache, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTwoPhaseDraw, "GetTwoPhaseDraw() -> bool\n"
"\n"
"Is drawing done in two phases with backgrounds drawn before\n"
"foregrounds?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTwoPhaseDraw(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTwoPhaseDraw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTwoPhaseDraw();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTwoPhaseDraw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTwoPhaseDraw, "SetTwoPhaseDraw(twoPhase)\n"
"\n"
"In twoPhaseDraw mode, drawing is performed in two phases, first the\n"
"background and then the foreground.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTwoPhaseDraw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTwoPhaseDraw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool twoPhase;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_twoPhase,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &twoPhase))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTwoPhaseDraw(twoPhase);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTwoPhaseDraw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPhasesDraw, "GetPhasesDraw() -> int\n"
"\n"
"How many phases is drawing done in?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPhasesDraw(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPhasesDraw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPhasesDraw();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPhasesDraw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetPhasesDraw, "SetPhasesDraw(phases)\n"
"\n"
"In one phase draw, text is drawn in a series of rectangular blocks\n"
"with no overlap.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetPhasesDraw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetPhasesDraw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int phases;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_phases,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &phases))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPhasesDraw(phases);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetPhasesDraw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetFontQuality, "SetFontQuality(fontQuality)\n"
"\n"
"Choose the quality level for text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetFontQuality(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetFontQuality(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int fontQuality;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fontQuality,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &fontQuality))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFontQuality(fontQuality);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetFontQuality, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetFontQuality, "GetFontQuality() -> int\n"
"\n"
"Retrieve the quality level for text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetFontQuality(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetFontQuality(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFontQuality();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetFontQuality, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSTCFocus, "SetSTCFocus(focus)\n"
"\n"
"Change internal focus flag.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSTCFocus(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSTCFocus(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool focus;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_focus,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &focus))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSTCFocus(focus);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSTCFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSTCFocus, "GetSTCFocus() -> bool\n"
"\n"
"Get internal focus flag.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSTCFocus(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSTCFocus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSTCFocus();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSTCFocus, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTechnology, "SetTechnology(technology)\n"
"\n"
"Set the technology used.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTechnology(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTechnology(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int technology;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_technology,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &technology))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTechnology(technology);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTechnology, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTechnology, "GetTechnology() -> int\n"
"\n"
"Get the tech.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTechnology(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTechnology(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTechnology();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTechnology, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_BraceHighlight, "BraceHighlight(posA, posB)\n"
"\n"
"Highlight the characters at two positions.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_BraceHighlight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_BraceHighlight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int posA;
        int posB;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_posA,
            sipName_posB,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &posA, &posB))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->BraceHighlight(posA,posB);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_BraceHighlight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_BraceHighlightIndicator, "BraceHighlightIndicator(useSetting, indicator)\n"
"\n"
"Use specified indicator to highlight matching braces instead of\n"
"changing their style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_BraceHighlightIndicator(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_BraceHighlightIndicator(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        int indicator;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bbi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, &indicator))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->BraceHighlightIndicator(useSetting,indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_BraceHighlightIndicator, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_BraceBadLight, "BraceBadLight(pos)\n"
"\n"
"Highlight the character at a position indicating there is no matching\n"
"brace.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_BraceBadLight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_BraceBadLight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->BraceBadLight(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_BraceBadLight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_BraceBadLightIndicator, "BraceBadLightIndicator(useSetting, indicator)\n"
"\n"
"Use specified indicator to highlight non matching brace instead of\n"
"changing its style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_BraceBadLightIndicator(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_BraceBadLightIndicator(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useSetting;
        int indicator;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useSetting,
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bbi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useSetting, &indicator))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->BraceBadLightIndicator(useSetting,indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_BraceBadLightIndicator, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_BraceMatch, "BraceMatch(pos, maxReStyle=0) -> int\n"
"\n"
"Find the position of a matching brace or wxSTC_INVALID_POSITION if no\n"
"match.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_BraceMatch(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_BraceMatch(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        int maxReStyle = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_maxReStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|i", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos, &maxReStyle))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->BraceMatch(pos,maxReStyle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_BraceMatch, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTabWidth, "SetTabWidth(tabWidth)\n"
"\n"
"Change the visible size of a tab to be a multiple of the width of a\n"
"space character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTabWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTabWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int tabWidth;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_tabWidth,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &tabWidth))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTabWidth(tabWidth);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTabWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTabWidth, "GetTabWidth() -> int\n"
"\n"
"Retrieve the visible size of a tab.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTabWidth(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTabWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTabWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTabWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ClearTabStops, "ClearTabStops(line)\n"
"\n"
"Clear explicit tabstops on a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ClearTabStops(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ClearTabStops(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearTabStops(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ClearTabStops, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AddTabStop, "AddTabStop(line, x)\n"
"\n"
"Add an explicit tab stop for a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AddTabStop(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AddTabStop(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int x;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_x,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &x))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AddTabStop(line,x);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AddTabStop, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetNextTabStop, "GetNextTabStop(line, x) -> int\n"
"\n"
"Find the next explicit tab stop position on a line after a position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetNextTabStop(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetNextTabStop(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int x;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_x,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &x))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetNextTabStop(line,x);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetNextTabStop, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetIndent, "SetIndent(indentSize)\n"
"\n"
"Set the number of spaces used for one level of indentation.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetIndent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetIndent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indentSize;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indentSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indentSize))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIndent(indentSize);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetIndent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetIndent, "GetIndent() -> int\n"
"\n"
"Retrieve indentation size.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetIndent(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetIndent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIndent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetIndent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetUseTabs, "SetUseTabs(useTabs)\n"
"\n"
"Indentation will only use space characters if useTabs is false,\n"
"otherwise it will use a combination of tabs and spaces.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetUseTabs(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetUseTabs(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useTabs;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useTabs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useTabs))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetUseTabs(useTabs);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetUseTabs, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetUseTabs, "GetUseTabs() -> bool\n"
"\n"
"Retrieve whether tabs will be used in indentation.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetUseTabs(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetUseTabs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetUseTabs();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetUseTabs, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetLineIndentation, "SetLineIndentation(line, indentation)\n"
"\n"
"Change the indentation of a line to a number of columns.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetLineIndentation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetLineIndentation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int indentation;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_indentation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &indentation))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLineIndentation(line,indentation);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetLineIndentation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineIndentation, "GetLineIndentation(line) -> int\n"
"\n"
"Retrieve the number of columns that a line is indented.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineIndentation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineIndentation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineIndentation(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineIndentation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineIndentPosition, "GetLineIndentPosition(line) -> int\n"
"\n"
"Retrieve the position before the first non indentation character on a\n"
"line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineIndentPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineIndentPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineIndentPosition(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineIndentPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetIndentationGuides, "SetIndentationGuides(indentView)\n"
"\n"
"Show or hide indentation guides.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetIndentationGuides(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetIndentationGuides(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indentView;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indentView,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indentView))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIndentationGuides(indentView);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetIndentationGuides, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetIndentationGuides, "GetIndentationGuides() -> int\n"
"\n"
"Are the indentation guides visible?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetIndentationGuides(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetIndentationGuides(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIndentationGuides();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetIndentationGuides, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetHighlightGuide, "SetHighlightGuide(column)\n"
"\n"
"Set the highlighted indentation guide column.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetHighlightGuide(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetHighlightGuide(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int column;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &column))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHighlightGuide(column);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetHighlightGuide, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetHighlightGuide, "GetHighlightGuide() -> int\n"
"\n"
"Get the highlighted indentation guide column.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetHighlightGuide(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetHighlightGuide(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetHighlightGuide();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetHighlightGuide, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTabIndents, "SetTabIndents(tabIndents)\n"
"\n"
"Sets whether a tab pressed when caret is within indentation indents.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTabIndents(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTabIndents(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool tabIndents;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_tabIndents,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &tabIndents))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTabIndents(tabIndents);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTabIndents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTabIndents, "GetTabIndents() -> bool\n"
"\n"
"Does a tab pressed when caret is within indentation indent?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTabIndents(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTabIndents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTabIndents();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTabIndents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetBackSpaceUnIndents, "SetBackSpaceUnIndents(bsUnIndents)\n"
"\n"
"Sets whether a backspace pressed when caret is within indentation\n"
"unindents.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetBackSpaceUnIndents(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetBackSpaceUnIndents(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool bsUnIndents;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bsUnIndents,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &bsUnIndents))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetBackSpaceUnIndents(bsUnIndents);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetBackSpaceUnIndents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetBackSpaceUnIndents, "GetBackSpaceUnIndents() -> bool\n"
"\n"
"Does a backspace pressed when caret is within indentation unindent?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetBackSpaceUnIndents(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetBackSpaceUnIndents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetBackSpaceUnIndents();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetBackSpaceUnIndents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerLineFromHandle, "MarkerLineFromHandle(markerHandle) -> int\n"
"\n"
"Retrieve the line number at which a particular marker is located.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerLineFromHandle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerLineFromHandle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerHandle;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerHandle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerHandle))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MarkerLineFromHandle(markerHandle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerLineFromHandle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerDeleteHandle, "MarkerDeleteHandle(markerHandle)\n"
"\n"
"Delete a marker.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerDeleteHandle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerDeleteHandle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerHandle;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerHandle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerHandle))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerDeleteHandle(markerHandle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerDeleteHandle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerDefine, "MarkerDefine(markerNumber, markerSymbol, foreground=NullColour, background=NullColour)\n"
"\n"
"Set the symbol used for a particular marker number, and optionally the\n"
"fore and background colours.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerDefine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerDefine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
        int markerSymbol;
        const  ::wxColour& foregrounddef = wxNullColour;
        const  ::wxColour* foreground = &foregrounddef;
        int foregroundState = 0;
        const  ::wxColour& backgrounddef = wxNullColour;
        const  ::wxColour* background = &backgrounddef;
        int backgroundState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
            sipName_markerSymbol,
            sipName_foreground,
            sipName_background,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|J1J1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber, &markerSymbol, sipType_wxColour, &foreground, &foregroundState, sipType_wxColour, &background, &backgroundState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerDefine(markerNumber,markerSymbol,*foreground,*background);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(foreground), sipType_wxColour, foregroundState);
            sipReleaseType(const_cast< ::wxColour *>(background), sipType_wxColour, backgroundState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerDefine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerSetForeground, "MarkerSetForeground(markerNumber, fore)\n"
"\n"
"Set the foreground colour used for a particular marker number.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerSetForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerSetForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerSetForeground(markerNumber,*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerSetForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerSetBackground, "MarkerSetBackground(markerNumber, back)\n"
"\n"
"Set the background colour used for a particular marker number.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerSetBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerSetBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerSetBackground(markerNumber,*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerSetBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerSetBackgroundSelected, "MarkerSetBackgroundSelected(markerNumber, back)\n"
"\n"
"Set the background colour used for a particular marker number when its\n"
"folding block is selected.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerSetBackgroundSelected(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerSetBackgroundSelected(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerSetBackgroundSelected(markerNumber,*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerSetBackgroundSelected, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerEnableHighlight, "MarkerEnableHighlight(enabled)\n"
"\n"
"Enable/disable highlight for current folding block (smallest one that\n"
"contains the caret)");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerEnableHighlight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerEnableHighlight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool enabled;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enabled,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &enabled))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerEnableHighlight(enabled);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerEnableHighlight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerAdd, "MarkerAdd(line, markerNumber) -> int\n"
"\n"
"Add a marker to a line, returning an ID which can be used to find or\n"
"delete the marker.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerAdd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerAdd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int markerNumber;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_markerNumber,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &markerNumber))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MarkerAdd(line,markerNumber);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerAdd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerDelete, "MarkerDelete(line, markerNumber)\n"
"\n"
"Delete a marker from a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerDelete(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerDelete(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int markerNumber;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_markerNumber,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &markerNumber))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerDelete(line,markerNumber);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerDelete, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerDeleteAll, "MarkerDeleteAll(markerNumber)\n"
"\n"
"Delete all markers with a particular number from all lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerDeleteAll(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerDeleteAll(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerDeleteAll(markerNumber);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerDeleteAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerGet, "MarkerGet(line) -> int\n"
"\n"
"Get a bit mask of all the markers set on a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerGet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerGet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MarkerGet(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerGet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerNext, "MarkerNext(lineStart, markerMask) -> int\n"
"\n"
"Find the next line at or after lineStart that includes a marker in\n"
"mask.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerNext(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerNext(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lineStart;
        int markerMask;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineStart,
            sipName_markerMask,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lineStart, &markerMask))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MarkerNext(lineStart,markerMask);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerNext, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerPrevious, "MarkerPrevious(lineStart, markerMask) -> int\n"
"\n"
"Find the previous line before lineStart that includes a marker in\n"
"mask.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerPrevious(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerPrevious(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lineStart;
        int markerMask;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineStart,
            sipName_markerMask,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lineStart, &markerMask))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->MarkerPrevious(lineStart,markerMask);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerPrevious, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerAddSet, "MarkerAddSet(line, markerSet)\n"
"\n"
"Add a set of markers to a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerAddSet(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerAddSet(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int markerSet;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_markerSet,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &markerSet))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerAddSet(line,markerSet);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerAddSet, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerSetAlpha, "MarkerSetAlpha(markerNumber, alpha)\n"
"\n"
"Set the alpha used for a marker that is drawn in the text area, not\n"
"the margin.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerSetAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerSetAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
        int alpha;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber, &alpha))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerSetAlpha(markerNumber,alpha);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerSetAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMarkerSymbolDefined, "GetMarkerSymbolDefined(markerNumber) -> int\n"
"\n"
"Which symbol was defined for markerNumber with MarkerDefine.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMarkerSymbolDefined(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMarkerSymbolDefined(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMarkerSymbolDefined(markerNumber);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMarkerSymbolDefined, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_RGBAImageSetWidth, "RGBAImageSetWidth(width)\n"
"\n"
"Set the width for future RGBA image data.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_RGBAImageSetWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_RGBAImageSetWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int width;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &width))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RGBAImageSetWidth(width);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_RGBAImageSetWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_RGBAImageSetHeight, "RGBAImageSetHeight(height)\n"
"\n"
"Set the height for future RGBA image data.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_RGBAImageSetHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_RGBAImageSetHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int height;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RGBAImageSetHeight(height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_RGBAImageSetHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_RGBAImageSetScale, "RGBAImageSetScale(scalePercent)\n"
"\n"
"Set the scale factor in percent for future RGBA image data.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_RGBAImageSetScale(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_RGBAImageSetScale(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int scalePercent;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_scalePercent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &scalePercent))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RGBAImageSetScale(scalePercent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_RGBAImageSetScale, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerDefineRGBAImage, "MarkerDefineRGBAImage(markerNumber, pixels)\n"
"\n"
"Define a marker from RGBA data.\n"
"\n"
"It has the width and height from RGBAImageSetWidth/Height. You must\n"
"ensure that the buffer is at least width*height*4 bytes long.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerDefineRGBAImage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerDefineRGBAImage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
         ::wxPyBuffer* pixels;
        int pixelsState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
            sipName_pixels,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ0", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber, sipType_wxPyBuffer, &pixels, &pixelsState))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxStyledTextCtrl_MarkerDefineRGBAImage(sipCpp, markerNumber, pixels);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(pixels, sipType_wxPyBuffer, pixelsState);

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerDefineRGBAImage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorSetStyle, "IndicatorSetStyle(indicator, indicatorStyle)\n"
"\n"
"Set an indicator to plain, squiggle or TT.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorSetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorSetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        int indicatorStyle;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_indicatorStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &indicatorStyle))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorSetStyle(indicator,indicatorStyle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorSetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorGetStyle, "IndicatorGetStyle(indicator) -> int\n"
"\n"
"Retrieve the style of an indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorGetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorGetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorGetStyle(indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorGetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorSetForeground, "IndicatorSetForeground(indicator, fore)\n"
"\n"
"Set the foreground colour of an indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorSetForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorSetForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorSetForeground(indicator,*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorSetForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorGetForeground, "IndicatorGetForeground(indicator) -> Colour\n"
"\n"
"Retrieve the foreground colour of an indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorGetForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorGetForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->IndicatorGetForeground(indicator));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorGetForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorSetUnder, "IndicatorSetUnder(indicator, under)\n"
"\n"
"Set an indicator to draw under text or over(default).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorSetUnder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorSetUnder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        bool under;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_under,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &under))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorSetUnder(indicator,under);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorSetUnder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorGetUnder, "IndicatorGetUnder(indicator) -> bool\n"
"\n"
"Retrieve whether indicator drawn under or over text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorGetUnder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorGetUnder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorGetUnder(indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorGetUnder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorSetHoverStyle, "IndicatorSetHoverStyle(indicator, indicatorStyle)\n"
"\n"
"Set a hover indicator to plain, squiggle or TT.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorSetHoverStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorSetHoverStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        int indicatorStyle;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_indicatorStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &indicatorStyle))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorSetHoverStyle(indicator,indicatorStyle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorSetHoverStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorGetHoverStyle, "IndicatorGetHoverStyle(indicator) -> int\n"
"\n"
"Retrieve the hover style of an indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorGetHoverStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorGetHoverStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorGetHoverStyle(indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorGetHoverStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorSetHoverForeground, "IndicatorSetHoverForeground(indicator, fore)\n"
"\n"
"Set the foreground hover colour of an indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorSetHoverForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorSetHoverForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorSetHoverForeground(indicator,*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorSetHoverForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorGetHoverForeground, "IndicatorGetHoverForeground(indicator) -> Colour\n"
"\n"
"Retrieve the foreground hover colour of an indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorGetHoverForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorGetHoverForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->IndicatorGetHoverForeground(indicator));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorGetHoverForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorSetFlags, "IndicatorSetFlags(indicator, flags)\n"
"\n"
"Set the attributes of an indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorSetFlags(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorSetFlags(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        int flags;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorSetFlags(indicator,flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorSetFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorGetFlags, "IndicatorGetFlags(indicator) -> int\n"
"\n"
"Retrieve the attributes of an indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorGetFlags(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorGetFlags(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorGetFlags(indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorGetFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetIndicatorCurrent, "SetIndicatorCurrent(indicator)\n"
"\n"
"Set the indicator used for IndicatorFillRange and IndicatorClearRange.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetIndicatorCurrent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetIndicatorCurrent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIndicatorCurrent(indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetIndicatorCurrent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetIndicatorCurrent, "GetIndicatorCurrent() -> int\n"
"\n"
"Get the current indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetIndicatorCurrent(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetIndicatorCurrent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIndicatorCurrent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetIndicatorCurrent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetIndicatorValue, "SetIndicatorValue(value)\n"
"\n"
"Set the value used for IndicatorFillRange.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetIndicatorValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetIndicatorValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int value;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &value))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIndicatorValue(value);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetIndicatorValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetIndicatorValue, "GetIndicatorValue() -> int\n"
"\n"
"Get the current indicator value.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetIndicatorValue(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetIndicatorValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIndicatorValue();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetIndicatorValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorFillRange, "IndicatorFillRange(start, lengthFill)\n"
"\n"
"Turn an indicator on over a range.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorFillRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorFillRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int lengthFill;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_lengthFill,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &lengthFill))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorFillRange(start,lengthFill);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorFillRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorClearRange, "IndicatorClearRange(start, lengthClear)\n"
"\n"
"Turn an indicator off over a range.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorClearRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorClearRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int lengthClear;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_lengthClear,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &lengthClear))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorClearRange(start,lengthClear);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorClearRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorAllOnFor, "IndicatorAllOnFor(pos) -> int\n"
"\n"
"Are any indicators present at pos?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorAllOnFor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorAllOnFor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorAllOnFor(pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorAllOnFor, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorValueAt, "IndicatorValueAt(indicator, pos) -> int\n"
"\n"
"What value does a particular indicator have at a position?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorValueAt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorValueAt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        int pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorValueAt(indicator,pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorValueAt, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorStart, "IndicatorStart(indicator, pos) -> int\n"
"\n"
"Where does a particular indicator start?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        int pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorStart(indicator,pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorEnd, "IndicatorEnd(indicator, pos) -> int\n"
"\n"
"Where does a particular indicator end?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorEnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorEnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        int pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &pos))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorEnd(indicator,pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorSetAlpha, "IndicatorSetAlpha(indicator, alpha)\n"
"\n"
"Set the alpha fill colour of the given indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorSetAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorSetAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        int alpha;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &alpha))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorSetAlpha(indicator,alpha);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorSetAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorGetAlpha, "IndicatorGetAlpha(indicator) -> int\n"
"\n"
"Get the alpha fill colour of the given indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorGetAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorGetAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorGetAlpha(indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorGetAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorSetOutlineAlpha, "IndicatorSetOutlineAlpha(indicator, alpha)\n"
"\n"
"Set the alpha outline colour of the given indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorSetOutlineAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorSetOutlineAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        int alpha;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator, &alpha))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->IndicatorSetOutlineAlpha(indicator,alpha);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorSetOutlineAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IndicatorGetOutlineAlpha, "IndicatorGetOutlineAlpha(indicator) -> int\n"
"\n"
"Get the alpha outline colour of the given indicator.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IndicatorGetOutlineAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IndicatorGetOutlineAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indicator;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indicator,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indicator))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IndicatorGetOutlineAlpha(indicator);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IndicatorGetOutlineAlpha, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompShow, "AutoCompShow(lengthEntered, itemList)\n"
"\n"
"Display an auto-completion list.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompShow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompShow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lengthEntered;
        const  ::wxString* itemList;
        int itemListState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lengthEntered,
            sipName_itemList,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lengthEntered, sipType_wxString, &itemList, &itemListState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompShow(lengthEntered,*itemList);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(itemList), sipType_wxString, itemListState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompShow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompCancel, "AutoCompCancel()\n"
"\n"
"Remove the auto-completion list from the screen.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompCancel(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompCancel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompCancel();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompCancel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompActive, "AutoCompActive() -> bool\n"
"\n"
"Is there an auto-completion list visible?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompActive(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompActive(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompActive();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompActive, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompPosStart, "AutoCompPosStart() -> int\n"
"\n"
"Retrieve the position of the caret when the auto-completion list was\n"
"displayed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompPosStart(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompPosStart(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompPosStart();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompPosStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompComplete, "AutoCompComplete()\n"
"\n"
"User has selected an item so remove the list and insert the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompComplete(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompComplete(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompComplete();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompComplete, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompStops, "AutoCompStops(characterSet)\n"
"\n"
"Define a set of character that when typed cancel the auto-completion\n"
"list.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompStops(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompStops(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* characterSet;
        int characterSetState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_characterSet,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &characterSet, &characterSetState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompStops(*characterSet);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(characterSet), sipType_wxString, characterSetState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompStops, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetSeparator, "AutoCompSetSeparator(separatorCharacter)\n"
"\n"
"Change the separator character in the string setting up an auto-\n"
"completion list.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetSeparator(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetSeparator(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int separatorCharacter;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_separatorCharacter,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &separatorCharacter))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetSeparator(separatorCharacter);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetSeparator, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetSeparator, "AutoCompGetSeparator() -> int\n"
"\n"
"Retrieve the auto-completion list separator character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetSeparator(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetSeparator(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetSeparator();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetSeparator, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSelect, "AutoCompSelect(select)\n"
"\n"
"Select the item in the auto-completion list that starts with a string.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSelect(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSelect(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* select;
        int selectState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_select,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &select, &selectState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSelect(*select);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(select), sipType_wxString, selectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSelect, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetCancelAtStart, "AutoCompSetCancelAtStart(cancel)\n"
"\n"
"Should the auto-completion list be cancelled if the user backspaces to\n"
"a position before where the box was created.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetCancelAtStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetCancelAtStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool cancel;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cancel,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &cancel))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetCancelAtStart(cancel);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetCancelAtStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetCancelAtStart, "AutoCompGetCancelAtStart() -> bool\n"
"\n"
"Retrieve whether auto-completion cancelled by backspacing before\n"
"start.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetCancelAtStart(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetCancelAtStart(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetCancelAtStart();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetCancelAtStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetFillUps, "AutoCompSetFillUps(characterSet)\n"
"\n"
"Define a set of characters that when typed will cause the\n"
"autocompletion to choose the selected item.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetFillUps(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetFillUps(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* characterSet;
        int characterSetState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_characterSet,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &characterSet, &characterSetState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetFillUps(*characterSet);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(characterSet), sipType_wxString, characterSetState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetFillUps, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetChooseSingle, "AutoCompSetChooseSingle(chooseSingle)\n"
"\n"
"Should a single item auto-completion list automatically choose the\n"
"item.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetChooseSingle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetChooseSingle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool chooseSingle;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chooseSingle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &chooseSingle))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetChooseSingle(chooseSingle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetChooseSingle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetChooseSingle, "AutoCompGetChooseSingle() -> bool\n"
"\n"
"Retrieve whether a single item auto-completion list automatically\n"
"choose the item.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetChooseSingle(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetChooseSingle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetChooseSingle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetChooseSingle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetIgnoreCase, "AutoCompSetIgnoreCase(ignoreCase)\n"
"\n"
"Set whether case is significant when performing auto-completion\n"
"searches.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetIgnoreCase(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetIgnoreCase(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool ignoreCase;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_ignoreCase,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &ignoreCase))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetIgnoreCase(ignoreCase);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetIgnoreCase, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetIgnoreCase, "AutoCompGetIgnoreCase() -> bool\n"
"\n"
"Retrieve state of ignore case flag.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetIgnoreCase(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetIgnoreCase(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetIgnoreCase();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetIgnoreCase, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetAutoHide, "AutoCompSetAutoHide(autoHide)\n"
"\n"
"Set whether or not autocompletion is hidden automatically when nothing\n"
"matches.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetAutoHide(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetAutoHide(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool autoHide;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_autoHide,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &autoHide))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetAutoHide(autoHide);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetAutoHide, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetAutoHide, "AutoCompGetAutoHide() -> bool\n"
"\n"
"Retrieve whether or not autocompletion is hidden automatically when\n"
"nothing matches.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetAutoHide(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetAutoHide(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetAutoHide();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetAutoHide, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetDropRestOfWord, "AutoCompSetDropRestOfWord(dropRestOfWord)\n"
"\n"
"Set whether or not autocompletion deletes any word characters after\n"
"the inserted text upon completion.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetDropRestOfWord(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetDropRestOfWord(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool dropRestOfWord;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_dropRestOfWord,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &dropRestOfWord))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetDropRestOfWord(dropRestOfWord);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetDropRestOfWord, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetDropRestOfWord, "AutoCompGetDropRestOfWord() -> bool\n"
"\n"
"Retrieve whether or not autocompletion deletes any word characters\n"
"after the inserted text upon completion.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetDropRestOfWord(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetDropRestOfWord(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetDropRestOfWord();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetDropRestOfWord, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_RegisterImage, "RegisterImage(type, bmp)\n"
"\n"
"Register an image for use in autocompletion lists.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_RegisterImage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_RegisterImage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int type;
        const  ::wxBitmap* bmp;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_type,
            sipName_bmp,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &type, sipType_wxBitmap, &bmp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RegisterImage(type,*bmp);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_RegisterImage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ClearRegisteredImages, "ClearRegisteredImages()\n"
"\n"
"Clear all the registered images.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ClearRegisteredImages(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ClearRegisteredImages(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ClearRegisteredImages();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ClearRegisteredImages, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetTypeSeparator, "AutoCompGetTypeSeparator() -> int\n"
"\n"
"Retrieve the auto-completion list type-separator character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetTypeSeparator(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetTypeSeparator(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetTypeSeparator();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetTypeSeparator, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetTypeSeparator, "AutoCompSetTypeSeparator(separatorCharacter)\n"
"\n"
"Change the type-separator character in the string setting up an auto-\n"
"completion list.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetTypeSeparator(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetTypeSeparator(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int separatorCharacter;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_separatorCharacter,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &separatorCharacter))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetTypeSeparator(separatorCharacter);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetTypeSeparator, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetMaxWidth, "AutoCompSetMaxWidth(characterCount)\n"
"\n"
"Set the maximum width, in characters, of auto-completion and user\n"
"lists.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetMaxWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetMaxWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int characterCount;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_characterCount,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &characterCount))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetMaxWidth(characterCount);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetMaxWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetMaxWidth, "AutoCompGetMaxWidth() -> int\n"
"\n"
"Get the maximum width, in characters, of auto-completion and user\n"
"lists.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetMaxWidth(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetMaxWidth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetMaxWidth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetMaxWidth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetMaxHeight, "AutoCompSetMaxHeight(rowCount)\n"
"\n"
"Set the maximum height, in rows, of auto-completion and user lists.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetMaxHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetMaxHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int rowCount;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rowCount,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &rowCount))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetMaxHeight(rowCount);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetMaxHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetMaxHeight, "AutoCompGetMaxHeight() -> int\n"
"\n"
"Set the maximum height, in rows, of auto-completion and user lists.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetMaxHeight(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetMaxHeight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetMaxHeight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetMaxHeight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetCurrent, "AutoCompGetCurrent() -> int\n"
"\n"
"Get currently selected item position in the auto-completion list.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetCurrent(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetCurrent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetCurrent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetCurrent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetCurrentText, "AutoCompGetCurrentText() -> String\n"
"\n"
"Get currently selected item text in the auto-completion list.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetCurrentText(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetCurrentText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->AutoCompGetCurrentText());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetCurrentText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetCaseInsensitiveBehaviour, "AutoCompSetCaseInsensitiveBehaviour(behaviour)\n"
"\n"
"Set auto-completion case insensitive behaviour to either prefer case-\n"
"sensitive matches or have no preference.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetCaseInsensitiveBehaviour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetCaseInsensitiveBehaviour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int behaviour;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_behaviour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &behaviour))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetCaseInsensitiveBehaviour(behaviour);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetCaseInsensitiveBehaviour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetCaseInsensitiveBehaviour, "AutoCompGetCaseInsensitiveBehaviour() -> int\n"
"\n"
"Get auto-completion case insensitive behaviour.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetCaseInsensitiveBehaviour(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetCaseInsensitiveBehaviour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetCaseInsensitiveBehaviour();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetCaseInsensitiveBehaviour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetMulti, "AutoCompSetMulti(multi)\n"
"\n"
"Change the effect of autocompleting when there are multiple\n"
"selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetMulti(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetMulti(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int multi;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_multi,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &multi))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetMulti(multi);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetMulti, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetMulti, "AutoCompGetMulti() -> int\n"
"\n"
"Retrieve the effect of autocompleting when there are multiple\n"
"selections.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetMulti(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetMulti(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetMulti();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetMulti, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompSetOrder, "AutoCompSetOrder(order)\n"
"\n"
"Set the way autocompletion lists are ordered.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompSetOrder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompSetOrder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int order;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_order,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &order))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AutoCompSetOrder(order);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompSetOrder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompGetOrder, "AutoCompGetOrder() -> int\n"
"\n"
"Get the way autocompletion lists are ordered.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompGetOrder(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompGetOrder(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompGetOrder();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompGetOrder, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_RegisterRGBAImage, "RegisterRGBAImage(type, pixels)\n"
"\n"
"Register an RGBA image for use in autocompletion lists.\n"
"\n"
"It has the width and height from RGBAImageSetWidth/Height. You must\n"
"ensure that the buffer is at least width*height*4 bytes long.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_RegisterRGBAImage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_RegisterRGBAImage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int type;
         ::wxPyBuffer* pixels;
        int pixelsState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_type,
            sipName_pixels,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ0", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &type, sipType_wxPyBuffer, &pixels, &pixelsState))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxStyledTextCtrl_RegisterRGBAImage(sipCpp, type, pixels);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(pixels, sipType_wxPyBuffer, pixelsState);

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_RegisterRGBAImage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_UserListShow, "UserListShow(listType, itemList)\n"
"\n"
"Display a list of strings and send notification when user chooses one.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_UserListShow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_UserListShow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int listType;
        const  ::wxString* itemList;
        int itemListState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_listType,
            sipName_itemList,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &listType, sipType_wxString, &itemList, &itemListState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->UserListShow(listType,*itemList);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(itemList), sipType_wxString, itemListState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_UserListShow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipShow, "CallTipShow(pos, definition)\n"
"\n"
"Show a call tip containing a definition near position pos.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipShow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipShow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        const  ::wxString* definition;
        int definitionState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_definition,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos, sipType_wxString, &definition, &definitionState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipShow(pos,*definition);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(definition), sipType_wxString, definitionState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipShow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipCancel, "CallTipCancel()\n"
"\n"
"Remove the call tip from the screen.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipCancel(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipCancel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipCancel();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipCancel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipActive, "CallTipActive() -> bool\n"
"\n"
"Is there an active call tip?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipActive(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipActive(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CallTipActive();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipActive, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipPosAtStart, "CallTipPosAtStart() -> int\n"
"\n"
"Retrieve the position where the caret was before displaying the call\n"
"tip.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipPosAtStart(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipPosAtStart(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CallTipPosAtStart();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipPosAtStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipSetPosAtStart, "CallTipSetPosAtStart(posStart)\n"
"\n"
"Set the start position in order to change when backspacing removes the\n"
"calltip.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipSetPosAtStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipSetPosAtStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int posStart;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_posStart,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &posStart))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipSetPosAtStart(posStart);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipSetPosAtStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipSetHighlight, "CallTipSetHighlight(highlightStart, highlightEnd)\n"
"\n"
"Highlight a segment of the definition.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipSetHighlight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipSetHighlight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int highlightStart;
        int highlightEnd;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_highlightStart,
            sipName_highlightEnd,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &highlightStart, &highlightEnd))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipSetHighlight(highlightStart,highlightEnd);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipSetHighlight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipSetBackground, "CallTipSetBackground(back)\n"
"\n"
"Set the background colour for the call tip.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipSetBackground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipSetBackground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* back;
        int backState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_back,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &back, &backState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipSetBackground(*back);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(back), sipType_wxColour, backState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipSetBackground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipSetForeground, "CallTipSetForeground(fore)\n"
"\n"
"Set the foreground colour for the call tip.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipSetForeground(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipSetForeground(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipSetForeground(*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipSetForeground, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipSetForegroundHighlight, "CallTipSetForegroundHighlight(fore)\n"
"\n"
"Set the foreground colour for the highlighted part of the call tip.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipSetForegroundHighlight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipSetForegroundHighlight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* fore;
        int foreState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fore,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &fore, &foreState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipSetForegroundHighlight(*fore);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(fore), sipType_wxColour, foreState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipSetForegroundHighlight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipUseStyle, "CallTipUseStyle(tabSize)\n"
"\n"
"Enable use of wxSTC_STYLE_CALLTIP and set call tip tab size in pixels.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipUseStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipUseStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int tabSize;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_tabSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &tabSize))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipUseStyle(tabSize);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipUseStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CallTipSetPosition, "CallTipSetPosition(above)\n"
"\n"
"Set position of calltip, above or below text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CallTipSetPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CallTipSetPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool above;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_above,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &above))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CallTipSetPosition(above);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CallTipSetPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineDown, "LineDown()\n"
"\n"
"Move caret down one line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineDown(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineDownExtend, "LineDownExtend()\n"
"\n"
"Move caret down one line extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineDownExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineDownExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineDownExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineDownExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineUp, "LineUp()\n"
"\n"
"Move caret up one line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineUp(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineUpExtend, "LineUpExtend()\n"
"\n"
"Move caret up one line extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineUpExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineUpExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineUpExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineUpExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CharLeft, "CharLeft()\n"
"\n"
"Move caret left one character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CharLeft(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CharLeft(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CharLeft();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CharLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CharLeftExtend, "CharLeftExtend()\n"
"\n"
"Move caret left one character extending selection to new caret\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CharLeftExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CharLeftExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CharLeftExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CharLeftExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CharRight, "CharRight()\n"
"\n"
"Move caret right one character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CharRight(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CharRight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CharRight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CharRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CharRightExtend, "CharRightExtend()\n"
"\n"
"Move caret right one character extending selection to new caret\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CharRightExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CharRightExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CharRightExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CharRightExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordLeft, "WordLeft()\n"
"\n"
"Move caret left one word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordLeft(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordLeft(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordLeft();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordLeftExtend, "WordLeftExtend()\n"
"\n"
"Move caret left one word extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordLeftExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordLeftExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordLeftExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordLeftExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordRight, "WordRight()\n"
"\n"
"Move caret right one word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordRight(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordRight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordRight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordRightExtend, "WordRightExtend()\n"
"\n"
"Move caret right one word extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordRightExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordRightExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordRightExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordRightExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Home, "Home()\n"
"\n"
"Move caret to first position on line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Home(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Home(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Home();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Home, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HomeExtend, "HomeExtend()\n"
"\n"
"Move caret to first position on line extending selection to new caret\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HomeExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HomeExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HomeExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HomeExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineEnd, "LineEnd()\n"
"\n"
"Move caret to last position on line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineEndExtend, "LineEndExtend()\n"
"\n"
"Move caret to last position on line extending selection to new caret\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineEndExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineEndExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineEndExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineEndExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DocumentStart, "DocumentStart()\n"
"\n"
"Move caret to first position in document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DocumentStart(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DocumentStart(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DocumentStart();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DocumentStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DocumentStartExtend, "DocumentStartExtend()\n"
"\n"
"Move caret to first position in document extending selection to new\n"
"caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DocumentStartExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DocumentStartExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DocumentStartExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DocumentStartExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DocumentEnd, "DocumentEnd()\n"
"\n"
"Move caret to last position in document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DocumentEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DocumentEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DocumentEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DocumentEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DocumentEndExtend, "DocumentEndExtend()\n"
"\n"
"Move caret to last position in document extending selection to new\n"
"caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DocumentEndExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DocumentEndExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DocumentEndExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DocumentEndExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PageUp, "PageUp()\n"
"\n"
"Move caret one page up.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PageUp(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PageUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PageUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PageUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PageUpExtend, "PageUpExtend()\n"
"\n"
"Move caret one page up extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PageUpExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PageUpExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PageUpExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PageUpExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PageDown, "PageDown()\n"
"\n"
"Move caret one page down.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PageDown(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PageDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PageDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PageDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PageDownExtend, "PageDownExtend()\n"
"\n"
"Move caret one page down extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PageDownExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PageDownExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PageDownExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PageDownExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_EditToggleOvertype, "EditToggleOvertype()\n"
"\n"
"Switch from insert to overtype mode or the reverse.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_EditToggleOvertype(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_EditToggleOvertype(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EditToggleOvertype();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_EditToggleOvertype, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Cancel, "Cancel()\n"
"\n"
"Cancel any modes such as call tip or auto-completion list display.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Cancel(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Cancel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Cancel();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Cancel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DeleteBack, "DeleteBack()\n"
"\n"
"Delete the selection or if no selection, the character before the\n"
"caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DeleteBack(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DeleteBack(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DeleteBack();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DeleteBack, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Tab, "Tab()\n"
"\n"
"If selection is empty or all on one line replace the selection with a\n"
"tab character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Tab(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Tab(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Tab();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Tab, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_BackTab, "BackTab()\n"
"\n"
"Dedent the selected lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_BackTab(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_BackTab(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->BackTab();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_BackTab, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_NewLine, "NewLine()\n"
"\n"
"Insert a new line, may use a CRLF, CR or LF depending on EOL mode.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_NewLine(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_NewLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->NewLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_NewLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FormFeed, "FormFeed()\n"
"\n"
"Insert a Form Feed character.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FormFeed(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FormFeed(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FormFeed();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FormFeed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VCHome, "VCHome()\n"
"\n"
"Move caret to before first visible character on line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VCHome(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VCHome(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->VCHome();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VCHome, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VCHomeExtend, "VCHomeExtend()\n"
"\n"
"Like VCHome but extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VCHomeExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VCHomeExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->VCHomeExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VCHomeExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DelWordLeft, "DelWordLeft()\n"
"\n"
"Delete the word to the left of the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DelWordLeft(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DelWordLeft(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DelWordLeft();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DelWordLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DelWordRight, "DelWordRight()\n"
"\n"
"Delete the word to the right of the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DelWordRight(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DelWordRight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DelWordRight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DelWordRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DelWordRightEnd, "DelWordRightEnd()\n"
"\n"
"Delete the word to the right of the caret, but not the trailing non-\n"
"word characters.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DelWordRightEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DelWordRightEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DelWordRightEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DelWordRightEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineCut, "LineCut()\n"
"\n"
"Cut the line containing the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineCut(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineCut(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineCut();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineCut, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineDelete, "LineDelete()\n"
"\n"
"Delete the line containing the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineDelete(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineDelete(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineDelete();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineDelete, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineTranspose, "LineTranspose()\n"
"\n"
"Switch the current line with the previous.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineTranspose(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineTranspose(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineTranspose();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineTranspose, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineDuplicate, "LineDuplicate()\n"
"\n"
"Duplicate the current line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineDuplicate(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineDuplicate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineDuplicate();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineDuplicate, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LowerCase, "LowerCase()\n"
"\n"
"Transform the selection to lower case.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LowerCase(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LowerCase(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LowerCase();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LowerCase, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_UpperCase, "UpperCase()\n"
"\n"
"Transform the selection to upper case.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_UpperCase(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_UpperCase(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->UpperCase();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_UpperCase, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineScrollDown, "LineScrollDown()\n"
"\n"
"Scroll the document down, keeping the caret visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineScrollDown(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineScrollDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineScrollDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineScrollDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineScrollUp, "LineScrollUp()\n"
"\n"
"Scroll the document up, keeping the caret visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineScrollUp(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineScrollUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineScrollUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineScrollUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DeleteBackNotLine, "DeleteBackNotLine()\n"
"\n"
"Delete the selection or if no selection, the character before the\n"
"caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DeleteBackNotLine(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DeleteBackNotLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DeleteBackNotLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DeleteBackNotLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HomeDisplay, "HomeDisplay()\n"
"\n"
"Move caret to first position on display line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HomeDisplay(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HomeDisplay(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HomeDisplay();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HomeDisplay, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HomeDisplayExtend, "HomeDisplayExtend()\n"
"\n"
"Move caret to first position on display line extending selection to\n"
"new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HomeDisplayExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HomeDisplayExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HomeDisplayExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HomeDisplayExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineEndDisplay, "LineEndDisplay()\n"
"\n"
"Move caret to last position on display line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineEndDisplay(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineEndDisplay(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineEndDisplay();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineEndDisplay, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineEndDisplayExtend, "LineEndDisplayExtend()\n"
"\n"
"Move caret to last position on display line extending selection to new\n"
"caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineEndDisplayExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineEndDisplayExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineEndDisplayExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineEndDisplayExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HomeWrap, "HomeWrap()\n"
"\n"
"Like Home but when word-wrap is enabled goes first to start of display\n"
"line HomeDisplay, then to start of document line Home.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HomeWrap(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HomeWrap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HomeWrap();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HomeWrap, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HomeWrapExtend, "HomeWrapExtend()\n"
"\n"
"Like HomeExtend but when word-wrap is enabled extends first to start\n"
"of display line HomeDisplayExtend, then to start of document line\n"
"HomeExtend.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HomeWrapExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HomeWrapExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HomeWrapExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HomeWrapExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineEndWrap, "LineEndWrap()\n"
"\n"
"Like LineEnd but when word-wrap is enabled goes first to end of\n"
"display line LineEndDisplay, then to start of document line LineEnd.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineEndWrap(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineEndWrap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineEndWrap();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineEndWrap, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineEndWrapExtend, "LineEndWrapExtend()\n"
"\n"
"Like LineEndExtend but when word-wrap is enabled extends first to end\n"
"of display line LineEndDisplayExtend, then to start of document line\n"
"LineEndExtend.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineEndWrapExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineEndWrapExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineEndWrapExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineEndWrapExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VCHomeWrap, "VCHomeWrap()\n"
"\n"
"Like VCHome but when word-wrap is enabled goes first to start of\n"
"display line VCHomeDisplay, then behaves like VCHome.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VCHomeWrap(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VCHomeWrap(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->VCHomeWrap();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VCHomeWrap, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VCHomeWrapExtend, "VCHomeWrapExtend()\n"
"\n"
"Like VCHomeExtend but when word-wrap is enabled extends first to start\n"
"of display line VCHomeDisplayExtend, then behaves like VCHomeExtend.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VCHomeWrapExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VCHomeWrapExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->VCHomeWrapExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VCHomeWrapExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineCopy, "LineCopy()\n"
"\n"
"Copy the line containing the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineCopy(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineCopy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineCopy();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineCopy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordPartLeft, "WordPartLeft()\n"
"\n"
"Move to the previous change in capitalisation.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordPartLeft(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordPartLeft(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordPartLeft();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordPartLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordPartLeftExtend, "WordPartLeftExtend()\n"
"\n"
"Move to the previous change in capitalisation extending selection to\n"
"new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordPartLeftExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordPartLeftExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordPartLeftExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordPartLeftExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordPartRight, "WordPartRight()\n"
"\n"
"Move to the change next in capitalisation.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordPartRight(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordPartRight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordPartRight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordPartRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordPartRightExtend, "WordPartRightExtend()\n"
"\n"
"Move to the next change in capitalisation extending selection to new\n"
"caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordPartRightExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordPartRightExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordPartRightExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordPartRightExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DelLineLeft, "DelLineLeft()\n"
"\n"
"Delete back from the current position to the start of the line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DelLineLeft(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DelLineLeft(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DelLineLeft();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DelLineLeft, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DelLineRight, "DelLineRight()\n"
"\n"
"Delete forwards from the current position to the end of the line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DelLineRight(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DelLineRight(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DelLineRight();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DelLineRight, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ParaDown, "ParaDown()\n"
"\n"
"Move caret down one paragraph (delimited by empty lines).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ParaDown(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ParaDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ParaDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ParaDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ParaDownExtend, "ParaDownExtend()\n"
"\n"
"Extend selection down one paragraph (delimited by empty lines).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ParaDownExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ParaDownExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ParaDownExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ParaDownExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ParaUp, "ParaUp()\n"
"\n"
"Move caret up one paragraph (delimited by empty lines).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ParaUp(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ParaUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ParaUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ParaUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ParaUpExtend, "ParaUpExtend()\n"
"\n"
"Extend selection up one paragraph (delimited by empty lines).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ParaUpExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ParaUpExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ParaUpExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ParaUpExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineDownRectExtend, "LineDownRectExtend()\n"
"\n"
"Move caret down one line, extending rectangular selection to new caret\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineDownRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineDownRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineDownRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineDownRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineUpRectExtend, "LineUpRectExtend()\n"
"\n"
"Move caret up one line, extending rectangular selection to new caret\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineUpRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineUpRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineUpRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineUpRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CharLeftRectExtend, "CharLeftRectExtend()\n"
"\n"
"Move caret left one character, extending rectangular selection to new\n"
"caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CharLeftRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CharLeftRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CharLeftRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CharLeftRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CharRightRectExtend, "CharRightRectExtend()\n"
"\n"
"Move caret right one character, extending rectangular selection to new\n"
"caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CharRightRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CharRightRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CharRightRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CharRightRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HomeRectExtend, "HomeRectExtend()\n"
"\n"
"Move caret to first position on line, extending rectangular selection\n"
"to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HomeRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HomeRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HomeRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HomeRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VCHomeRectExtend, "VCHomeRectExtend()\n"
"\n"
"Move caret to before first visible character on line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VCHomeRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VCHomeRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->VCHomeRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VCHomeRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LineEndRectExtend, "LineEndRectExtend()\n"
"\n"
"Move caret to last position on line, extending rectangular selection\n"
"to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LineEndRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LineEndRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LineEndRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LineEndRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PageUpRectExtend, "PageUpRectExtend()\n"
"\n"
"Move caret one page up, extending rectangular selection to new caret\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PageUpRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PageUpRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PageUpRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PageUpRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PageDownRectExtend, "PageDownRectExtend()\n"
"\n"
"Move caret one page down, extending rectangular selection to new caret\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PageDownRectExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PageDownRectExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->PageDownRectExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PageDownRectExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StutteredPageUp, "StutteredPageUp()\n"
"\n"
"Move caret to top of page, or one page up if already at top of page.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StutteredPageUp(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StutteredPageUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StutteredPageUp();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StutteredPageUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StutteredPageUpExtend, "StutteredPageUpExtend()\n"
"\n"
"Move caret to top of page, or one page up if already at top of page,\n"
"extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StutteredPageUpExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StutteredPageUpExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StutteredPageUpExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StutteredPageUpExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StutteredPageDown, "StutteredPageDown()\n"
"\n"
"Move caret to bottom of page, or one page down if already at bottom of\n"
"page.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StutteredPageDown(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StutteredPageDown(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StutteredPageDown();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StutteredPageDown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StutteredPageDownExtend, "StutteredPageDownExtend()\n"
"\n"
"Move caret to bottom of page, or one page down if already at bottom of\n"
"page, extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StutteredPageDownExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StutteredPageDownExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StutteredPageDownExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StutteredPageDownExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordLeftEnd, "WordLeftEnd()\n"
"\n"
"Move caret left one word, position cursor at end of word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordLeftEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordLeftEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordLeftEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordLeftEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordLeftEndExtend, "WordLeftEndExtend()\n"
"\n"
"Move caret left one word, position cursor at end of word, extending\n"
"selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordLeftEndExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordLeftEndExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordLeftEndExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordLeftEndExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordRightEnd, "WordRightEnd()\n"
"\n"
"Move caret right one word, position cursor at end of word.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordRightEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordRightEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordRightEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordRightEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WordRightEndExtend, "WordRightEndExtend()\n"
"\n"
"Move caret right one word, position cursor at end of word, extending\n"
"selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WordRightEndExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WordRightEndExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->WordRightEndExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WordRightEndExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SelectionDuplicate, "SelectionDuplicate()\n"
"\n"
"Duplicate the selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SelectionDuplicate(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SelectionDuplicate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SelectionDuplicate();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SelectionDuplicate, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VerticalCentreCaret, "VerticalCentreCaret()\n"
"\n"
"Centre current line in window.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VerticalCentreCaret(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VerticalCentreCaret(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->VerticalCentreCaret();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VerticalCentreCaret, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ScrollToStart, "ScrollToStart()\n"
"\n"
"Scroll to start of document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ScrollToStart(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ScrollToStart(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ScrollToStart();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ScrollToStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ScrollToEnd, "ScrollToEnd()\n"
"\n"
"Scroll to end of document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ScrollToEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ScrollToEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ScrollToEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ScrollToEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VCHomeDisplay, "VCHomeDisplay()\n"
"\n"
"Move caret to before first visible character on display line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VCHomeDisplay(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VCHomeDisplay(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->VCHomeDisplay();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VCHomeDisplay, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VCHomeDisplayExtend, "VCHomeDisplayExtend()\n"
"\n"
"Like VCHomeDisplay but extending selection to new caret position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VCHomeDisplayExtend(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VCHomeDisplayExtend(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->VCHomeDisplayExtend();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VCHomeDisplayExtend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CmdKeyAssign, "CmdKeyAssign(key, modifiers, cmd)\n"
"\n"
"When key+modifier combination keyDefinition is pressed perform\n"
"sciCommand.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CmdKeyAssign(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CmdKeyAssign(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int key;
        int modifiers;
        int cmd;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_key,
            sipName_modifiers,
            sipName_cmd,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &key, &modifiers, &cmd))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CmdKeyAssign(key,modifiers,cmd);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CmdKeyAssign, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CmdKeyClear, "CmdKeyClear(key, modifiers)\n"
"\n"
"When key+modifier combination keyDefinition is pressed do nothing.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CmdKeyClear(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CmdKeyClear(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int key;
        int modifiers;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_key,
            sipName_modifiers,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &key, &modifiers))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CmdKeyClear(key,modifiers);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CmdKeyClear, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CmdKeyClearAll, "CmdKeyClearAll()\n"
"\n"
"Drop all key mappings.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CmdKeyClearAll(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CmdKeyClearAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CmdKeyClearAll();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CmdKeyClearAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_UsePopUp, "UsePopUp(popUpMode)\n"
"\n"
"Set whether a pop up menu is displayed automatically when the user\n"
"presses the wrong mouse button on certain areas.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_UsePopUp(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_UsePopUp(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int popUpMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_popUpMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &popUpMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->UsePopUp(popUpMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_UsePopUp, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StartRecord, "StartRecord()\n"
"\n"
"Start notifying the container of all key presses and commands.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StartRecord(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StartRecord(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StartRecord();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StartRecord, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StopRecord, "StopRecord()\n"
"\n"
"Stop notifying the container of all key presses and commands.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StopRecord(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StopRecord(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StopRecord();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StopRecord, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetPrintMagnification, "SetPrintMagnification(magnification)\n"
"\n"
"Sets the print magnification added to the point size of each style for\n"
"printing.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetPrintMagnification(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetPrintMagnification(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int magnification;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_magnification,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &magnification))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPrintMagnification(magnification);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetPrintMagnification, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPrintMagnification, "GetPrintMagnification() -> int\n"
"\n"
"Returns the print magnification.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPrintMagnification(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPrintMagnification(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPrintMagnification();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPrintMagnification, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetPrintColourMode, "SetPrintColourMode(mode)\n"
"\n"
"Modify colours when printing for clearer printed text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetPrintColourMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetPrintColourMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int mode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_mode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &mode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPrintColourMode(mode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetPrintColourMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPrintColourMode, "GetPrintColourMode() -> int\n"
"\n"
"Returns the print colour mode.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPrintColourMode(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPrintColourMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPrintColourMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPrintColourMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FormatRange, "FormatRange(doDraw, startPos, endPos, draw, target, renderRect, pageRect) -> int\n"
"\n"
"On Windows, will draw the document into a display context such as a\n"
"printer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FormatRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FormatRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool doDraw;
        int startPos;
        int endPos;
         ::wxDC* draw;
         ::wxDC* target;
         ::wxRect* renderRect;
        int renderRectState = 0;
         ::wxRect* pageRect;
        int pageRectState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_doDraw,
            sipName_startPos,
            sipName_endPos,
            sipName_draw,
            sipName_target,
            sipName_renderRect,
            sipName_pageRect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BbiiJ8J8J1J1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &doDraw, &startPos, &endPos, sipType_wxDC, &draw, sipType_wxDC, &target, sipType_wxRect, &renderRect, &renderRectState, sipType_wxRect, &pageRect, &pageRectState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FormatRange(doDraw,startPos,endPos,draw,target,*renderRect,*pageRect);
            Py_END_ALLOW_THREADS
            sipReleaseType(renderRect, sipType_wxRect, renderRectState);
            sipReleaseType(pageRect, sipType_wxRect, pageRectState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FormatRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetPrintWrapMode, "SetPrintWrapMode(wrapMode)\n"
"\n"
"Set printing to line wrapped (wxSTC_WRAP_WORD) or not line wrapped\n"
"(wxSTC_WRAP_NONE).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetPrintWrapMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetPrintWrapMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int wrapMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_wrapMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &wrapMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPrintWrapMode(wrapMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetPrintWrapMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPrintWrapMode, "GetPrintWrapMode() -> int\n"
"\n"
"Is printing line wrapped?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPrintWrapMode(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPrintWrapMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPrintWrapMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPrintWrapMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetDirectFunction, "GetDirectFunction() -> void\n"
"\n"
"Retrieve a pointer to a function that processes messages for this\n"
"Scintilla.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetDirectFunction(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetDirectFunction(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            void*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDirectFunction();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromVoidPtr(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetDirectFunction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetDirectPointer, "GetDirectPointer() -> void\n"
"\n"
"Retrieve a pointer value to use as the first argument when calling the\n"
"function returned by GetDirectFunction.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetDirectPointer(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetDirectPointer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            void*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDirectPointer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromVoidPtr(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetDirectPointer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCharacterPointer, "GetCharacterPointer() -> PyObject\n"
"\n"
"Compact the document buffer and return a read-only memoryview\n"
"object of the characters in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCharacterPointer(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCharacterPointer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyObject * sipRes = SIP_NULLPTR;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxStyledTextCtrl_GetCharacterPointer(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCharacterPointer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetRangePointer, "GetRangePointer(position, rangeLength) -> PyObject\n"
"\n"
"Return a read-only pointer to a range of characters in the\n"
"document. May move the gap so that the range is contiguous,\n"
"but will only move up to rangeLength bytes.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetRangePointer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetRangePointer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int position;
        int rangeLength;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_rangeLength,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &position, &rangeLength))
        {
            PyObject * sipRes = SIP_NULLPTR;
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxStyledTextCtrl_GetRangePointer(sipCpp, position, rangeLength);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetRangePointer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetGapPosition, "GetGapPosition() -> int\n"
"\n"
"Return a position which, to avoid performance costs, should not be\n"
"within the range of a call to GetRangePointer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetGapPosition(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetGapPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetGapPosition();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetGapPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetDocPointer, "GetDocPointer() -> void\n"
"\n"
"Retrieve a pointer to the document object.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetDocPointer(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetDocPointer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            void*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDocPointer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromVoidPtr(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetDocPointer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetDocPointer, "SetDocPointer(docPointer)\n"
"\n"
"Change the document object used.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetDocPointer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetDocPointer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        void* docPointer;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_docPointer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bv", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &docPointer))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDocPointer(docPointer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetDocPointer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CreateDocument, "CreateDocument() -> void\n"
"\n"
"Create a new document object.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CreateDocument(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CreateDocument(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            void*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CreateDocument();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromVoidPtr(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CreateDocument, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AddRefDocument, "AddRefDocument(docPointer)\n"
"\n"
"Extend life of document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AddRefDocument(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AddRefDocument(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        void* docPointer;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_docPointer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bv", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &docPointer))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AddRefDocument(docPointer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AddRefDocument, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ReleaseDocument, "ReleaseDocument(docPointer)\n"
"\n"
"Release a reference to the document, deleting document if it fades to\n"
"black.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ReleaseDocument(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ReleaseDocument(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        void* docPointer;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_docPointer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bv", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &docPointer))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ReleaseDocument(docPointer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ReleaseDocument, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CreateLoader, "CreateLoader(bytes) -> void\n"
"\n"
"Create an ILoader*.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CreateLoader(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CreateLoader(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int bytes;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bytes,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &bytes))
        {
            void*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->CreateLoader(bytes);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromVoidPtr(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CreateLoader, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_VisibleFromDocLine, "VisibleFromDocLine(docLine) -> int\n"
"\n"
"Find the display line of a document line taking hidden lines into\n"
"account.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_VisibleFromDocLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_VisibleFromDocLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int docLine;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_docLine,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &docLine))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->VisibleFromDocLine(docLine);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_VisibleFromDocLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DocLineFromVisible, "DocLineFromVisible(displayLine) -> int\n"
"\n"
"Find the document line of a display line taking hidden lines into\n"
"account.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DocLineFromVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DocLineFromVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int displayLine;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_displayLine,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &displayLine))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DocLineFromVisible(displayLine);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DocLineFromVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetFoldLevel, "SetFoldLevel(line, level)\n"
"\n"
"Set the fold level of a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetFoldLevel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetFoldLevel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int level;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_level,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &level))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFoldLevel(line,level);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetFoldLevel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetFoldLevel, "GetFoldLevel(line) -> int\n"
"\n"
"Retrieve the fold level of a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetFoldLevel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetFoldLevel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFoldLevel(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetFoldLevel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLastChild, "GetLastChild(line, level) -> int\n"
"\n"
"Find the last child line of a header line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLastChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLastChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int level;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_level,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &level))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLastChild(line,level);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLastChild, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetFoldParent, "GetFoldParent(line) -> int\n"
"\n"
"Find the parent line of a child line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetFoldParent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetFoldParent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFoldParent(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetFoldParent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ShowLines, "ShowLines(lineStart, lineEnd)\n"
"\n"
"Make a range of lines visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ShowLines(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ShowLines(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lineStart;
        int lineEnd;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineStart,
            sipName_lineEnd,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lineStart, &lineEnd))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ShowLines(lineStart,lineEnd);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ShowLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HideLines, "HideLines(lineStart, lineEnd)\n"
"\n"
"Make a range of lines invisible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HideLines(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HideLines(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lineStart;
        int lineEnd;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineStart,
            sipName_lineEnd,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lineStart, &lineEnd))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->HideLines(lineStart,lineEnd);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HideLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineVisible, "GetLineVisible(line) -> bool\n"
"\n"
"Is a line visible?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLineVisible(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetAllLinesVisible, "GetAllLinesVisible() -> bool\n"
"\n"
"Are all lines visible?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetAllLinesVisible(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetAllLinesVisible(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAllLinesVisible();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetAllLinesVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetFoldExpanded, "SetFoldExpanded(line, expanded)\n"
"\n"
"Show the children of a header line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetFoldExpanded(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetFoldExpanded(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        bool expanded;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_expanded,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bib", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &expanded))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFoldExpanded(line,expanded);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetFoldExpanded, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetFoldExpanded, "GetFoldExpanded(line) -> bool\n"
"\n"
"Is a header line expanded?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetFoldExpanded(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetFoldExpanded(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFoldExpanded(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetFoldExpanded, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ToggleFold, "ToggleFold(line)\n"
"\n"
"Switch a header line between expanded and contracted.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ToggleFold(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ToggleFold(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ToggleFold(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ToggleFold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ToggleFoldShowText, "ToggleFoldShowText(line, text)\n"
"\n"
"Switch a header line between expanded and contracted and show some\n"
"text after the line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ToggleFoldShowText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ToggleFoldShowText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ToggleFoldShowText(line,*text);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ToggleFoldShowText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FoldDisplayTextSetStyle, "FoldDisplayTextSetStyle(style)\n"
"\n"
"Set the style of fold display text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FoldDisplayTextSetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FoldDisplayTextSetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FoldDisplayTextSetStyle(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FoldDisplayTextSetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FoldLine, "FoldLine(line, action)\n"
"\n"
"Expand or contract a fold header.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FoldLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FoldLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int action;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_action,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &action))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FoldLine(line,action);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FoldLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FoldChildren, "FoldChildren(line, action)\n"
"\n"
"Expand or contract a fold header and its children.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FoldChildren(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FoldChildren(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int action;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_action,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &action))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FoldChildren(line,action);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FoldChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ExpandChildren, "ExpandChildren(line, level)\n"
"\n"
"Expand a fold header and all children.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ExpandChildren(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ExpandChildren(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
        int level;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
            sipName_level,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line, &level))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ExpandChildren(line,level);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ExpandChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FoldAll, "FoldAll(action)\n"
"\n"
"Expand or contract all fold headers.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FoldAll(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FoldAll(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int action;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_action,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &action))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FoldAll(action);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FoldAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_EnsureVisible, "EnsureVisible(line)\n"
"\n"
"Ensure a particular line is visible by expanding any header line\n"
"hiding it.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_EnsureVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_EnsureVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnsureVisible(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_EnsureVisible, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetAutomaticFold, "SetAutomaticFold(automaticFold)\n"
"\n"
"Set automatic folding behaviours.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetAutomaticFold(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetAutomaticFold(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int automaticFold;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_automaticFold,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &automaticFold))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAutomaticFold(automaticFold);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetAutomaticFold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetAutomaticFold, "GetAutomaticFold() -> int\n"
"\n"
"Get automatic folding behaviours.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetAutomaticFold(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetAutomaticFold(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetAutomaticFold();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetAutomaticFold, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetFoldFlags, "SetFoldFlags(flags)\n"
"\n"
"Set some style options for folding.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetFoldFlags(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetFoldFlags(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int flags;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &flags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetFoldFlags(flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetFoldFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_EnsureVisibleEnforcePolicy, "EnsureVisibleEnforcePolicy(line)\n"
"\n"
"Ensure a particular line is visible by expanding any header line\n"
"hiding it.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_EnsureVisibleEnforcePolicy(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_EnsureVisibleEnforcePolicy(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnsureVisibleEnforcePolicy(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_EnsureVisibleEnforcePolicy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ContractedFoldNext, "ContractedFoldNext(lineStart) -> int\n"
"\n"
"Find the next line at or after lineStart that is a contracted fold\n"
"header line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ContractedFoldNext(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ContractedFoldNext(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lineStart;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineStart,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lineStart))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ContractedFoldNext(lineStart);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ContractedFoldNext, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WrapCount, "WrapCount(docLine) -> int\n"
"\n"
"The number of display lines needed to wrap a document line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WrapCount(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WrapCount(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int docLine;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_docLine,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &docLine))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->WrapCount(docLine);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WrapCount, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWrapMode, "SetWrapMode(wrapMode)\n"
"\n"
"Sets whether text is word wrapped.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWrapMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWrapMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int wrapMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_wrapMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &wrapMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWrapMode(wrapMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWrapMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetWrapMode, "GetWrapMode() -> int\n"
"\n"
"Retrieve whether text is word wrapped.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetWrapMode(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetWrapMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWrapMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetWrapMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWrapVisualFlags, "SetWrapVisualFlags(wrapVisualFlags)\n"
"\n"
"Set the display mode of visual flags for wrapped lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWrapVisualFlags(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWrapVisualFlags(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int wrapVisualFlags;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_wrapVisualFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &wrapVisualFlags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWrapVisualFlags(wrapVisualFlags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWrapVisualFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetWrapVisualFlags, "GetWrapVisualFlags() -> int\n"
"\n"
"Retrieve the display mode of visual flags for wrapped lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetWrapVisualFlags(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetWrapVisualFlags(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWrapVisualFlags();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetWrapVisualFlags, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWrapVisualFlagsLocation, "SetWrapVisualFlagsLocation(wrapVisualFlagsLocation)\n"
"\n"
"Set the location of visual flags for wrapped lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWrapVisualFlagsLocation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWrapVisualFlagsLocation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int wrapVisualFlagsLocation;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_wrapVisualFlagsLocation,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &wrapVisualFlagsLocation))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWrapVisualFlagsLocation(wrapVisualFlagsLocation);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWrapVisualFlagsLocation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetWrapVisualFlagsLocation, "GetWrapVisualFlagsLocation() -> int\n"
"\n"
"Retrieve the location of visual flags for wrapped lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetWrapVisualFlagsLocation(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetWrapVisualFlagsLocation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWrapVisualFlagsLocation();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetWrapVisualFlagsLocation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWrapStartIndent, "SetWrapStartIndent(indent)\n"
"\n"
"Set the start indent for wrapped lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWrapStartIndent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWrapStartIndent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int indent;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_indent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &indent))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWrapStartIndent(indent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWrapStartIndent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetWrapStartIndent, "GetWrapStartIndent() -> int\n"
"\n"
"Retrieve the start indent for wrapped lines.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetWrapStartIndent(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetWrapStartIndent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWrapStartIndent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetWrapStartIndent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetWrapIndentMode, "SetWrapIndentMode(wrapIndentMode)\n"
"\n"
"Sets how wrapped sublines are placed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetWrapIndentMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetWrapIndentMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int wrapIndentMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_wrapIndentMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &wrapIndentMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetWrapIndentMode(wrapIndentMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetWrapIndentMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetWrapIndentMode, "GetWrapIndentMode() -> int\n"
"\n"
"Retrieve how wrapped sublines are placed.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetWrapIndentMode(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetWrapIndentMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWrapIndentMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetWrapIndentMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLayoutCache, "GetLayoutCache() -> int\n"
"\n"
"Retrieve the degree of caching of layout information.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLayoutCache(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLayoutCache(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLayoutCache();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLayoutCache, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LinesJoin, "LinesJoin()\n"
"\n"
"Join the lines in the target.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LinesJoin(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LinesJoin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LinesJoin();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LinesJoin, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LinesSplit, "LinesSplit(pixelWidth)\n"
"\n"
"Split the lines in the target into lines that are less wide than\n"
"pixelWidth where possible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LinesSplit(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LinesSplit(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pixelWidth;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pixelWidth,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pixelWidth))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LinesSplit(pixelWidth);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LinesSplit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetPositionCacheSize, "SetPositionCacheSize(size)\n"
"\n"
"Set number of entries in position cache.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetPositionCacheSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetPositionCacheSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int size;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &size))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPositionCacheSize(size);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetPositionCacheSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPositionCacheSize, "GetPositionCacheSize() -> int\n"
"\n"
"How many entries are allocated to the position cache?");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPositionCacheSize(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPositionCacheSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPositionCacheSize();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPositionCacheSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ZoomIn, "ZoomIn()\n"
"\n"
"Magnify the displayed text by increasing the sizes by 1 point.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ZoomIn(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ZoomIn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ZoomIn();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ZoomIn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ZoomOut, "ZoomOut()\n"
"\n"
"Make the displayed text smaller by decreasing the sizes by 1 point.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ZoomOut(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ZoomOut(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ZoomOut();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ZoomOut, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetZoom, "SetZoom(zoomInPoints)\n"
"\n"
"Set the zoom level.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetZoom(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetZoom(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int zoomInPoints;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_zoomInPoints,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &zoomInPoints))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetZoom(zoomInPoints);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetZoom, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetZoom, "GetZoom() -> int\n"
"\n"
"Retrieve the zoom level.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetZoom(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetZoom(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetZoom();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetZoom, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetEdgeColumn, "GetEdgeColumn() -> int\n"
"\n"
"Retrieve the column number which text should be kept within.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetEdgeColumn(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetEdgeColumn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetEdgeColumn();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetEdgeColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetEdgeColumn, "SetEdgeColumn(column)\n"
"\n"
"Set the column number of the edge.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetEdgeColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetEdgeColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int column;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &column))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetEdgeColumn(column);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetEdgeColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetEdgeMode, "GetEdgeMode() -> int\n"
"\n"
"Retrieve the edge highlight mode.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetEdgeMode(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetEdgeMode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetEdgeMode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetEdgeMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetEdgeMode, "SetEdgeMode(edgeMode)\n"
"\n"
"The edge may be displayed by a line\n"
"(wxSTC_EDGE_LINE/wxSTC_EDGE_MULTILINE) or by highlighting text that\n"
"goes beyond it (wxSTC_EDGE_BACKGROUND) or not displayed at all\n"
"(wxSTC_EDGE_NONE).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetEdgeMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetEdgeMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int edgeMode;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_edgeMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &edgeMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetEdgeMode(edgeMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetEdgeMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetEdgeColour, "GetEdgeColour() -> Colour\n"
"\n"
"Retrieve the colour used in edge indication.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetEdgeColour(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetEdgeColour(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxColour*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxColour(sipCpp->GetEdgeColour());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxColour,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetEdgeColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetEdgeColour, "SetEdgeColour(edgeColour)\n"
"\n"
"Change the colour used in edge indication.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetEdgeColour(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetEdgeColour(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxColour* edgeColour;
        int edgeColourState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_edgeColour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxColour, &edgeColour, &edgeColourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetEdgeColour(*edgeColour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(edgeColour), sipType_wxColour, edgeColourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetEdgeColour, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MultiEdgeAddLine, "MultiEdgeAddLine(column, edgeColour)\n"
"\n"
"Add a new vertical edge to the view.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MultiEdgeAddLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MultiEdgeAddLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int column;
        const  ::wxColour* edgeColour;
        int edgeColourState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
            sipName_edgeColour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &column, sipType_wxColour, &edgeColour, &edgeColourState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MultiEdgeAddLine(column,*edgeColour);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(edgeColour), sipType_wxColour, edgeColourState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MultiEdgeAddLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MultiEdgeClearAll, "MultiEdgeClearAll()\n"
"\n"
"Clear all vertical edges.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MultiEdgeClearAll(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MultiEdgeClearAll(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MultiEdgeClearAll();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MultiEdgeClearAll, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ChangeLexerState, "ChangeLexerState(start, end) -> int\n"
"\n"
"Indicate that the internal state of a lexer has changed over a range\n"
"and therefore there may be a need to redraw.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ChangeLexerState(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ChangeLexerState(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int end;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &end))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ChangeLexerState(start,end);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ChangeLexerState, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetLexer, "SetLexer(lexer)\n"
"\n"
"Set the lexing language of the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetLexer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetLexer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int lexer;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lexer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lexer))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLexer(lexer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetLexer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLexer, "GetLexer() -> int\n"
"\n"
"Retrieve the lexing language of the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLexer(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLexer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLexer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLexer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Colourise, "Colourise(start, end)\n"
"\n"
"Colourise a segment of the document using the current lexing language.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Colourise(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Colourise(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int start;
        int end;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &end))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Colourise(start,end);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Colourise, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetProperty, "SetProperty(key, value)\n"
"\n"
"Set up a value that may be used by a lexer for some optional feature.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetProperty(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetProperty(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* key;
        int keyState = 0;
        const  ::wxString* value;
        int valueState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_key,
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &key, &keyState, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetProperty(*key,*value);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(key), sipType_wxString, keyState);
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetProperty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetKeyWords, "SetKeyWords(keyWordSet, keyWords)\n"
"\n"
"Set up the key words used by the lexer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetKeyWords(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetKeyWords(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int keyWordSet;
        const  ::wxString* keyWords;
        int keyWordsState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_keyWordSet,
            sipName_keyWords,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &keyWordSet, sipType_wxString, &keyWords, &keyWordsState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetKeyWords(keyWordSet,*keyWords);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(keyWords), sipType_wxString, keyWordsState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetKeyWords, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetLexerLanguage, "SetLexerLanguage(language)\n"
"\n"
"Set the lexing language of the document based on string name.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetLexerLanguage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetLexerLanguage(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* language;
        int languageState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_language,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &language, &languageState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLexerLanguage(*language);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(language), sipType_wxString, languageState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetLexerLanguage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LoadLexerLibrary, "LoadLexerLibrary(path)\n"
"\n"
"Load a lexer library (dll / so).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LoadLexerLibrary(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LoadLexerLibrary(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* path;
        int pathState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_path,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &path, &pathState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->LoadLexerLibrary(*path);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(path), sipType_wxString, pathState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LoadLexerLibrary, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetProperty, "GetProperty(key) -> String\n"
"\n"
"Retrieve a \"property\" value previously set with SetProperty.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetProperty(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetProperty(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* key;
        int keyState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_key,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &key, &keyState))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetProperty(*key));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(key), sipType_wxString, keyState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetProperty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPropertyExpanded, "GetPropertyExpanded(key) -> String\n"
"\n"
"Retrieve a \"property\" value previously set with SetProperty, with\n"
"\"$()\" variable replacement on returned buffer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPropertyExpanded(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPropertyExpanded(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* key;
        int keyState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_key,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &key, &keyState))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetPropertyExpanded(*key));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(key), sipType_wxString, keyState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPropertyExpanded, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPropertyInt, "GetPropertyInt(key, defaultValue=0) -> int\n"
"\n"
"Retrieve a \"property\" value previously set with SetProperty,\n"
"interpreted as an int AFTER any \"$()\" variable replacement.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPropertyInt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPropertyInt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* key;
        int keyState = 0;
        int defaultValue = 0;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_key,
            sipName_defaultValue,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|i", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &key, &keyState, &defaultValue))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPropertyInt(*key,defaultValue);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(key), sipType_wxString, keyState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPropertyInt, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLexerLanguage, "GetLexerLanguage() -> String\n"
"\n"
"Retrieve the lexing language of the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLexerLanguage(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLexerLanguage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLexerLanguage());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLexerLanguage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PrivateLexerCall, "PrivateLexerCall(operation, pointer) -> void\n"
"\n"
"For private communication between an application and a known lexer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PrivateLexerCall(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PrivateLexerCall(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int operation;
        void* pointer;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_operation,
            sipName_pointer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biv", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &operation, &pointer))
        {
            void*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrivateLexerCall(operation,pointer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromVoidPtr(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PrivateLexerCall, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PropertyNames, "PropertyNames() -> String\n"
"\n"
"Retrieve a '\\n' separated list of properties understood by the current\n"
"lexer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PropertyNames(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PropertyNames(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->PropertyNames());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PropertyNames, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PropertyType, "PropertyType(name) -> int\n"
"\n"
"Retrieve the type of a property.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PropertyType(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PropertyType(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &name, &nameState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PropertyType(*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PropertyType, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DescribeProperty, "DescribeProperty(name) -> String\n"
"\n"
"Describe a property.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DescribeProperty(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DescribeProperty(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &name, &nameState))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->DescribeProperty(*name));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DescribeProperty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DescribeKeyWordSets, "DescribeKeyWordSets() -> String\n"
"\n"
"Retrieve a '\\n' separated list of descriptions of the keyword sets\n"
"understood by the current lexer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DescribeKeyWordSets(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DescribeKeyWordSets(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->DescribeKeyWordSets());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DescribeKeyWordSets, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AllocateSubStyles, "AllocateSubStyles(styleBase, numberStyles) -> int\n"
"\n"
"Allocate a set of sub styles for a particular base style, returning\n"
"start of range.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AllocateSubStyles(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AllocateSubStyles(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int styleBase;
        int numberStyles;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleBase,
            sipName_numberStyles,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &styleBase, &numberStyles))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AllocateSubStyles(styleBase,numberStyles);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AllocateSubStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSubStylesStart, "GetSubStylesStart(styleBase) -> int\n"
"\n"
"The starting style number for the sub styles associated with a base\n"
"style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSubStylesStart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSubStylesStart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int styleBase;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleBase,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &styleBase))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSubStylesStart(styleBase);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSubStylesStart, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSubStylesLength, "GetSubStylesLength(styleBase) -> int\n"
"\n"
"The number of sub styles associated with a base style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSubStylesLength(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSubStylesLength(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int styleBase;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleBase,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &styleBase))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetSubStylesLength(styleBase);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSubStylesLength, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetStyleFromSubStyle, "GetStyleFromSubStyle(subStyle) -> int\n"
"\n"
"For a sub style, return the base style, else return the argument.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetStyleFromSubStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetStyleFromSubStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int subStyle;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_subStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &subStyle))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyleFromSubStyle(subStyle);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetStyleFromSubStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetPrimaryStyleFromStyle, "GetPrimaryStyleFromStyle(style) -> int\n"
"\n"
"For a secondary style, return the primary style, else return the\n"
"argument.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetPrimaryStyleFromStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetPrimaryStyleFromStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPrimaryStyleFromStyle(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetPrimaryStyleFromStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_FreeSubStyles, "FreeSubStyles()\n"
"\n"
"Free allocated sub styles.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_FreeSubStyles(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_FreeSubStyles(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FreeSubStyles();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_FreeSubStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetIdentifiers, "SetIdentifiers(style, identifiers)\n"
"\n"
"Set the identifiers that are shown in a particular style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetIdentifiers(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetIdentifiers(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
        const  ::wxString* identifiers;
        int identifiersState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_identifiers,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, sipType_wxString, &identifiers, &identifiersState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIdentifiers(style,*identifiers);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(identifiers), sipType_wxString, identifiersState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetIdentifiers, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DistanceToSecondaryStyles, "DistanceToSecondaryStyles() -> int\n"
"\n"
"Where styles are duplicated by a feature such as active/inactive code\n"
"return the distance between the two types.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DistanceToSecondaryStyles(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DistanceToSecondaryStyles(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DistanceToSecondaryStyles();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DistanceToSecondaryStyles, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSubStyleBases, "GetSubStyleBases() -> String\n"
"\n"
"Get the set of base styles that can be extended with sub styles.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSubStyleBases(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSubStyleBases(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetSubStyleBases());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSubStyleBases, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMouseDwellTime, "SetMouseDwellTime(periodMilliseconds)\n"
"\n"
"Sets the time the mouse must sit still to generate a mouse dwell\n"
"event.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMouseDwellTime(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMouseDwellTime(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int periodMilliseconds;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_periodMilliseconds,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &periodMilliseconds))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMouseDwellTime(periodMilliseconds);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMouseDwellTime, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMouseDwellTime, "GetMouseDwellTime() -> int\n"
"\n"
"Retrieve the time the mouse must sit still to generate a mouse dwell\n"
"event.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMouseDwellTime(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMouseDwellTime(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMouseDwellTime();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMouseDwellTime, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetModEventMask, "SetModEventMask(eventMask)\n"
"\n"
"Set which document modification events are sent to the container.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetModEventMask(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetModEventMask(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int eventMask;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eventMask,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &eventMask))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetModEventMask(eventMask);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetModEventMask, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetModEventMask, "GetModEventMask() -> int\n"
"\n"
"Get which document modification events are sent to the container.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetModEventMask(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetModEventMask(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetModEventMask();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetModEventMask, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetIdentifier, "SetIdentifier(identifier)\n"
"\n"
"Set the identifier reported as idFrom in notification messages.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetIdentifier(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetIdentifier(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int identifier;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_identifier,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &identifier))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIdentifier(identifier);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetIdentifier, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetIdentifier, "GetIdentifier() -> int\n"
"\n"
"Get the identifier.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetIdentifier(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetIdentifier(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIdentifier();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetIdentifier, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetStyleBits, "SetStyleBits(bits)\n"
"\n"
"Divide each styling byte into lexical class bits (default: 5) and\n"
"indicator bits (default: 3).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetStyleBits(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetStyleBits(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int bits;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bits,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &bits))
        {
            if (sipDeprecated(sipName_StyledTextCtrl,sipName_SetStyleBits) < 0)
                return SIP_NULLPTR;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetStyleBits(bits);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetStyleBits, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetStyleBits, "GetStyleBits() -> int\n"
"\n"
"Retrieve number of bits in style bytes used to hold the lexical state.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetStyleBits(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetStyleBits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            if (sipDeprecated(sipName_StyledTextCtrl,sipName_GetStyleBits) < 0)
                return SIP_NULLPTR;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyleBits();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetStyleBits, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetStyleBitsNeeded, "GetStyleBitsNeeded() -> int\n"
"\n"
"Retrieve the number of bits the current lexer needs for styling.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetStyleBitsNeeded(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetStyleBitsNeeded(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            if (sipDeprecated(sipName_StyledTextCtrl,sipName_GetStyleBitsNeeded) < 0)
                return SIP_NULLPTR;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyleBitsNeeded();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetStyleBitsNeeded, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCurrentLine, "GetCurrentLine() -> int\n"
"\n"
"Returns the line number of the line with the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCurrentLine(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCurrentLine(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCurrentLine();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCurrentLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetSpec, "StyleSetSpec(styleNum, spec)\n"
"\n"
"Extract style settings from a spec-string which is composed of one or\n"
"more of the following comma separated elements:");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetSpec(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetSpec(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int styleNum;
        const  ::wxString* spec;
        int specState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleNum,
            sipName_spec,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &styleNum, sipType_wxString, &spec, &specState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetSpec(styleNum,*spec);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(spec), sipType_wxString, specState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetSpec, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleGetFont, "StyleGetFont(style) -> Font\n"
"\n"
"Get the font of a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleGetFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleGetFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style))
        {
             ::wxFont*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxFont(sipCpp->StyleGetFont(style));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxFont,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleGetFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetFont, "StyleSetFont(styleNum, font)\n"
"\n"
"Set style size, face, bold, italic, and underline attributes from a\n"
"wxFont's attributes.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetFont(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetFont(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int styleNum;
         ::wxFont* font;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleNum,
            sipName_font,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &styleNum, sipType_wxFont, &font))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetFont(styleNum,*font);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetFont, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetFontAttr, "StyleSetFontAttr(styleNum, size, faceName, bold, italic, underline, encoding=FONTENCODING_DEFAULT)\n"
"\n"
"Set all font style attributes at once.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetFontAttr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetFontAttr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int styleNum;
        int size;
        const  ::wxString* faceName;
        int faceNameState = 0;
        bool bold;
        bool italic;
        bool underline;
         ::wxFontEncoding encoding = wxFONTENCODING_DEFAULT;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_styleNum,
            sipName_size,
            sipName_faceName,
            sipName_bold,
            sipName_italic,
            sipName_underline,
            sipName_encoding,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ1bbb|E", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &styleNum, &size, sipType_wxString, &faceName, &faceNameState, &bold, &italic, &underline, sipType_wxFontEncoding, &encoding))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetFontAttr(styleNum,size,*faceName,bold,italic,underline,encoding);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(faceName), sipType_wxString, faceNameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetFontAttr, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_StyleSetFontEncoding, "StyleSetFontEncoding(style, encoding)\n"
"\n"
"Set the font encoding to be used by a style.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_StyleSetFontEncoding(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_StyleSetFontEncoding(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int style;
         ::wxFontEncoding encoding;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
            sipName_encoding,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiE", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &style, sipType_wxFontEncoding, &encoding))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StyleSetFontEncoding(style,encoding);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_StyleSetFontEncoding, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CmdKeyExecute, "CmdKeyExecute(cmd)\n"
"\n"
"Perform one of the operations defined by the wxSTC_CMD_* constants.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CmdKeyExecute(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CmdKeyExecute(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int cmd;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cmd,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &cmd))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CmdKeyExecute(cmd);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CmdKeyExecute, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMargins, "SetMargins(left, right)\n"
"\n"
"Set the left and right margin in the edit area, measured in pixels.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMargins(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMargins(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int left;
        int right;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_left,
            sipName_right,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &left, &right))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMargins(left,right);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMargins, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ScrollToLine, "ScrollToLine(line)\n"
"\n"
"Scroll enough to make the given line visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ScrollToLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ScrollToLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ScrollToLine(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ScrollToLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ScrollToColumn, "ScrollToColumn(column)\n"
"\n"
"Scroll enough to make the given column visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ScrollToColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ScrollToColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int column;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &column))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ScrollToColumn(column);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ScrollToColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SendMsg, "SendMsg(msg, wp=0, lp=0) -> IntPtr\n"
"\n"
"Scintilla API call.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SendMsg(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SendMsg(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int msg;
         ::wxUIntPtr wpdef = 0;
         ::wxUIntPtr* wp = &wpdef;
        int wpState = 0;
         ::wxIntPtr lpdef = 0;
         ::wxIntPtr* lp = &lpdef;
        int lpState = 0;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_msg,
            sipName_wp,
            sipName_lp,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|J1J1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &msg, sipType_wxUIntPtr, &wp, &wpState, sipType_wxIntPtr, &lp, &lpState))
        {
             ::wxIntPtr*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxIntPtr(sipCpp->SendMsg(msg,*wp,*lp));
            Py_END_ALLOW_THREADS
            sipReleaseType(wp, sipType_wxUIntPtr, wpState);
            sipReleaseType(lp, sipType_wxIntPtr, lpState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxIntPtr,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SendMsg, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetVScrollBar, "SetVScrollBar(bar)\n"
"\n"
"Set the vertical scrollbar to use instead of the one that's built-in.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetVScrollBar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetVScrollBar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxScrollBar* bar;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bar,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxScrollBar, &bar))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetVScrollBar(bar);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetVScrollBar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetHScrollBar, "SetHScrollBar(bar)\n"
"\n"
"Set the horizontal scrollbar to use instead of the one that's built-\n"
"in.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetHScrollBar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetHScrollBar(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxScrollBar* bar;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_bar,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxScrollBar, &bar))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHScrollBar(bar);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetHScrollBar, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLastKeydownProcessed, "GetLastKeydownProcessed() -> bool\n"
"\n"
"Can be used to prevent the EVT_CHAR handler from adding the char.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLastKeydownProcessed(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLastKeydownProcessed(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLastKeydownProcessed();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLastKeydownProcessed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetLastKeydownProcessed, "SetLastKeydownProcessed(val)\n"
"\n"
"Returns the line number of the line with the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetLastKeydownProcessed(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetLastKeydownProcessed(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool val;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_val,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &val))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLastKeydownProcessed(val);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetLastKeydownProcessed, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SaveFile, "SaveFile(filename) -> bool\n"
"\n"
"Write the contents of the editor to filename.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SaveFile(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SaveFile(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* filename;
        int filenameState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_filename,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &filename, &filenameState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SaveFile(*filename);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(filename), sipType_wxString, filenameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SaveFile, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_LoadFile, "LoadFile(filename) -> bool\n"
"\n"
"Load the contents of filename into the editor.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_LoadFile(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_LoadFile(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* filename;
        int filenameState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_filename,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &filename, &filenameState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->LoadFile(*filename);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(filename), sipType_wxString, filenameState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_LoadFile, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoDragEnter, "DoDragEnter(x, y, defaultRes) -> DragResult\n"
"\n"
"Allow for simulating a DnD DragEnter.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoDragEnter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoDragEnter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxDragResult defaultRes;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_defaultRes,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiE", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y, sipType_wxDragResult, &defaultRes))
        {
             ::wxDragResult sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DoDragEnter(x,y,defaultRes);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxDragResult);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoDragEnter, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoDragOver, "DoDragOver(x, y, defaultRes) -> DragResult\n"
"\n"
"Allow for simulating a DnD DragOver.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoDragOver(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoDragOver(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxDragResult defaultRes;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_defaultRes,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiE", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y, sipType_wxDragResult, &defaultRes))
        {
             ::wxDragResult sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DoDragOver(x,y,defaultRes);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxDragResult);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoDragOver, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoDragLeave, "DoDragLeave()\n"
"\n"
"Allow for simulating a DnD DragLeave.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoDragLeave(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoDragLeave(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DoDragLeave();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoDragLeave, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DoDropText, "DoDropText(x, y, data) -> bool\n"
"\n"
"Allow for simulating a DnD DropText.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DoDropText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DoDropText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long x;
        long y;
        const  ::wxString* data;
        int dataState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_data,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BllJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y, sipType_wxString, &data, &dataState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->DoDropText(x,y,*data);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(data), sipType_wxString, dataState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DoDropText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetUseAntiAliasing, "SetUseAntiAliasing(useAA)\n"
"\n"
"Specify whether anti-aliased fonts should be used.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetUseAntiAliasing(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetUseAntiAliasing(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool useAA;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_useAA,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &useAA))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetUseAntiAliasing(useAA);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetUseAntiAliasing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetUseAntiAliasing, "GetUseAntiAliasing() -> bool\n"
"\n"
"Returns the current UseAntiAliasing setting.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetUseAntiAliasing(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetUseAntiAliasing(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetUseAntiAliasing();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetUseAntiAliasing, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AnnotationClearLine, "AnnotationClearLine(line)\n"
"\n"
"Clear annotations from the given line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AnnotationClearLine(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AnnotationClearLine(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AnnotationClearLine(line);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AnnotationClearLine, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkerDefineBitmap, "MarkerDefineBitmap(markerNumber, bmp)\n"
"\n"
"Define a marker with a wxBitmap.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkerDefineBitmap(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkerDefineBitmap(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int markerNumber;
        const  ::wxBitmap* bmp;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_markerNumber,
            sipName_bmp,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &markerNumber, sipType_wxBitmap, &bmp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->MarkerDefineBitmap(markerNumber,*bmp);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkerDefineBitmap, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AddTextRaw, "AddTextRaw(text, length=-1)\n"
"\n"
"Add text to the document at current position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AddTextRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AddTextRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const char* text;
        int length = -1;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
            sipName_length,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bs|i", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &text, &length))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AddTextRaw(text,length);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AddTextRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_InsertTextRaw, "InsertTextRaw(pos, text)\n"
"\n"
"Insert string at a position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_InsertTextRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_InsertTextRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int pos;
        const char* text;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bis", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos, &text))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->InsertTextRaw(pos,text);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_InsertTextRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetCurLineRaw, "GetCurLineRaw() -> (CharBuffer, linePos)\n"
"\n"
"Retrieve the text of the line containing the caret.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetCurLineRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetCurLineRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int linePos;
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxCharBuffer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCharBuffer(sipCpp->GetCurLineRaw(&linePos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            PyObject *sipResObj = sipConvertFromNewType(sipRes,sipType_wxCharBuffer,SIP_NULLPTR);
            return sipBuildResult(0,"(Ri)",sipResObj,linePos);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetCurLineRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineRaw, "GetLineRaw(line) -> CharBuffer\n"
"\n"
"Retrieve the contents of a line.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int line;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_line,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &line))
        {
             ::wxCharBuffer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCharBuffer(sipCpp->GetLineRaw(line));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxCharBuffer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelectedTextRaw, "GetSelectedTextRaw() -> CharBuffer\n"
"\n"
"Retrieve the selected text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelectedTextRaw(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelectedTextRaw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxCharBuffer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCharBuffer(sipCpp->GetSelectedTextRaw());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxCharBuffer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelectedTextRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTargetTextRaw, "GetTargetTextRaw() -> CharBuffer\n"
"\n"
"Retrieve the target text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTargetTextRaw(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTargetTextRaw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxCharBuffer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCharBuffer(sipCpp->GetTargetTextRaw());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxCharBuffer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTargetTextRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTextRangeRaw, "GetTextRangeRaw(startPos, endPos) -> CharBuffer\n"
"\n"
"Retrieve a range of text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTextRangeRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTextRangeRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int startPos;
        int endPos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_startPos,
            sipName_endPos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &startPos, &endPos))
        {
             ::wxCharBuffer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCharBuffer(sipCpp->GetTextRangeRaw(startPos,endPos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxCharBuffer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTextRangeRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetTextRaw, "SetTextRaw(text)\n"
"\n"
"Replace the contents of the document with the argument text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetTextRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetTextRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const char* text;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bs", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &text))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTextRaw(text);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetTextRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetTextRaw, "GetTextRaw() -> CharBuffer\n"
"\n"
"Retrieve all the text in the document.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetTextRaw(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetTextRaw(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxCharBuffer*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxCharBuffer(sipCpp->GetTextRaw());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxCharBuffer,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetTextRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AppendTextRaw, "AppendTextRaw(text, length=-1)\n"
"\n"
"Append a string to the end of the document without changing the\n"
"selection.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AppendTextRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AppendTextRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const char* text;
        int length = -1;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
            sipName_length,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bs|i", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &text, &length))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->AppendTextRaw(text,length);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AppendTextRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ReplaceSelectionRaw, "ReplaceSelectionRaw(text)\n"
"\n"
"Replace the current selection with text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ReplaceSelectionRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ReplaceSelectionRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const char* text;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bs", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &text))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ReplaceSelectionRaw(text);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ReplaceSelectionRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ReplaceTargetRaw, "ReplaceTargetRaw(text, length=-1) -> int\n"
"\n"
"Replace the current target with text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ReplaceTargetRaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ReplaceTargetRaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const char* text;
        int length = -1;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
            sipName_length,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bs|i", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &text, &length))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ReplaceTargetRaw(text,length);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ReplaceTargetRaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ReplaceTargetRERaw, "ReplaceTargetRERaw(text, length=-1) -> int\n"
"\n"
"Replace the current target with text using regular expressions.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ReplaceTargetRERaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ReplaceTargetRERaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const char* text;
        int length = -1;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
            sipName_length,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bs|i", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &text, &length))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ReplaceTargetRERaw(text,length);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ReplaceTargetRERaw, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_WriteText, "WriteText(text)\n"
"\n"
"Writes the text into the text control at the current insertion\n"
"position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_WriteText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_WriteText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::WriteText(*text) : sipCpp->WriteText(*text));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_WriteText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Remove, "Remove(from_, to_)\n"
"\n"
"Removes the text starting at the first given position up to (but not\n"
"including) the character at the last position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Remove(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Remove(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long from_;
        long to_;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bll", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &from_, &to_))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::Remove(from_,to_) : sipCpp->Remove(from_,to_));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Remove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_Replace, "Replace(from_, to_, value)\n"
"\n"
"Replaces the text starting at the first position up to (but not\n"
"including) the character at the last position with the given text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_Replace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_Replace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long from_;
        long to_;
        const  ::wxString* value;
        int valueState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BllJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &from_, &to_, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::Replace(from_,to_,*value) : sipCpp->Replace(from_,to_,*value));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_Replace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetInsertionPoint, "SetInsertionPoint(pos)\n"
"\n"
"Sets the insertion point at the given position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetInsertionPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetInsertionPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::SetInsertionPoint(pos) : sipCpp->SetInsertionPoint(pos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetInsertionPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetInsertionPoint, "GetInsertionPoint() -> long\n"
"\n"
"Returns the insertion point, or cursor, position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetInsertionPoint(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetInsertionPoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::GetInsertionPoint() : sipCpp->GetInsertionPoint());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetInsertionPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLastPosition, "GetLastPosition() -> long\n"
"\n"
"Returns the zero based index of the last position in the text control,\n"
"which is equal to the number of characters in the control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLastPosition(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLastPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::GetLastPosition() : sipCpp->GetLastPosition());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLastPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetSelection, "SetSelection(from_, to_)\n"
"\n"
"Selects the text starting at the first position up to (but not\n"
"including) the character at the last position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long from_;
        long to_;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bll", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &from_, &to_))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::SetSelection(from_,to_) : sipCpp->SetSelection(from_,to_));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SelectNone, "SelectNone()\n"
"\n"
"Deselects selected text in the control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SelectNone(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SelectNone(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::SelectNone() : sipCpp->SelectNone());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SelectNone, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetSelection, "GetSelection() -> (from_, to_)\n"
"\n"
"Gets the current selection span.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetSelection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetSelection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long from_;
        long to_;
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, SIP_NULLPTR, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::GetSelection(&from_,&to_) : sipCpp->GetSelection(&from_,&to_));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ll)",from_,to_);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IsEditable, "IsEditable() -> bool\n"
"\n"
"Returns true if the controls contents may be edited by user (note that\n"
"it always can be changed by the program).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IsEditable(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IsEditable(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::IsEditable() : sipCpp->IsEditable());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IsEditable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetEditable, "SetEditable(editable)\n"
"\n"
"Makes the text item editable or read-only, overriding the\n"
"wxTE_READONLY flag.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetEditable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetEditable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool editable;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_editable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &editable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::SetEditable(editable) : sipCpp->SetEditable(editable));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetEditable, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineLength, "GetLineLength(lineNo) -> int\n"
"\n"
"Gets the length of the specified line, not including any trailing\n"
"newline character(s).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineLength(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineLength(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long lineNo;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineNo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lineNo))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::GetLineLength(lineNo) : sipCpp->GetLineLength(lineNo));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineLength, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLineText, "GetLineText(lineNo) -> String\n"
"\n"
"Returns the contents of a given line in the text control, not\n"
"including any trailing newline character(s).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLineText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLineText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long lineNo;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lineNo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &lineNo))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString((sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::GetLineText(lineNo) : sipCpp->GetLineText(lineNo)));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLineText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetNumberOfLines, "GetNumberOfLines() -> int\n"
"\n"
"Returns the number of lines in the text control buffer.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetNumberOfLines(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetNumberOfLines(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::GetNumberOfLines() : sipCpp->GetNumberOfLines());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetNumberOfLines, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IsModified, "IsModified() -> bool\n"
"\n"
"Returns true if the text has been modified by user.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IsModified(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IsModified(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::IsModified() : sipCpp->IsModified());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IsModified, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_MarkDirty, "MarkDirty()\n"
"\n"
"Mark text as modified (dirty).");

extern "C" {static PyObject *meth_wxStyledTextCtrl_MarkDirty(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_MarkDirty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::MarkDirty() : sipCpp->MarkDirty());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_MarkDirty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_DiscardEdits, "DiscardEdits()\n"
"\n"
"Resets the internal modified flag as if the current changes had been\n"
"saved.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_DiscardEdits(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_DiscardEdits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::DiscardEdits() : sipCpp->DiscardEdits());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_DiscardEdits, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetStyle, "SetStyle(start, end, style) -> bool\n"
"\n"
"This method is inherited from wxTextAreaBase but is not implemented in\n"
"wxStyledTextCtrl.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long start;
        long end;
        const  ::wxTextAttr* style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_start,
            sipName_end,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BllJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &start, &end, sipType_wxTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::SetStyle(start,end,*style) : sipCpp->SetStyle(start,end,*style));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetStyle, "GetStyle(position, style) -> bool\n"
"\n"
"This method is inherited from wxTextAreaBase but is not implemented in\n"
"wxStyledTextCtrl.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long position;
         ::wxTextAttr* style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BlJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &position, sipType_wxTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::GetStyle(position,*style) : sipCpp->GetStyle(position,*style));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetDefaultStyle, "SetDefaultStyle(style) -> bool\n"
"\n"
"This method is inherited from wxTextAreaBase but is not implemented in\n"
"wxStyledTextCtrl.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetDefaultStyle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetDefaultStyle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxTextAttr* style;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxTextAttr, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::SetDefaultStyle(*style) : sipCpp->SetDefaultStyle(*style));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetDefaultStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_XYToPosition, "XYToPosition(x, y) -> long\n"
"\n"
"Converts the given zero based column and line number to a position.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_XYToPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_XYToPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long x;
        long y;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bll", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &x, &y))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::XYToPosition(x,y) : sipCpp->XYToPosition(x,y));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_XYToPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PositionToXY, "PositionToXY(pos) -> (bool, x, y)\n"
"\n"
"Converts given position to a zero-based column, line number pair.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PositionToXY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PositionToXY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long pos;
        long x;
        long y;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::PositionToXY(pos,&x,&y) : sipCpp->PositionToXY(pos,&x,&y));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(bll)",sipRes,x,y);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PositionToXY, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ShowPosition, "ShowPosition(pos)\n"
"\n"
"Makes the line containing the given position visible.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ShowPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ShowPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long pos;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::ShowPosition(pos) : sipCpp->ShowPosition(pos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ShowPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HitTestPos, "HitTestPos(pt) -> (TextCtrlHitTestResult, pos)\n"
"\n"
"Finds the position of the character at the specified point.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HitTestPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HitTestPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        long pos;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxTextCtrlHitTestResult sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::HitTest(*pt,&pos) : sipCpp->HitTest(*pt,&pos));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(Fl)",sipRes,sipType_wxTextCtrlHitTestResult,pos);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HitTestPos, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_HitTest, "HitTest(pt) -> (TextCtrlHitTestResult, col, row)\n"
"\n"
"Finds the row and column of the character at the specified point.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_HitTest(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_HitTest(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxPoint* pt;
        int ptState = 0;
         ::wxTextCoord col;
         ::wxTextCoord row;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxPoint, &pt, &ptState))
        {
             ::wxTextCtrlHitTestResult sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::HitTest(*pt,&col,&row) : sipCpp->HitTest(*pt,&col,&row));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt), sipType_wxPoint, ptState);

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(Fll)",sipRes,sipType_wxTextCtrlHitTestResult,col,row);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_HitTest, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetLibraryVersionInfo, "GetLibraryVersionInfo() -> VersionInfo\n"
"\n"
"Returns the version of the Scintilla library used by this control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetLibraryVersionInfo(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetLibraryVersionInfo(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxVersionInfo*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxVersionInfo( ::wxStyledTextCtrl::GetLibraryVersionInfo());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxVersionInfo,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetLibraryVersionInfo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetClassDefaultAttributes, "GetClassDefaultAttributes(variant=WINDOW_VARIANT_NORMAL) -> VisualAttributes");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetClassDefaultAttributes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetClassDefaultAttributes(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "|E", sipType_wxWindowVariant, &variant))
        {
             ::wxVisualAttributes*sipRes;
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxVisualAttributes( ::wxStyledTextCtrl::GetClassDefaultAttributes(variant));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxVisualAttributes,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetClassDefaultAttributes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoComplete, "AutoComplete(choices) -> bool\n"
"AutoComplete(completer) -> bool\n"
"\n"
"Call this function to enable auto-completion of the text typed in a\n"
"single-line text control using the given choices.\n"
"");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoComplete(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoComplete(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxArrayString* choices;
        int choicesState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_choices,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxArrayString, &choices, &choicesState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoComplete(*choices);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxArrayString *>(choices), sipType_wxArrayString, choicesState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxTextCompleter* completer;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_completer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxTextCompleter, &completer))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoComplete(completer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoComplete, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompleteFileNames, "AutoCompleteFileNames() -> bool\n"
"\n"
"Call this function to enable auto-completion of the text typed in a\n"
"single-line text control using all valid file system paths.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompleteFileNames(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompleteFileNames(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompleteFileNames();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompleteFileNames, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_AutoCompleteDirectories, "AutoCompleteDirectories() -> bool\n"
"\n"
"Call this function to enable auto-completion of the text using the\n"
"file system directories.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_AutoCompleteDirectories(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_AutoCompleteDirectories(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AutoCompleteDirectories();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_AutoCompleteDirectories, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CanCopy, "CanCopy() -> bool\n"
"\n"
"Returns true if the selection can be copied to the clipboard.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CanCopy(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CanCopy(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::CanCopy() : sipCpp->CanCopy());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CanCopy, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_CanCut, "CanCut() -> bool\n"
"\n"
"Returns true if the selection can be cut to the clipboard.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_CanCut(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_CanCut(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxStyledTextCtrl::CanCut() : sipCpp->CanCut());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_CanCut, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ChangeValue, "ChangeValue(value)\n"
"\n"
"Sets the new text control value.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ChangeValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ChangeValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* value;
        int valueState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ChangeValue(*value);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ChangeValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_ForceUpper, "ForceUpper()\n"
"\n"
"Convert all text entered into the control to upper case.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_ForceUpper(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_ForceUpper(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ForceUpper();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_ForceUpper, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetRange, "GetRange(from_, to_) -> String\n"
"\n"
"Returns the string containing the text starting in the positions from\n"
"and up to to in the control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetRange(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetRange(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long from_;
        long to_;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bll", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &from_, &to_))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetRange(from_,to_));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetRange, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetStringSelection, "GetStringSelection() -> String\n"
"\n"
"Gets the text currently selected in the control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetStringSelection(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetStringSelection(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetStringSelection());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetStringSelection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetValue, "GetValue() -> String\n"
"\n"
"Gets the contents of the control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetValue(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetValue());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_IsEmpty, "IsEmpty() -> bool\n"
"\n"
"Returns true if the control is currently empty.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_IsEmpty(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_IsEmpty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEmpty();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_IsEmpty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetInsertionPointEnd, "SetInsertionPointEnd()\n"
"\n"
"Sets the insertion point at the end of the text control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetInsertionPointEnd(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetInsertionPointEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetInsertionPointEnd();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetInsertionPointEnd, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetMaxLength, "SetMaxLength(len)\n"
"\n"
"This function sets the maximum number of characters the user can enter\n"
"into the control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetMaxLength(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetMaxLength(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        unsigned long len;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_len,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bm", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &len))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMaxLength(len);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetMaxLength, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetHint, "SetHint(hint) -> bool\n"
"\n"
"Sets a hint shown in an empty unfocused text control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetHint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetHint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* hint;
        int hintState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_hint,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &hint, &hintState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetHint(*hint);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(hint), sipType_wxString, hintState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetHint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetHint, "GetHint() -> String\n"
"\n"
"Returns the current hint string.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetHint(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetHint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetHint());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetHint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetMargins, "GetMargins() -> Point\n"
"\n"
"Returns the margins used by the control.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetMargins(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetMargins(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetMargins());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetMargins, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetValue, "SetValue(value)\n"
"\n"
"Sets the new text control value.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* value;
        int valueState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &value, &valueState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetValue(*value);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(value), sipType_wxString, valueState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetValue, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_GetDefaultStyle, "GetDefaultStyle() -> TextAttr\n"
"\n"
"Returns the style currently used for the new text.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_GetDefaultStyle(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_GetDefaultStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
             ::wxTextAttr*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxTextAttr(sipCpp->GetDefaultStyle());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxTextAttr,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_GetDefaultStyle, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_PositionToCoords, "PositionToCoords(pos) -> Point\n"
"\n"
"Converts given text position to client coordinates in pixels.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_PositionToCoords(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_PositionToCoords(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long pos;
        const  ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &pos))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->PositionToCoords(pos));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_PositionToCoords, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_SetModified, "SetModified(modified)\n"
"\n"
"Marks the control as being modified by the user or not.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_SetModified(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_SetModified(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool modified;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_modified,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, &modified))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetModified(modified);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_SetModified, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_write, "write(text)\n"
"\n"
"Append text to the textctrl, for file-like compatibility.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_write(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_write(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* text;
        int textState = 0;
         ::wxStyledTextCtrl *sipCpp;

        static const char *sipKwdList[] = {
            sipName_text,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ0", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp, sipType_wxString, &text, &textState))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxStyledTextCtrl_write(sipCpp, text);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxString *>(text), sipType_wxString, textState);

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_write, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxStyledTextCtrl_flush, "flush()\n"
"\n"
"NOP, for file-like compatibility.");

extern "C" {static PyObject *meth_wxStyledTextCtrl_flush(PyObject *, PyObject *);}
static PyObject *meth_wxStyledTextCtrl_flush(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxStyledTextCtrl *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxStyledTextCtrl, &sipCpp))
        {
            int sipIsErr = 0;
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxStyledTextCtrl_flush(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_StyledTextCtrl, sipName_flush, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxStyledTextCtrl(void *, const sipTypeDef *);}
static void *cast_wxStyledTextCtrl(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxStyledTextCtrl *sipCpp = reinterpret_cast< ::wxStyledTextCtrl *>(sipCppV);

    if (targetType == sipType_wxStyledTextCtrl)
        return sipCppV;

    sipCppV = ((const sipClassTypeDef *)sipType_wxControl)->ctd_cast(static_cast< ::wxControl *>(sipCpp), targetType);
    if (sipCppV)
        return sipCppV;

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxStyledTextCtrl(void *, int);}
static void release_wxStyledTextCtrl(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxStyledTextCtrl *>(sipCppV);
    else
        delete reinterpret_cast< ::wxStyledTextCtrl *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void *array_wxStyledTextCtrl(Py_ssize_t);}
static void *array_wxStyledTextCtrl(Py_ssize_t sipNrElem)
{
    return new  ::wxStyledTextCtrl[sipNrElem];
}


extern "C" {static void dealloc_wxStyledTextCtrl(sipSimpleWrapper *);}
static void dealloc_wxStyledTextCtrl(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxStyledTextCtrl *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxStyledTextCtrl(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxStyledTextCtrl(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxStyledTextCtrl(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipwxStyledTextCtrl *sipCpp = SIP_NULLPTR;

    {
         ::wxWindow* parent;
         ::wxWindowID id = wxID_ANY;
        const  ::wxPoint& posdef = wxDefaultPosition;
        const  ::wxPoint* pos = &posdef;
        int posState = 0;
        const  ::wxSize& sizedef = wxDefaultSize;
        const  ::wxSize* size = &sizedef;
        int sizeState = 0;
        long style = 0;
        const  ::wxString& namedef = wxSTCNameStr;
        const  ::wxString* name = &namedef;
        int nameState = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
            sipName_id,
            sipName_pos,
            sipName_size,
            sipName_style,
            sipName_name,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "JH|iJ1J1lJ1", sipType_wxWindow, &parent, sipOwner, &id, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState, &style, sipType_wxString, &name, &nameState))
        {
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxStyledTextCtrl(parent,id,*pos,*size,style,*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos), sipType_wxPoint, posState);
            sipReleaseType(const_cast< ::wxSize *>(size), sipType_wxSize, sizeState);
            sipReleaseType(const_cast< ::wxString *>(name), sipType_wxString, nameState);

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxStyledTextCtrl();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxStyledTextCtrl[] = {{6, 0, 1}};


static PyMethodDef methods_wxStyledTextCtrl[] = {
    {sipName_AddRefDocument, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AddRefDocument), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AddRefDocument},
    {sipName_AddSelection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AddSelection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AddSelection},
    {sipName_AddStyledText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AddStyledText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AddStyledText},
    {sipName_AddTabStop, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AddTabStop), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AddTabStop},
    {sipName_AddText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AddText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AddText},
    {sipName_AddTextRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AddTextRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AddTextRaw},
    {sipName_AddUndoAction, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AddUndoAction), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AddUndoAction},
    {sipName_Allocate, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_Allocate), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_Allocate},
    {sipName_AllocateExtendedStyles, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AllocateExtendedStyles), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AllocateExtendedStyles},
    {sipName_AllocateSubStyles, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AllocateSubStyles), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AllocateSubStyles},
    {sipName_AnnotationClearAll, meth_wxStyledTextCtrl_AnnotationClearAll, METH_VARARGS, doc_wxStyledTextCtrl_AnnotationClearAll},
    {sipName_AnnotationClearLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationClearLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationClearLine},
    {sipName_AnnotationGetLines, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationGetLines), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationGetLines},
    {sipName_AnnotationGetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationGetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationGetStyle},
    {sipName_AnnotationGetStyleOffset, meth_wxStyledTextCtrl_AnnotationGetStyleOffset, METH_VARARGS, doc_wxStyledTextCtrl_AnnotationGetStyleOffset},
    {sipName_AnnotationGetStyles, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationGetStyles), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationGetStyles},
    {sipName_AnnotationGetText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationGetText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationGetText},
    {sipName_AnnotationGetVisible, meth_wxStyledTextCtrl_AnnotationGetVisible, METH_VARARGS, doc_wxStyledTextCtrl_AnnotationGetVisible},
    {sipName_AnnotationSetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationSetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationSetStyle},
    {sipName_AnnotationSetStyleOffset, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationSetStyleOffset), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationSetStyleOffset},
    {sipName_AnnotationSetStyles, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationSetStyles), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationSetStyles},
    {sipName_AnnotationSetText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationSetText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationSetText},
    {sipName_AnnotationSetVisible, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AnnotationSetVisible), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AnnotationSetVisible},
    {sipName_AppendText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AppendText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AppendText},
    {sipName_AppendTextRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AppendTextRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AppendTextRaw},
    {sipName_AutoCompActive, meth_wxStyledTextCtrl_AutoCompActive, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompActive},
    {sipName_AutoCompCancel, meth_wxStyledTextCtrl_AutoCompCancel, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompCancel},
    {sipName_AutoCompComplete, meth_wxStyledTextCtrl_AutoCompComplete, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompComplete},
    {sipName_AutoCompGetAutoHide, meth_wxStyledTextCtrl_AutoCompGetAutoHide, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetAutoHide},
    {sipName_AutoCompGetCancelAtStart, meth_wxStyledTextCtrl_AutoCompGetCancelAtStart, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetCancelAtStart},
    {sipName_AutoCompGetCaseInsensitiveBehaviour, meth_wxStyledTextCtrl_AutoCompGetCaseInsensitiveBehaviour, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetCaseInsensitiveBehaviour},
    {sipName_AutoCompGetChooseSingle, meth_wxStyledTextCtrl_AutoCompGetChooseSingle, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetChooseSingle},
    {sipName_AutoCompGetCurrent, meth_wxStyledTextCtrl_AutoCompGetCurrent, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetCurrent},
    {sipName_AutoCompGetCurrentText, meth_wxStyledTextCtrl_AutoCompGetCurrentText, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetCurrentText},
    {sipName_AutoCompGetDropRestOfWord, meth_wxStyledTextCtrl_AutoCompGetDropRestOfWord, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetDropRestOfWord},
    {sipName_AutoCompGetIgnoreCase, meth_wxStyledTextCtrl_AutoCompGetIgnoreCase, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetIgnoreCase},
    {sipName_AutoCompGetMaxHeight, meth_wxStyledTextCtrl_AutoCompGetMaxHeight, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetMaxHeight},
    {sipName_AutoCompGetMaxWidth, meth_wxStyledTextCtrl_AutoCompGetMaxWidth, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetMaxWidth},
    {sipName_AutoCompGetMulti, meth_wxStyledTextCtrl_AutoCompGetMulti, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetMulti},
    {sipName_AutoCompGetOrder, meth_wxStyledTextCtrl_AutoCompGetOrder, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetOrder},
    {sipName_AutoCompGetSeparator, meth_wxStyledTextCtrl_AutoCompGetSeparator, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetSeparator},
    {sipName_AutoCompGetTypeSeparator, meth_wxStyledTextCtrl_AutoCompGetTypeSeparator, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompGetTypeSeparator},
    {sipName_AutoCompPosStart, meth_wxStyledTextCtrl_AutoCompPosStart, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompPosStart},
    {sipName_AutoCompSelect, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSelect), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSelect},
    {sipName_AutoCompSetAutoHide, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetAutoHide), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetAutoHide},
    {sipName_AutoCompSetCancelAtStart, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetCancelAtStart), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetCancelAtStart},
    {sipName_AutoCompSetCaseInsensitiveBehaviour, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetCaseInsensitiveBehaviour), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetCaseInsensitiveBehaviour},
    {sipName_AutoCompSetChooseSingle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetChooseSingle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetChooseSingle},
    {sipName_AutoCompSetDropRestOfWord, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetDropRestOfWord), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetDropRestOfWord},
    {sipName_AutoCompSetFillUps, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetFillUps), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetFillUps},
    {sipName_AutoCompSetIgnoreCase, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetIgnoreCase), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetIgnoreCase},
    {sipName_AutoCompSetMaxHeight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetMaxHeight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetMaxHeight},
    {sipName_AutoCompSetMaxWidth, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetMaxWidth), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetMaxWidth},
    {sipName_AutoCompSetMulti, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetMulti), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetMulti},
    {sipName_AutoCompSetOrder, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetOrder), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetOrder},
    {sipName_AutoCompSetSeparator, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetSeparator), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetSeparator},
    {sipName_AutoCompSetTypeSeparator, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompSetTypeSeparator), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompSetTypeSeparator},
    {sipName_AutoCompShow, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompShow), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompShow},
    {sipName_AutoCompStops, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoCompStops), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoCompStops},
    {sipName_AutoComplete, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_AutoComplete), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_AutoComplete},
    {sipName_AutoCompleteDirectories, meth_wxStyledTextCtrl_AutoCompleteDirectories, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompleteDirectories},
    {sipName_AutoCompleteFileNames, meth_wxStyledTextCtrl_AutoCompleteFileNames, METH_VARARGS, doc_wxStyledTextCtrl_AutoCompleteFileNames},
    {sipName_BackTab, meth_wxStyledTextCtrl_BackTab, METH_VARARGS, doc_wxStyledTextCtrl_BackTab},
    {sipName_BeginUndoAction, meth_wxStyledTextCtrl_BeginUndoAction, METH_VARARGS, doc_wxStyledTextCtrl_BeginUndoAction},
    {sipName_BraceBadLight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_BraceBadLight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_BraceBadLight},
    {sipName_BraceBadLightIndicator, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_BraceBadLightIndicator), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_BraceBadLightIndicator},
    {sipName_BraceHighlight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_BraceHighlight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_BraceHighlight},
    {sipName_BraceHighlightIndicator, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_BraceHighlightIndicator), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_BraceHighlightIndicator},
    {sipName_BraceMatch, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_BraceMatch), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_BraceMatch},
    {sipName_CallTipActive, meth_wxStyledTextCtrl_CallTipActive, METH_VARARGS, doc_wxStyledTextCtrl_CallTipActive},
    {sipName_CallTipCancel, meth_wxStyledTextCtrl_CallTipCancel, METH_VARARGS, doc_wxStyledTextCtrl_CallTipCancel},
    {sipName_CallTipPosAtStart, meth_wxStyledTextCtrl_CallTipPosAtStart, METH_VARARGS, doc_wxStyledTextCtrl_CallTipPosAtStart},
    {sipName_CallTipSetBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CallTipSetBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CallTipSetBackground},
    {sipName_CallTipSetForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CallTipSetForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CallTipSetForeground},
    {sipName_CallTipSetForegroundHighlight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CallTipSetForegroundHighlight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CallTipSetForegroundHighlight},
    {sipName_CallTipSetHighlight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CallTipSetHighlight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CallTipSetHighlight},
    {sipName_CallTipSetPosAtStart, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CallTipSetPosAtStart), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CallTipSetPosAtStart},
    {sipName_CallTipSetPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CallTipSetPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CallTipSetPosition},
    {sipName_CallTipShow, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CallTipShow), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CallTipShow},
    {sipName_CallTipUseStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CallTipUseStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CallTipUseStyle},
    {sipName_CanCopy, meth_wxStyledTextCtrl_CanCopy, METH_VARARGS, doc_wxStyledTextCtrl_CanCopy},
    {sipName_CanCut, meth_wxStyledTextCtrl_CanCut, METH_VARARGS, doc_wxStyledTextCtrl_CanCut},
    {sipName_CanPaste, meth_wxStyledTextCtrl_CanPaste, METH_VARARGS, doc_wxStyledTextCtrl_CanPaste},
    {sipName_CanRedo, meth_wxStyledTextCtrl_CanRedo, METH_VARARGS, doc_wxStyledTextCtrl_CanRedo},
    {sipName_CanUndo, meth_wxStyledTextCtrl_CanUndo, METH_VARARGS, doc_wxStyledTextCtrl_CanUndo},
    {sipName_Cancel, meth_wxStyledTextCtrl_Cancel, METH_VARARGS, doc_wxStyledTextCtrl_Cancel},
    {sipName_ChangeInsertion, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ChangeInsertion), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ChangeInsertion},
    {sipName_ChangeLexerState, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ChangeLexerState), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ChangeLexerState},
    {sipName_ChangeValue, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ChangeValue), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ChangeValue},
    {sipName_CharLeft, meth_wxStyledTextCtrl_CharLeft, METH_VARARGS, doc_wxStyledTextCtrl_CharLeft},
    {sipName_CharLeftExtend, meth_wxStyledTextCtrl_CharLeftExtend, METH_VARARGS, doc_wxStyledTextCtrl_CharLeftExtend},
    {sipName_CharLeftRectExtend, meth_wxStyledTextCtrl_CharLeftRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_CharLeftRectExtend},
    {sipName_CharPositionFromPoint, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CharPositionFromPoint), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CharPositionFromPoint},
    {sipName_CharPositionFromPointClose, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CharPositionFromPointClose), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CharPositionFromPointClose},
    {sipName_CharRight, meth_wxStyledTextCtrl_CharRight, METH_VARARGS, doc_wxStyledTextCtrl_CharRight},
    {sipName_CharRightExtend, meth_wxStyledTextCtrl_CharRightExtend, METH_VARARGS, doc_wxStyledTextCtrl_CharRightExtend},
    {sipName_CharRightRectExtend, meth_wxStyledTextCtrl_CharRightRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_CharRightRectExtend},
    {sipName_ChooseCaretX, meth_wxStyledTextCtrl_ChooseCaretX, METH_VARARGS, doc_wxStyledTextCtrl_ChooseCaretX},
    {sipName_Clear, meth_wxStyledTextCtrl_Clear, METH_VARARGS, doc_wxStyledTextCtrl_Clear},
    {sipName_ClearAll, meth_wxStyledTextCtrl_ClearAll, METH_VARARGS, doc_wxStyledTextCtrl_ClearAll},
    {sipName_ClearDocumentStyle, meth_wxStyledTextCtrl_ClearDocumentStyle, METH_VARARGS, doc_wxStyledTextCtrl_ClearDocumentStyle},
    {sipName_ClearRegisteredImages, meth_wxStyledTextCtrl_ClearRegisteredImages, METH_VARARGS, doc_wxStyledTextCtrl_ClearRegisteredImages},
    {sipName_ClearRepresentation, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ClearRepresentation), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ClearRepresentation},
    {sipName_ClearSelections, meth_wxStyledTextCtrl_ClearSelections, METH_VARARGS, doc_wxStyledTextCtrl_ClearSelections},
    {sipName_ClearTabStops, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ClearTabStops), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ClearTabStops},
    {sipName_CmdKeyAssign, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CmdKeyAssign), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CmdKeyAssign},
    {sipName_CmdKeyClear, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CmdKeyClear), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CmdKeyClear},
    {sipName_CmdKeyClearAll, meth_wxStyledTextCtrl_CmdKeyClearAll, METH_VARARGS, doc_wxStyledTextCtrl_CmdKeyClearAll},
    {sipName_CmdKeyExecute, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CmdKeyExecute), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CmdKeyExecute},
    {sipName_Colourise, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_Colourise), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_Colourise},
    {sipName_ContractedFoldNext, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ContractedFoldNext), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ContractedFoldNext},
    {sipName_ConvertEOLs, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ConvertEOLs), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ConvertEOLs},
    {sipName_Copy, meth_wxStyledTextCtrl_Copy, METH_VARARGS, doc_wxStyledTextCtrl_Copy},
    {sipName_CopyAllowLine, meth_wxStyledTextCtrl_CopyAllowLine, METH_VARARGS, doc_wxStyledTextCtrl_CopyAllowLine},
    {sipName_CopyRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CopyRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CopyRange},
    {sipName_CopyText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CopyText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CopyText},
    {sipName_CountCharacters, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CountCharacters), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CountCharacters},
    {sipName_Create, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_Create), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_Create},
    {sipName_CreateDocument, meth_wxStyledTextCtrl_CreateDocument, METH_VARARGS, doc_wxStyledTextCtrl_CreateDocument},
    {sipName_CreateLoader, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_CreateLoader), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_CreateLoader},
    {sipName_Cut, meth_wxStyledTextCtrl_Cut, METH_VARARGS, doc_wxStyledTextCtrl_Cut},
    {sipName_DelLineLeft, meth_wxStyledTextCtrl_DelLineLeft, METH_VARARGS, doc_wxStyledTextCtrl_DelLineLeft},
    {sipName_DelLineRight, meth_wxStyledTextCtrl_DelLineRight, METH_VARARGS, doc_wxStyledTextCtrl_DelLineRight},
    {sipName_DelWordLeft, meth_wxStyledTextCtrl_DelWordLeft, METH_VARARGS, doc_wxStyledTextCtrl_DelWordLeft},
    {sipName_DelWordRight, meth_wxStyledTextCtrl_DelWordRight, METH_VARARGS, doc_wxStyledTextCtrl_DelWordRight},
    {sipName_DelWordRightEnd, meth_wxStyledTextCtrl_DelWordRightEnd, METH_VARARGS, doc_wxStyledTextCtrl_DelWordRightEnd},
    {sipName_DeleteBack, meth_wxStyledTextCtrl_DeleteBack, METH_VARARGS, doc_wxStyledTextCtrl_DeleteBack},
    {sipName_DeleteBackNotLine, meth_wxStyledTextCtrl_DeleteBackNotLine, METH_VARARGS, doc_wxStyledTextCtrl_DeleteBackNotLine},
    {sipName_DeleteRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DeleteRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_DeleteRange},
    {sipName_DescribeKeyWordSets, meth_wxStyledTextCtrl_DescribeKeyWordSets, METH_VARARGS, doc_wxStyledTextCtrl_DescribeKeyWordSets},
    {sipName_DescribeProperty, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DescribeProperty), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_DescribeProperty},
    {sipName_DiscardEdits, meth_wxStyledTextCtrl_DiscardEdits, METH_VARARGS, doc_wxStyledTextCtrl_DiscardEdits},
    {sipName_DistanceToSecondaryStyles, meth_wxStyledTextCtrl_DistanceToSecondaryStyles, METH_VARARGS, doc_wxStyledTextCtrl_DistanceToSecondaryStyles},
    {sipName_DoDragEnter, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoDragEnter), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_DoDragEnter},
    {sipName_DoDragLeave, meth_wxStyledTextCtrl_DoDragLeave, METH_VARARGS, doc_wxStyledTextCtrl_DoDragLeave},
    {sipName_DoDragOver, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoDragOver), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_DoDragOver},
    {sipName_DoDropText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoDropText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_DoDropText},
    {sipName_DoEnable, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoEnable), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoFreeze, meth_wxStyledTextCtrl_DoFreeze, METH_VARARGS, SIP_NULLPTR},
    {sipName_DoGetBestClientSize, meth_wxStyledTextCtrl_DoGetBestClientSize, METH_VARARGS, SIP_NULLPTR},
    {sipName_DoGetBestSize, meth_wxStyledTextCtrl_DoGetBestSize, METH_VARARGS, SIP_NULLPTR},
    {sipName_DoGetClientSize, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoGetClientSize), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoGetPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoGetPosition), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoGetSize, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoGetSize), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoMoveWindow, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoMoveWindow), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoSetClientSize, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoSetClientSize), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoSetSize, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoSetSize), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoSetSizeHints, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoSetSizeHints), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoSetWindowVariant, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DoSetWindowVariant), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_DoThaw, meth_wxStyledTextCtrl_DoThaw, METH_VARARGS, SIP_NULLPTR},
    {sipName_DocLineFromVisible, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DocLineFromVisible), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_DocLineFromVisible},
    {sipName_DocumentEnd, meth_wxStyledTextCtrl_DocumentEnd, METH_VARARGS, doc_wxStyledTextCtrl_DocumentEnd},
    {sipName_DocumentEndExtend, meth_wxStyledTextCtrl_DocumentEndExtend, METH_VARARGS, doc_wxStyledTextCtrl_DocumentEndExtend},
    {sipName_DocumentStart, meth_wxStyledTextCtrl_DocumentStart, METH_VARARGS, doc_wxStyledTextCtrl_DocumentStart},
    {sipName_DocumentStartExtend, meth_wxStyledTextCtrl_DocumentStartExtend, METH_VARARGS, doc_wxStyledTextCtrl_DocumentStartExtend},
    {sipName_DropSelectionN, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_DropSelectionN), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_DropSelectionN},
    {sipName_EditToggleOvertype, meth_wxStyledTextCtrl_EditToggleOvertype, METH_VARARGS, doc_wxStyledTextCtrl_EditToggleOvertype},
    {sipName_EmptyUndoBuffer, meth_wxStyledTextCtrl_EmptyUndoBuffer, METH_VARARGS, doc_wxStyledTextCtrl_EmptyUndoBuffer},
    {sipName_EndUndoAction, meth_wxStyledTextCtrl_EndUndoAction, METH_VARARGS, doc_wxStyledTextCtrl_EndUndoAction},
    {sipName_EnsureCaretVisible, meth_wxStyledTextCtrl_EnsureCaretVisible, METH_VARARGS, doc_wxStyledTextCtrl_EnsureCaretVisible},
    {sipName_EnsureVisible, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_EnsureVisible), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_EnsureVisible},
    {sipName_EnsureVisibleEnforcePolicy, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_EnsureVisibleEnforcePolicy), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_EnsureVisibleEnforcePolicy},
    {sipName_ExpandChildren, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ExpandChildren), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ExpandChildren},
    {sipName_FindColumn, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_FindColumn), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_FindColumn},
    {sipName_FindText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_FindText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_FindText},
    {sipName_FoldAll, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_FoldAll), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_FoldAll},
    {sipName_FoldChildren, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_FoldChildren), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_FoldChildren},
    {sipName_FoldDisplayTextSetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_FoldDisplayTextSetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_FoldDisplayTextSetStyle},
    {sipName_FoldLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_FoldLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_FoldLine},
    {sipName_ForceUpper, meth_wxStyledTextCtrl_ForceUpper, METH_VARARGS, doc_wxStyledTextCtrl_ForceUpper},
    {sipName_FormFeed, meth_wxStyledTextCtrl_FormFeed, METH_VARARGS, doc_wxStyledTextCtrl_FormFeed},
    {sipName_FormatRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_FormatRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_FormatRange},
    {sipName_FreeSubStyles, meth_wxStyledTextCtrl_FreeSubStyles, METH_VARARGS, doc_wxStyledTextCtrl_FreeSubStyles},
    {sipName_GetAdditionalCaretForeground, meth_wxStyledTextCtrl_GetAdditionalCaretForeground, METH_VARARGS, doc_wxStyledTextCtrl_GetAdditionalCaretForeground},
    {sipName_GetAdditionalCaretsBlink, meth_wxStyledTextCtrl_GetAdditionalCaretsBlink, METH_VARARGS, doc_wxStyledTextCtrl_GetAdditionalCaretsBlink},
    {sipName_GetAdditionalCaretsVisible, meth_wxStyledTextCtrl_GetAdditionalCaretsVisible, METH_VARARGS, doc_wxStyledTextCtrl_GetAdditionalCaretsVisible},
    {sipName_GetAdditionalSelAlpha, meth_wxStyledTextCtrl_GetAdditionalSelAlpha, METH_VARARGS, doc_wxStyledTextCtrl_GetAdditionalSelAlpha},
    {sipName_GetAdditionalSelectionTyping, meth_wxStyledTextCtrl_GetAdditionalSelectionTyping, METH_VARARGS, doc_wxStyledTextCtrl_GetAdditionalSelectionTyping},
    {sipName_GetAllLinesVisible, meth_wxStyledTextCtrl_GetAllLinesVisible, METH_VARARGS, doc_wxStyledTextCtrl_GetAllLinesVisible},
    {sipName_GetAnchor, meth_wxStyledTextCtrl_GetAnchor, METH_VARARGS, doc_wxStyledTextCtrl_GetAnchor},
    {sipName_GetAutomaticFold, meth_wxStyledTextCtrl_GetAutomaticFold, METH_VARARGS, doc_wxStyledTextCtrl_GetAutomaticFold},
    {sipName_GetBackSpaceUnIndents, meth_wxStyledTextCtrl_GetBackSpaceUnIndents, METH_VARARGS, doc_wxStyledTextCtrl_GetBackSpaceUnIndents},
    {sipName_GetBufferedDraw, meth_wxStyledTextCtrl_GetBufferedDraw, METH_VARARGS, doc_wxStyledTextCtrl_GetBufferedDraw},
    {sipName_GetCaretForeground, meth_wxStyledTextCtrl_GetCaretForeground, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretForeground},
    {sipName_GetCaretLineBackAlpha, meth_wxStyledTextCtrl_GetCaretLineBackAlpha, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretLineBackAlpha},
    {sipName_GetCaretLineBackground, meth_wxStyledTextCtrl_GetCaretLineBackground, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretLineBackground},
    {sipName_GetCaretLineVisible, meth_wxStyledTextCtrl_GetCaretLineVisible, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretLineVisible},
    {sipName_GetCaretLineVisibleAlways, meth_wxStyledTextCtrl_GetCaretLineVisibleAlways, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretLineVisibleAlways},
    {sipName_GetCaretPeriod, meth_wxStyledTextCtrl_GetCaretPeriod, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretPeriod},
    {sipName_GetCaretSticky, meth_wxStyledTextCtrl_GetCaretSticky, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretSticky},
    {sipName_GetCaretStyle, meth_wxStyledTextCtrl_GetCaretStyle, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretStyle},
    {sipName_GetCaretWidth, meth_wxStyledTextCtrl_GetCaretWidth, METH_VARARGS, doc_wxStyledTextCtrl_GetCaretWidth},
    {sipName_GetCharAt, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetCharAt), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetCharAt},
    {sipName_GetCharacterPointer, meth_wxStyledTextCtrl_GetCharacterPointer, METH_VARARGS, doc_wxStyledTextCtrl_GetCharacterPointer},
    {sipName_GetClassDefaultAttributes, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetClassDefaultAttributes), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetClassDefaultAttributes},
    {sipName_GetCodePage, meth_wxStyledTextCtrl_GetCodePage, METH_VARARGS, doc_wxStyledTextCtrl_GetCodePage},
    {sipName_GetColumn, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetColumn), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetColumn},
    {sipName_GetControlCharSymbol, meth_wxStyledTextCtrl_GetControlCharSymbol, METH_VARARGS, doc_wxStyledTextCtrl_GetControlCharSymbol},
    {sipName_GetCurLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetCurLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetCurLine},
    {sipName_GetCurLineRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetCurLineRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetCurLineRaw},
    {sipName_GetCurrentLine, meth_wxStyledTextCtrl_GetCurrentLine, METH_VARARGS, doc_wxStyledTextCtrl_GetCurrentLine},
    {sipName_GetCurrentPos, meth_wxStyledTextCtrl_GetCurrentPos, METH_VARARGS, doc_wxStyledTextCtrl_GetCurrentPos},
    {sipName_GetDefaultBorder, meth_wxStyledTextCtrl_GetDefaultBorder, METH_VARARGS, SIP_NULLPTR},
    {sipName_GetDefaultBorderForControl, meth_wxStyledTextCtrl_GetDefaultBorderForControl, METH_VARARGS, SIP_NULLPTR},
    {sipName_GetDefaultStyle, meth_wxStyledTextCtrl_GetDefaultStyle, METH_VARARGS, doc_wxStyledTextCtrl_GetDefaultStyle},
    {sipName_GetDirectFunction, meth_wxStyledTextCtrl_GetDirectFunction, METH_VARARGS, doc_wxStyledTextCtrl_GetDirectFunction},
    {sipName_GetDirectPointer, meth_wxStyledTextCtrl_GetDirectPointer, METH_VARARGS, doc_wxStyledTextCtrl_GetDirectPointer},
    {sipName_GetDocPointer, meth_wxStyledTextCtrl_GetDocPointer, METH_VARARGS, doc_wxStyledTextCtrl_GetDocPointer},
    {sipName_GetEOLMode, meth_wxStyledTextCtrl_GetEOLMode, METH_VARARGS, doc_wxStyledTextCtrl_GetEOLMode},
    {sipName_GetEdgeColour, meth_wxStyledTextCtrl_GetEdgeColour, METH_VARARGS, doc_wxStyledTextCtrl_GetEdgeColour},
    {sipName_GetEdgeColumn, meth_wxStyledTextCtrl_GetEdgeColumn, METH_VARARGS, doc_wxStyledTextCtrl_GetEdgeColumn},
    {sipName_GetEdgeMode, meth_wxStyledTextCtrl_GetEdgeMode, METH_VARARGS, doc_wxStyledTextCtrl_GetEdgeMode},
    {sipName_GetEndAtLastLine, meth_wxStyledTextCtrl_GetEndAtLastLine, METH_VARARGS, doc_wxStyledTextCtrl_GetEndAtLastLine},
    {sipName_GetEndStyled, meth_wxStyledTextCtrl_GetEndStyled, METH_VARARGS, doc_wxStyledTextCtrl_GetEndStyled},
    {sipName_GetExtraAscent, meth_wxStyledTextCtrl_GetExtraAscent, METH_VARARGS, doc_wxStyledTextCtrl_GetExtraAscent},
    {sipName_GetExtraDescent, meth_wxStyledTextCtrl_GetExtraDescent, METH_VARARGS, doc_wxStyledTextCtrl_GetExtraDescent},
    {sipName_GetFirstVisibleLine, meth_wxStyledTextCtrl_GetFirstVisibleLine, METH_VARARGS, doc_wxStyledTextCtrl_GetFirstVisibleLine},
    {sipName_GetFoldExpanded, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetFoldExpanded), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetFoldExpanded},
    {sipName_GetFoldLevel, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetFoldLevel), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetFoldLevel},
    {sipName_GetFoldParent, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetFoldParent), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetFoldParent},
    {sipName_GetFontQuality, meth_wxStyledTextCtrl_GetFontQuality, METH_VARARGS, doc_wxStyledTextCtrl_GetFontQuality},
    {sipName_GetGapPosition, meth_wxStyledTextCtrl_GetGapPosition, METH_VARARGS, doc_wxStyledTextCtrl_GetGapPosition},
    {sipName_GetHighlightGuide, meth_wxStyledTextCtrl_GetHighlightGuide, METH_VARARGS, doc_wxStyledTextCtrl_GetHighlightGuide},
    {sipName_GetHint, meth_wxStyledTextCtrl_GetHint, METH_VARARGS, doc_wxStyledTextCtrl_GetHint},
    {sipName_GetHotspotActiveBackground, meth_wxStyledTextCtrl_GetHotspotActiveBackground, METH_VARARGS, doc_wxStyledTextCtrl_GetHotspotActiveBackground},
    {sipName_GetHotspotActiveForeground, meth_wxStyledTextCtrl_GetHotspotActiveForeground, METH_VARARGS, doc_wxStyledTextCtrl_GetHotspotActiveForeground},
    {sipName_GetHotspotActiveUnderline, meth_wxStyledTextCtrl_GetHotspotActiveUnderline, METH_VARARGS, doc_wxStyledTextCtrl_GetHotspotActiveUnderline},
    {sipName_GetHotspotSingleLine, meth_wxStyledTextCtrl_GetHotspotSingleLine, METH_VARARGS, doc_wxStyledTextCtrl_GetHotspotSingleLine},
    {sipName_GetIMEInteraction, meth_wxStyledTextCtrl_GetIMEInteraction, METH_VARARGS, doc_wxStyledTextCtrl_GetIMEInteraction},
    {sipName_GetIdentifier, meth_wxStyledTextCtrl_GetIdentifier, METH_VARARGS, doc_wxStyledTextCtrl_GetIdentifier},
    {sipName_GetIdleStyling, meth_wxStyledTextCtrl_GetIdleStyling, METH_VARARGS, doc_wxStyledTextCtrl_GetIdleStyling},
    {sipName_GetIndent, meth_wxStyledTextCtrl_GetIndent, METH_VARARGS, doc_wxStyledTextCtrl_GetIndent},
    {sipName_GetIndentationGuides, meth_wxStyledTextCtrl_GetIndentationGuides, METH_VARARGS, doc_wxStyledTextCtrl_GetIndentationGuides},
    {sipName_GetIndicatorCurrent, meth_wxStyledTextCtrl_GetIndicatorCurrent, METH_VARARGS, doc_wxStyledTextCtrl_GetIndicatorCurrent},
    {sipName_GetIndicatorValue, meth_wxStyledTextCtrl_GetIndicatorValue, METH_VARARGS, doc_wxStyledTextCtrl_GetIndicatorValue},
    {sipName_GetInsertionPoint, meth_wxStyledTextCtrl_GetInsertionPoint, METH_VARARGS, doc_wxStyledTextCtrl_GetInsertionPoint},
    {sipName_GetLastChild, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLastChild), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLastChild},
    {sipName_GetLastKeydownProcessed, meth_wxStyledTextCtrl_GetLastKeydownProcessed, METH_VARARGS, doc_wxStyledTextCtrl_GetLastKeydownProcessed},
    {sipName_GetLastPosition, meth_wxStyledTextCtrl_GetLastPosition, METH_VARARGS, doc_wxStyledTextCtrl_GetLastPosition},
    {sipName_GetLayoutCache, meth_wxStyledTextCtrl_GetLayoutCache, METH_VARARGS, doc_wxStyledTextCtrl_GetLayoutCache},
    {sipName_GetLength, meth_wxStyledTextCtrl_GetLength, METH_VARARGS, doc_wxStyledTextCtrl_GetLength},
    {sipName_GetLexer, meth_wxStyledTextCtrl_GetLexer, METH_VARARGS, doc_wxStyledTextCtrl_GetLexer},
    {sipName_GetLexerLanguage, meth_wxStyledTextCtrl_GetLexerLanguage, METH_VARARGS, doc_wxStyledTextCtrl_GetLexerLanguage},
    {sipName_GetLibraryVersionInfo, meth_wxStyledTextCtrl_GetLibraryVersionInfo, METH_VARARGS, doc_wxStyledTextCtrl_GetLibraryVersionInfo},
    {sipName_GetLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLine},
    {sipName_GetLineCount, meth_wxStyledTextCtrl_GetLineCount, METH_VARARGS, doc_wxStyledTextCtrl_GetLineCount},
    {sipName_GetLineEndPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineEndPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineEndPosition},
    {sipName_GetLineEndTypesActive, meth_wxStyledTextCtrl_GetLineEndTypesActive, METH_VARARGS, doc_wxStyledTextCtrl_GetLineEndTypesActive},
    {sipName_GetLineEndTypesAllowed, meth_wxStyledTextCtrl_GetLineEndTypesAllowed, METH_VARARGS, doc_wxStyledTextCtrl_GetLineEndTypesAllowed},
    {sipName_GetLineEndTypesSupported, meth_wxStyledTextCtrl_GetLineEndTypesSupported, METH_VARARGS, doc_wxStyledTextCtrl_GetLineEndTypesSupported},
    {sipName_GetLineIndentPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineIndentPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineIndentPosition},
    {sipName_GetLineIndentation, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineIndentation), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineIndentation},
    {sipName_GetLineLength, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineLength), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineLength},
    {sipName_GetLineRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineRaw},
    {sipName_GetLineSelEndPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineSelEndPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineSelEndPosition},
    {sipName_GetLineSelStartPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineSelStartPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineSelStartPosition},
    {sipName_GetLineState, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineState), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineState},
    {sipName_GetLineText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineText},
    {sipName_GetLineVisible, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetLineVisible), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetLineVisible},
    {sipName_GetMainSelection, meth_wxStyledTextCtrl_GetMainSelection, METH_VARARGS, doc_wxStyledTextCtrl_GetMainSelection},
    {sipName_GetMarginBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetMarginBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetMarginBackground},
    {sipName_GetMarginCount, meth_wxStyledTextCtrl_GetMarginCount, METH_VARARGS, doc_wxStyledTextCtrl_GetMarginCount},
    {sipName_GetMarginCursor, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetMarginCursor), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetMarginCursor},
    {sipName_GetMarginLeft, meth_wxStyledTextCtrl_GetMarginLeft, METH_VARARGS, doc_wxStyledTextCtrl_GetMarginLeft},
    {sipName_GetMarginMask, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetMarginMask), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetMarginMask},
    {sipName_GetMarginOptions, meth_wxStyledTextCtrl_GetMarginOptions, METH_VARARGS, doc_wxStyledTextCtrl_GetMarginOptions},
    {sipName_GetMarginRight, meth_wxStyledTextCtrl_GetMarginRight, METH_VARARGS, doc_wxStyledTextCtrl_GetMarginRight},
    {sipName_GetMarginSensitive, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetMarginSensitive), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetMarginSensitive},
    {sipName_GetMarginType, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetMarginType), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetMarginType},
    {sipName_GetMarginWidth, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetMarginWidth), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetMarginWidth},
    {sipName_GetMargins, meth_wxStyledTextCtrl_GetMargins, METH_VARARGS, doc_wxStyledTextCtrl_GetMargins},
    {sipName_GetMarkerSymbolDefined, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetMarkerSymbolDefined), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetMarkerSymbolDefined},
    {sipName_GetMaxLineState, meth_wxStyledTextCtrl_GetMaxLineState, METH_VARARGS, doc_wxStyledTextCtrl_GetMaxLineState},
    {sipName_GetModEventMask, meth_wxStyledTextCtrl_GetModEventMask, METH_VARARGS, doc_wxStyledTextCtrl_GetModEventMask},
    {sipName_GetModify, meth_wxStyledTextCtrl_GetModify, METH_VARARGS, doc_wxStyledTextCtrl_GetModify},
    {sipName_GetMouseDownCaptures, meth_wxStyledTextCtrl_GetMouseDownCaptures, METH_VARARGS, doc_wxStyledTextCtrl_GetMouseDownCaptures},
    {sipName_GetMouseDwellTime, meth_wxStyledTextCtrl_GetMouseDwellTime, METH_VARARGS, doc_wxStyledTextCtrl_GetMouseDwellTime},
    {sipName_GetMouseSelectionRectangularSwitch, meth_wxStyledTextCtrl_GetMouseSelectionRectangularSwitch, METH_VARARGS, doc_wxStyledTextCtrl_GetMouseSelectionRectangularSwitch},
    {sipName_GetMouseWheelCaptures, meth_wxStyledTextCtrl_GetMouseWheelCaptures, METH_VARARGS, doc_wxStyledTextCtrl_GetMouseWheelCaptures},
    {sipName_GetMultiPaste, meth_wxStyledTextCtrl_GetMultiPaste, METH_VARARGS, doc_wxStyledTextCtrl_GetMultiPaste},
    {sipName_GetMultipleSelection, meth_wxStyledTextCtrl_GetMultipleSelection, METH_VARARGS, doc_wxStyledTextCtrl_GetMultipleSelection},
    {sipName_GetNextTabStop, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetNextTabStop), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetNextTabStop},
    {sipName_GetNumberOfLines, meth_wxStyledTextCtrl_GetNumberOfLines, METH_VARARGS, doc_wxStyledTextCtrl_GetNumberOfLines},
    {sipName_GetOvertype, meth_wxStyledTextCtrl_GetOvertype, METH_VARARGS, doc_wxStyledTextCtrl_GetOvertype},
    {sipName_GetPasteConvertEndings, meth_wxStyledTextCtrl_GetPasteConvertEndings, METH_VARARGS, doc_wxStyledTextCtrl_GetPasteConvertEndings},
    {sipName_GetPhasesDraw, meth_wxStyledTextCtrl_GetPhasesDraw, METH_VARARGS, doc_wxStyledTextCtrl_GetPhasesDraw},
    {sipName_GetPositionCacheSize, meth_wxStyledTextCtrl_GetPositionCacheSize, METH_VARARGS, doc_wxStyledTextCtrl_GetPositionCacheSize},
    {sipName_GetPrimaryStyleFromStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetPrimaryStyleFromStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetPrimaryStyleFromStyle},
    {sipName_GetPrintColourMode, meth_wxStyledTextCtrl_GetPrintColourMode, METH_VARARGS, doc_wxStyledTextCtrl_GetPrintColourMode},
    {sipName_GetPrintMagnification, meth_wxStyledTextCtrl_GetPrintMagnification, METH_VARARGS, doc_wxStyledTextCtrl_GetPrintMagnification},
    {sipName_GetPrintWrapMode, meth_wxStyledTextCtrl_GetPrintWrapMode, METH_VARARGS, doc_wxStyledTextCtrl_GetPrintWrapMode},
    {sipName_GetProperty, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetProperty), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetProperty},
    {sipName_GetPropertyExpanded, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetPropertyExpanded), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetPropertyExpanded},
    {sipName_GetPropertyInt, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetPropertyInt), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetPropertyInt},
    {sipName_GetPunctuationChars, meth_wxStyledTextCtrl_GetPunctuationChars, METH_VARARGS, doc_wxStyledTextCtrl_GetPunctuationChars},
    {sipName_GetRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetRange},
    {sipName_GetRangePointer, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetRangePointer), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetRangePointer},
    {sipName_GetReadOnly, meth_wxStyledTextCtrl_GetReadOnly, METH_VARARGS, doc_wxStyledTextCtrl_GetReadOnly},
    {sipName_GetRectangularSelectionAnchor, meth_wxStyledTextCtrl_GetRectangularSelectionAnchor, METH_VARARGS, doc_wxStyledTextCtrl_GetRectangularSelectionAnchor},
    {sipName_GetRectangularSelectionAnchorVirtualSpace, meth_wxStyledTextCtrl_GetRectangularSelectionAnchorVirtualSpace, METH_VARARGS, doc_wxStyledTextCtrl_GetRectangularSelectionAnchorVirtualSpace},
    {sipName_GetRectangularSelectionCaret, meth_wxStyledTextCtrl_GetRectangularSelectionCaret, METH_VARARGS, doc_wxStyledTextCtrl_GetRectangularSelectionCaret},
    {sipName_GetRectangularSelectionCaretVirtualSpace, meth_wxStyledTextCtrl_GetRectangularSelectionCaretVirtualSpace, METH_VARARGS, doc_wxStyledTextCtrl_GetRectangularSelectionCaretVirtualSpace},
    {sipName_GetRectangularSelectionModifier, meth_wxStyledTextCtrl_GetRectangularSelectionModifier, METH_VARARGS, doc_wxStyledTextCtrl_GetRectangularSelectionModifier},
    {sipName_GetRepresentation, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetRepresentation), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetRepresentation},
    {sipName_GetSTCCursor, meth_wxStyledTextCtrl_GetSTCCursor, METH_VARARGS, doc_wxStyledTextCtrl_GetSTCCursor},
    {sipName_GetSTCFocus, meth_wxStyledTextCtrl_GetSTCFocus, METH_VARARGS, doc_wxStyledTextCtrl_GetSTCFocus},
    {sipName_GetScrollWidth, meth_wxStyledTextCtrl_GetScrollWidth, METH_VARARGS, doc_wxStyledTextCtrl_GetScrollWidth},
    {sipName_GetScrollWidthTracking, meth_wxStyledTextCtrl_GetScrollWidthTracking, METH_VARARGS, doc_wxStyledTextCtrl_GetScrollWidthTracking},
    {sipName_GetSearchFlags, meth_wxStyledTextCtrl_GetSearchFlags, METH_VARARGS, doc_wxStyledTextCtrl_GetSearchFlags},
    {sipName_GetSelAlpha, meth_wxStyledTextCtrl_GetSelAlpha, METH_VARARGS, doc_wxStyledTextCtrl_GetSelAlpha},
    {sipName_GetSelEOLFilled, meth_wxStyledTextCtrl_GetSelEOLFilled, METH_VARARGS, doc_wxStyledTextCtrl_GetSelEOLFilled},
    {sipName_GetSelectedText, meth_wxStyledTextCtrl_GetSelectedText, METH_VARARGS, doc_wxStyledTextCtrl_GetSelectedText},
    {sipName_GetSelectedTextRaw, meth_wxStyledTextCtrl_GetSelectedTextRaw, METH_VARARGS, doc_wxStyledTextCtrl_GetSelectedTextRaw},
    {sipName_GetSelection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSelection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSelection},
    {sipName_GetSelectionEmpty, meth_wxStyledTextCtrl_GetSelectionEmpty, METH_VARARGS, doc_wxStyledTextCtrl_GetSelectionEmpty},
    {sipName_GetSelectionEnd, meth_wxStyledTextCtrl_GetSelectionEnd, METH_VARARGS, doc_wxStyledTextCtrl_GetSelectionEnd},
    {sipName_GetSelectionMode, meth_wxStyledTextCtrl_GetSelectionMode, METH_VARARGS, doc_wxStyledTextCtrl_GetSelectionMode},
    {sipName_GetSelectionNAnchor, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSelectionNAnchor), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSelectionNAnchor},
    {sipName_GetSelectionNAnchorVirtualSpace, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSelectionNAnchorVirtualSpace), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSelectionNAnchorVirtualSpace},
    {sipName_GetSelectionNCaret, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSelectionNCaret), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSelectionNCaret},
    {sipName_GetSelectionNCaretVirtualSpace, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSelectionNCaretVirtualSpace), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSelectionNCaretVirtualSpace},
    {sipName_GetSelectionNEnd, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSelectionNEnd), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSelectionNEnd},
    {sipName_GetSelectionNStart, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSelectionNStart), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSelectionNStart},
    {sipName_GetSelectionStart, meth_wxStyledTextCtrl_GetSelectionStart, METH_VARARGS, doc_wxStyledTextCtrl_GetSelectionStart},
    {sipName_GetSelections, meth_wxStyledTextCtrl_GetSelections, METH_VARARGS, doc_wxStyledTextCtrl_GetSelections},
    {sipName_GetStatus, meth_wxStyledTextCtrl_GetStatus, METH_VARARGS, doc_wxStyledTextCtrl_GetStatus},
    {sipName_GetStringSelection, meth_wxStyledTextCtrl_GetStringSelection, METH_VARARGS, doc_wxStyledTextCtrl_GetStringSelection},
    {sipName_GetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetStyle},
    {sipName_GetStyleAt, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetStyleAt), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetStyleAt},
    {sipName_GetStyleBits, meth_wxStyledTextCtrl_GetStyleBits, METH_VARARGS, doc_wxStyledTextCtrl_GetStyleBits},
    {sipName_GetStyleBitsNeeded, meth_wxStyledTextCtrl_GetStyleBitsNeeded, METH_VARARGS, doc_wxStyledTextCtrl_GetStyleBitsNeeded},
    {sipName_GetStyleFromSubStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetStyleFromSubStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetStyleFromSubStyle},
    {sipName_GetStyledText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetStyledText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetStyledText},
    {sipName_GetSubStyleBases, meth_wxStyledTextCtrl_GetSubStyleBases, METH_VARARGS, doc_wxStyledTextCtrl_GetSubStyleBases},
    {sipName_GetSubStylesLength, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSubStylesLength), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSubStylesLength},
    {sipName_GetSubStylesStart, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetSubStylesStart), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetSubStylesStart},
    {sipName_GetTabDrawMode, meth_wxStyledTextCtrl_GetTabDrawMode, METH_VARARGS, doc_wxStyledTextCtrl_GetTabDrawMode},
    {sipName_GetTabIndents, meth_wxStyledTextCtrl_GetTabIndents, METH_VARARGS, doc_wxStyledTextCtrl_GetTabIndents},
    {sipName_GetTabWidth, meth_wxStyledTextCtrl_GetTabWidth, METH_VARARGS, doc_wxStyledTextCtrl_GetTabWidth},
    {sipName_GetTag, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetTag), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetTag},
    {sipName_GetTargetEnd, meth_wxStyledTextCtrl_GetTargetEnd, METH_VARARGS, doc_wxStyledTextCtrl_GetTargetEnd},
    {sipName_GetTargetStart, meth_wxStyledTextCtrl_GetTargetStart, METH_VARARGS, doc_wxStyledTextCtrl_GetTargetStart},
    {sipName_GetTargetText, meth_wxStyledTextCtrl_GetTargetText, METH_VARARGS, doc_wxStyledTextCtrl_GetTargetText},
    {sipName_GetTargetTextRaw, meth_wxStyledTextCtrl_GetTargetTextRaw, METH_VARARGS, doc_wxStyledTextCtrl_GetTargetTextRaw},
    {sipName_GetTechnology, meth_wxStyledTextCtrl_GetTechnology, METH_VARARGS, doc_wxStyledTextCtrl_GetTechnology},
    {sipName_GetText, meth_wxStyledTextCtrl_GetText, METH_VARARGS, doc_wxStyledTextCtrl_GetText},
    {sipName_GetTextLength, meth_wxStyledTextCtrl_GetTextLength, METH_VARARGS, doc_wxStyledTextCtrl_GetTextLength},
    {sipName_GetTextRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetTextRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetTextRange},
    {sipName_GetTextRangeRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GetTextRangeRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GetTextRangeRaw},
    {sipName_GetTextRaw, meth_wxStyledTextCtrl_GetTextRaw, METH_VARARGS, doc_wxStyledTextCtrl_GetTextRaw},
    {sipName_GetTwoPhaseDraw, meth_wxStyledTextCtrl_GetTwoPhaseDraw, METH_VARARGS, doc_wxStyledTextCtrl_GetTwoPhaseDraw},
    {sipName_GetUndoCollection, meth_wxStyledTextCtrl_GetUndoCollection, METH_VARARGS, doc_wxStyledTextCtrl_GetUndoCollection},
    {sipName_GetUseAntiAliasing, meth_wxStyledTextCtrl_GetUseAntiAliasing, METH_VARARGS, doc_wxStyledTextCtrl_GetUseAntiAliasing},
    {sipName_GetUseHorizontalScrollBar, meth_wxStyledTextCtrl_GetUseHorizontalScrollBar, METH_VARARGS, doc_wxStyledTextCtrl_GetUseHorizontalScrollBar},
    {sipName_GetUseTabs, meth_wxStyledTextCtrl_GetUseTabs, METH_VARARGS, doc_wxStyledTextCtrl_GetUseTabs},
    {sipName_GetUseVerticalScrollBar, meth_wxStyledTextCtrl_GetUseVerticalScrollBar, METH_VARARGS, doc_wxStyledTextCtrl_GetUseVerticalScrollBar},
    {sipName_GetValue, meth_wxStyledTextCtrl_GetValue, METH_VARARGS, doc_wxStyledTextCtrl_GetValue},
    {sipName_GetViewEOL, meth_wxStyledTextCtrl_GetViewEOL, METH_VARARGS, doc_wxStyledTextCtrl_GetViewEOL},
    {sipName_GetViewWhiteSpace, meth_wxStyledTextCtrl_GetViewWhiteSpace, METH_VARARGS, doc_wxStyledTextCtrl_GetViewWhiteSpace},
    {sipName_GetVirtualSpaceOptions, meth_wxStyledTextCtrl_GetVirtualSpaceOptions, METH_VARARGS, doc_wxStyledTextCtrl_GetVirtualSpaceOptions},
    {sipName_GetWhitespaceChars, meth_wxStyledTextCtrl_GetWhitespaceChars, METH_VARARGS, doc_wxStyledTextCtrl_GetWhitespaceChars},
    {sipName_GetWhitespaceSize, meth_wxStyledTextCtrl_GetWhitespaceSize, METH_VARARGS, doc_wxStyledTextCtrl_GetWhitespaceSize},
    {sipName_GetWordChars, meth_wxStyledTextCtrl_GetWordChars, METH_VARARGS, doc_wxStyledTextCtrl_GetWordChars},
    {sipName_GetWrapIndentMode, meth_wxStyledTextCtrl_GetWrapIndentMode, METH_VARARGS, doc_wxStyledTextCtrl_GetWrapIndentMode},
    {sipName_GetWrapMode, meth_wxStyledTextCtrl_GetWrapMode, METH_VARARGS, doc_wxStyledTextCtrl_GetWrapMode},
    {sipName_GetWrapStartIndent, meth_wxStyledTextCtrl_GetWrapStartIndent, METH_VARARGS, doc_wxStyledTextCtrl_GetWrapStartIndent},
    {sipName_GetWrapVisualFlags, meth_wxStyledTextCtrl_GetWrapVisualFlags, METH_VARARGS, doc_wxStyledTextCtrl_GetWrapVisualFlags},
    {sipName_GetWrapVisualFlagsLocation, meth_wxStyledTextCtrl_GetWrapVisualFlagsLocation, METH_VARARGS, doc_wxStyledTextCtrl_GetWrapVisualFlagsLocation},
    {sipName_GetXOffset, meth_wxStyledTextCtrl_GetXOffset, METH_VARARGS, doc_wxStyledTextCtrl_GetXOffset},
    {sipName_GetZoom, meth_wxStyledTextCtrl_GetZoom, METH_VARARGS, doc_wxStyledTextCtrl_GetZoom},
    {sipName_GotoLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GotoLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GotoLine},
    {sipName_GotoPos, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_GotoPos), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_GotoPos},
    {sipName_HasTransparentBackground, meth_wxStyledTextCtrl_HasTransparentBackground, METH_VARARGS, SIP_NULLPTR},
    {sipName_HideLines, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_HideLines), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_HideLines},
    {sipName_HideSelection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_HideSelection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_HideSelection},
    {sipName_HitTest, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_HitTest), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_HitTest},
    {sipName_HitTestPos, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_HitTestPos), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_HitTestPos},
    {sipName_Home, meth_wxStyledTextCtrl_Home, METH_VARARGS, doc_wxStyledTextCtrl_Home},
    {sipName_HomeDisplay, meth_wxStyledTextCtrl_HomeDisplay, METH_VARARGS, doc_wxStyledTextCtrl_HomeDisplay},
    {sipName_HomeDisplayExtend, meth_wxStyledTextCtrl_HomeDisplayExtend, METH_VARARGS, doc_wxStyledTextCtrl_HomeDisplayExtend},
    {sipName_HomeExtend, meth_wxStyledTextCtrl_HomeExtend, METH_VARARGS, doc_wxStyledTextCtrl_HomeExtend},
    {sipName_HomeRectExtend, meth_wxStyledTextCtrl_HomeRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_HomeRectExtend},
    {sipName_HomeWrap, meth_wxStyledTextCtrl_HomeWrap, METH_VARARGS, doc_wxStyledTextCtrl_HomeWrap},
    {sipName_HomeWrapExtend, meth_wxStyledTextCtrl_HomeWrapExtend, METH_VARARGS, doc_wxStyledTextCtrl_HomeWrapExtend},
    {sipName_IndicatorAllOnFor, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorAllOnFor), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorAllOnFor},
    {sipName_IndicatorClearRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorClearRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorClearRange},
    {sipName_IndicatorEnd, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorEnd), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorEnd},
    {sipName_IndicatorFillRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorFillRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorFillRange},
    {sipName_IndicatorGetAlpha, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorGetAlpha), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorGetAlpha},
    {sipName_IndicatorGetFlags, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorGetFlags), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorGetFlags},
    {sipName_IndicatorGetForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorGetForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorGetForeground},
    {sipName_IndicatorGetHoverForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorGetHoverForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorGetHoverForeground},
    {sipName_IndicatorGetHoverStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorGetHoverStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorGetHoverStyle},
    {sipName_IndicatorGetOutlineAlpha, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorGetOutlineAlpha), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorGetOutlineAlpha},
    {sipName_IndicatorGetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorGetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorGetStyle},
    {sipName_IndicatorGetUnder, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorGetUnder), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorGetUnder},
    {sipName_IndicatorSetAlpha, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorSetAlpha), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorSetAlpha},
    {sipName_IndicatorSetFlags, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorSetFlags), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorSetFlags},
    {sipName_IndicatorSetForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorSetForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorSetForeground},
    {sipName_IndicatorSetHoverForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorSetHoverForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorSetHoverForeground},
    {sipName_IndicatorSetHoverStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorSetHoverStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorSetHoverStyle},
    {sipName_IndicatorSetOutlineAlpha, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorSetOutlineAlpha), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorSetOutlineAlpha},
    {sipName_IndicatorSetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorSetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorSetStyle},
    {sipName_IndicatorSetUnder, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorSetUnder), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorSetUnder},
    {sipName_IndicatorStart, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorStart), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorStart},
    {sipName_IndicatorValueAt, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IndicatorValueAt), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IndicatorValueAt},
    {sipName_InsertText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_InsertText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_InsertText},
    {sipName_InsertTextRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_InsertTextRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_InsertTextRaw},
    {sipName_IsEditable, meth_wxStyledTextCtrl_IsEditable, METH_VARARGS, doc_wxStyledTextCtrl_IsEditable},
    {sipName_IsEmpty, meth_wxStyledTextCtrl_IsEmpty, METH_VARARGS, doc_wxStyledTextCtrl_IsEmpty},
    {sipName_IsModified, meth_wxStyledTextCtrl_IsModified, METH_VARARGS, doc_wxStyledTextCtrl_IsModified},
    {sipName_IsRangeWord, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_IsRangeWord), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_IsRangeWord},
    {sipName_LineCopy, meth_wxStyledTextCtrl_LineCopy, METH_VARARGS, doc_wxStyledTextCtrl_LineCopy},
    {sipName_LineCut, meth_wxStyledTextCtrl_LineCut, METH_VARARGS, doc_wxStyledTextCtrl_LineCut},
    {sipName_LineDelete, meth_wxStyledTextCtrl_LineDelete, METH_VARARGS, doc_wxStyledTextCtrl_LineDelete},
    {sipName_LineDown, meth_wxStyledTextCtrl_LineDown, METH_VARARGS, doc_wxStyledTextCtrl_LineDown},
    {sipName_LineDownExtend, meth_wxStyledTextCtrl_LineDownExtend, METH_VARARGS, doc_wxStyledTextCtrl_LineDownExtend},
    {sipName_LineDownRectExtend, meth_wxStyledTextCtrl_LineDownRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_LineDownRectExtend},
    {sipName_LineDuplicate, meth_wxStyledTextCtrl_LineDuplicate, METH_VARARGS, doc_wxStyledTextCtrl_LineDuplicate},
    {sipName_LineEnd, meth_wxStyledTextCtrl_LineEnd, METH_VARARGS, doc_wxStyledTextCtrl_LineEnd},
    {sipName_LineEndDisplay, meth_wxStyledTextCtrl_LineEndDisplay, METH_VARARGS, doc_wxStyledTextCtrl_LineEndDisplay},
    {sipName_LineEndDisplayExtend, meth_wxStyledTextCtrl_LineEndDisplayExtend, METH_VARARGS, doc_wxStyledTextCtrl_LineEndDisplayExtend},
    {sipName_LineEndExtend, meth_wxStyledTextCtrl_LineEndExtend, METH_VARARGS, doc_wxStyledTextCtrl_LineEndExtend},
    {sipName_LineEndRectExtend, meth_wxStyledTextCtrl_LineEndRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_LineEndRectExtend},
    {sipName_LineEndWrap, meth_wxStyledTextCtrl_LineEndWrap, METH_VARARGS, doc_wxStyledTextCtrl_LineEndWrap},
    {sipName_LineEndWrapExtend, meth_wxStyledTextCtrl_LineEndWrapExtend, METH_VARARGS, doc_wxStyledTextCtrl_LineEndWrapExtend},
    {sipName_LineFromPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_LineFromPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_LineFromPosition},
    {sipName_LineLength, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_LineLength), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_LineLength},
    {sipName_LineScroll, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_LineScroll), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_LineScroll},
    {sipName_LineScrollDown, meth_wxStyledTextCtrl_LineScrollDown, METH_VARARGS, doc_wxStyledTextCtrl_LineScrollDown},
    {sipName_LineScrollUp, meth_wxStyledTextCtrl_LineScrollUp, METH_VARARGS, doc_wxStyledTextCtrl_LineScrollUp},
    {sipName_LineTranspose, meth_wxStyledTextCtrl_LineTranspose, METH_VARARGS, doc_wxStyledTextCtrl_LineTranspose},
    {sipName_LineUp, meth_wxStyledTextCtrl_LineUp, METH_VARARGS, doc_wxStyledTextCtrl_LineUp},
    {sipName_LineUpExtend, meth_wxStyledTextCtrl_LineUpExtend, METH_VARARGS, doc_wxStyledTextCtrl_LineUpExtend},
    {sipName_LineUpRectExtend, meth_wxStyledTextCtrl_LineUpRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_LineUpRectExtend},
    {sipName_LinesJoin, meth_wxStyledTextCtrl_LinesJoin, METH_VARARGS, doc_wxStyledTextCtrl_LinesJoin},
    {sipName_LinesOnScreen, meth_wxStyledTextCtrl_LinesOnScreen, METH_VARARGS, doc_wxStyledTextCtrl_LinesOnScreen},
    {sipName_LinesSplit, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_LinesSplit), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_LinesSplit},
    {sipName_LoadFile, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_LoadFile), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_LoadFile},
    {sipName_LoadLexerLibrary, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_LoadLexerLibrary), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_LoadLexerLibrary},
    {sipName_LowerCase, meth_wxStyledTextCtrl_LowerCase, METH_VARARGS, doc_wxStyledTextCtrl_LowerCase},
    {sipName_MarginGetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarginGetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarginGetStyle},
    {sipName_MarginGetStyleOffset, meth_wxStyledTextCtrl_MarginGetStyleOffset, METH_VARARGS, doc_wxStyledTextCtrl_MarginGetStyleOffset},
    {sipName_MarginGetStyles, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarginGetStyles), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarginGetStyles},
    {sipName_MarginGetText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarginGetText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarginGetText},
    {sipName_MarginSetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarginSetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarginSetStyle},
    {sipName_MarginSetStyleOffset, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarginSetStyleOffset), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarginSetStyleOffset},
    {sipName_MarginSetStyles, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarginSetStyles), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarginSetStyles},
    {sipName_MarginSetText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarginSetText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarginSetText},
    {sipName_MarginTextClearAll, meth_wxStyledTextCtrl_MarginTextClearAll, METH_VARARGS, doc_wxStyledTextCtrl_MarginTextClearAll},
    {sipName_MarkDirty, meth_wxStyledTextCtrl_MarkDirty, METH_VARARGS, doc_wxStyledTextCtrl_MarkDirty},
    {sipName_MarkerAdd, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerAdd), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerAdd},
    {sipName_MarkerAddSet, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerAddSet), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerAddSet},
    {sipName_MarkerDefine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerDefine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerDefine},
    {sipName_MarkerDefineBitmap, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerDefineBitmap), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerDefineBitmap},
    {sipName_MarkerDefineRGBAImage, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerDefineRGBAImage), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerDefineRGBAImage},
    {sipName_MarkerDelete, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerDelete), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerDelete},
    {sipName_MarkerDeleteAll, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerDeleteAll), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerDeleteAll},
    {sipName_MarkerDeleteHandle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerDeleteHandle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerDeleteHandle},
    {sipName_MarkerEnableHighlight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerEnableHighlight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerEnableHighlight},
    {sipName_MarkerGet, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerGet), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerGet},
    {sipName_MarkerLineFromHandle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerLineFromHandle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerLineFromHandle},
    {sipName_MarkerNext, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerNext), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerNext},
    {sipName_MarkerPrevious, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerPrevious), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerPrevious},
    {sipName_MarkerSetAlpha, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerSetAlpha), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerSetAlpha},
    {sipName_MarkerSetBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerSetBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerSetBackground},
    {sipName_MarkerSetBackgroundSelected, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerSetBackgroundSelected), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerSetBackgroundSelected},
    {sipName_MarkerSetForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MarkerSetForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MarkerSetForeground},
    {sipName_MoveCaretInsideView, meth_wxStyledTextCtrl_MoveCaretInsideView, METH_VARARGS, doc_wxStyledTextCtrl_MoveCaretInsideView},
    {sipName_MoveSelectedLinesDown, meth_wxStyledTextCtrl_MoveSelectedLinesDown, METH_VARARGS, doc_wxStyledTextCtrl_MoveSelectedLinesDown},
    {sipName_MoveSelectedLinesUp, meth_wxStyledTextCtrl_MoveSelectedLinesUp, METH_VARARGS, doc_wxStyledTextCtrl_MoveSelectedLinesUp},
    {sipName_MultiEdgeAddLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_MultiEdgeAddLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_MultiEdgeAddLine},
    {sipName_MultiEdgeClearAll, meth_wxStyledTextCtrl_MultiEdgeClearAll, METH_VARARGS, doc_wxStyledTextCtrl_MultiEdgeClearAll},
    {sipName_MultipleSelectAddEach, meth_wxStyledTextCtrl_MultipleSelectAddEach, METH_VARARGS, doc_wxStyledTextCtrl_MultipleSelectAddEach},
    {sipName_MultipleSelectAddNext, meth_wxStyledTextCtrl_MultipleSelectAddNext, METH_VARARGS, doc_wxStyledTextCtrl_MultipleSelectAddNext},
    {sipName_NewLine, meth_wxStyledTextCtrl_NewLine, METH_VARARGS, doc_wxStyledTextCtrl_NewLine},
    {sipName_PageDown, meth_wxStyledTextCtrl_PageDown, METH_VARARGS, doc_wxStyledTextCtrl_PageDown},
    {sipName_PageDownExtend, meth_wxStyledTextCtrl_PageDownExtend, METH_VARARGS, doc_wxStyledTextCtrl_PageDownExtend},
    {sipName_PageDownRectExtend, meth_wxStyledTextCtrl_PageDownRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_PageDownRectExtend},
    {sipName_PageUp, meth_wxStyledTextCtrl_PageUp, METH_VARARGS, doc_wxStyledTextCtrl_PageUp},
    {sipName_PageUpExtend, meth_wxStyledTextCtrl_PageUpExtend, METH_VARARGS, doc_wxStyledTextCtrl_PageUpExtend},
    {sipName_PageUpRectExtend, meth_wxStyledTextCtrl_PageUpRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_PageUpRectExtend},
    {sipName_ParaDown, meth_wxStyledTextCtrl_ParaDown, METH_VARARGS, doc_wxStyledTextCtrl_ParaDown},
    {sipName_ParaDownExtend, meth_wxStyledTextCtrl_ParaDownExtend, METH_VARARGS, doc_wxStyledTextCtrl_ParaDownExtend},
    {sipName_ParaUp, meth_wxStyledTextCtrl_ParaUp, METH_VARARGS, doc_wxStyledTextCtrl_ParaUp},
    {sipName_ParaUpExtend, meth_wxStyledTextCtrl_ParaUpExtend, METH_VARARGS, doc_wxStyledTextCtrl_ParaUpExtend},
    {sipName_Paste, meth_wxStyledTextCtrl_Paste, METH_VARARGS, doc_wxStyledTextCtrl_Paste},
    {sipName_PointFromPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PointFromPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PointFromPosition},
    {sipName_PositionAfter, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PositionAfter), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PositionAfter},
    {sipName_PositionBefore, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PositionBefore), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PositionBefore},
    {sipName_PositionFromLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PositionFromLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PositionFromLine},
    {sipName_PositionFromPoint, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PositionFromPoint), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PositionFromPoint},
    {sipName_PositionFromPointClose, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PositionFromPointClose), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PositionFromPointClose},
    {sipName_PositionRelative, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PositionRelative), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PositionRelative},
    {sipName_PositionToCoords, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PositionToCoords), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PositionToCoords},
    {sipName_PositionToXY, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PositionToXY), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PositionToXY},
    {sipName_PrivateLexerCall, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PrivateLexerCall), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PrivateLexerCall},
    {sipName_ProcessEvent, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ProcessEvent), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_PropertyNames, meth_wxStyledTextCtrl_PropertyNames, METH_VARARGS, doc_wxStyledTextCtrl_PropertyNames},
    {sipName_PropertyType, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_PropertyType), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_PropertyType},
    {sipName_RGBAImageSetHeight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_RGBAImageSetHeight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_RGBAImageSetHeight},
    {sipName_RGBAImageSetScale, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_RGBAImageSetScale), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_RGBAImageSetScale},
    {sipName_RGBAImageSetWidth, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_RGBAImageSetWidth), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_RGBAImageSetWidth},
    {sipName_Redo, meth_wxStyledTextCtrl_Redo, METH_VARARGS, doc_wxStyledTextCtrl_Redo},
    {sipName_RegisterImage, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_RegisterImage), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_RegisterImage},
    {sipName_RegisterRGBAImage, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_RegisterRGBAImage), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_RegisterRGBAImage},
    {sipName_ReleaseAllExtendedStyles, meth_wxStyledTextCtrl_ReleaseAllExtendedStyles, METH_VARARGS, doc_wxStyledTextCtrl_ReleaseAllExtendedStyles},
    {sipName_ReleaseDocument, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ReleaseDocument), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ReleaseDocument},
    {sipName_Remove, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_Remove), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_Remove},
    {sipName_Replace, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_Replace), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_Replace},
    {sipName_ReplaceSelection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ReplaceSelection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ReplaceSelection},
    {sipName_ReplaceSelectionRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ReplaceSelectionRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ReplaceSelectionRaw},
    {sipName_ReplaceTarget, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ReplaceTarget), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ReplaceTarget},
    {sipName_ReplaceTargetRE, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ReplaceTargetRE), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ReplaceTargetRE},
    {sipName_ReplaceTargetRERaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ReplaceTargetRERaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ReplaceTargetRERaw},
    {sipName_ReplaceTargetRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ReplaceTargetRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ReplaceTargetRaw},
    {sipName_RotateSelection, meth_wxStyledTextCtrl_RotateSelection, METH_VARARGS, doc_wxStyledTextCtrl_RotateSelection},
    {sipName_SaveFile, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SaveFile), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SaveFile},
    {sipName_ScrollRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ScrollRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ScrollRange},
    {sipName_ScrollToColumn, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ScrollToColumn), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ScrollToColumn},
    {sipName_ScrollToEnd, meth_wxStyledTextCtrl_ScrollToEnd, METH_VARARGS, doc_wxStyledTextCtrl_ScrollToEnd},
    {sipName_ScrollToLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ScrollToLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ScrollToLine},
    {sipName_ScrollToStart, meth_wxStyledTextCtrl_ScrollToStart, METH_VARARGS, doc_wxStyledTextCtrl_ScrollToStart},
    {sipName_SearchAnchor, meth_wxStyledTextCtrl_SearchAnchor, METH_VARARGS, doc_wxStyledTextCtrl_SearchAnchor},
    {sipName_SearchInTarget, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SearchInTarget), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SearchInTarget},
    {sipName_SearchNext, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SearchNext), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SearchNext},
    {sipName_SearchPrev, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SearchPrev), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SearchPrev},
    {sipName_SelectAll, meth_wxStyledTextCtrl_SelectAll, METH_VARARGS, doc_wxStyledTextCtrl_SelectAll},
    {sipName_SelectNone, meth_wxStyledTextCtrl_SelectNone, METH_VARARGS, doc_wxStyledTextCtrl_SelectNone},
    {sipName_SelectionDuplicate, meth_wxStyledTextCtrl_SelectionDuplicate, METH_VARARGS, doc_wxStyledTextCtrl_SelectionDuplicate},
    {sipName_SelectionIsRectangle, meth_wxStyledTextCtrl_SelectionIsRectangle, METH_VARARGS, doc_wxStyledTextCtrl_SelectionIsRectangle},
    {sipName_SendDestroyEvent, meth_wxStyledTextCtrl_SendDestroyEvent, METH_VARARGS, SIP_NULLPTR},
    {sipName_SendMsg, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SendMsg), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SendMsg},
    {sipName_SetAdditionalCaretForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAdditionalCaretForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAdditionalCaretForeground},
    {sipName_SetAdditionalCaretsBlink, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAdditionalCaretsBlink), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAdditionalCaretsBlink},
    {sipName_SetAdditionalCaretsVisible, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAdditionalCaretsVisible), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAdditionalCaretsVisible},
    {sipName_SetAdditionalSelAlpha, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAdditionalSelAlpha), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAdditionalSelAlpha},
    {sipName_SetAdditionalSelBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAdditionalSelBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAdditionalSelBackground},
    {sipName_SetAdditionalSelForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAdditionalSelForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAdditionalSelForeground},
    {sipName_SetAdditionalSelectionTyping, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAdditionalSelectionTyping), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAdditionalSelectionTyping},
    {sipName_SetAnchor, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAnchor), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAnchor},
    {sipName_SetAutomaticFold, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetAutomaticFold), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetAutomaticFold},
    {sipName_SetBackSpaceUnIndents, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetBackSpaceUnIndents), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetBackSpaceUnIndents},
    {sipName_SetBufferedDraw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetBufferedDraw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetBufferedDraw},
    {sipName_SetCaretForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretForeground},
    {sipName_SetCaretLineBackAlpha, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretLineBackAlpha), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretLineBackAlpha},
    {sipName_SetCaretLineBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretLineBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretLineBackground},
    {sipName_SetCaretLineVisible, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretLineVisible), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretLineVisible},
    {sipName_SetCaretLineVisibleAlways, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretLineVisibleAlways), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretLineVisibleAlways},
    {sipName_SetCaretPeriod, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretPeriod), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretPeriod},
    {sipName_SetCaretSticky, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretSticky), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretSticky},
    {sipName_SetCaretStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretStyle},
    {sipName_SetCaretWidth, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCaretWidth), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCaretWidth},
    {sipName_SetCharsDefault, meth_wxStyledTextCtrl_SetCharsDefault, METH_VARARGS, doc_wxStyledTextCtrl_SetCharsDefault},
    {sipName_SetCodePage, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCodePage), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCodePage},
    {sipName_SetControlCharSymbol, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetControlCharSymbol), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetControlCharSymbol},
    {sipName_SetCurrentPos, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetCurrentPos), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetCurrentPos},
    {sipName_SetDefaultStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetDefaultStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetDefaultStyle},
    {sipName_SetDocPointer, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetDocPointer), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetDocPointer},
    {sipName_SetEOLMode, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetEOLMode), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetEOLMode},
    {sipName_SetEdgeColour, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetEdgeColour), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetEdgeColour},
    {sipName_SetEdgeColumn, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetEdgeColumn), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetEdgeColumn},
    {sipName_SetEdgeMode, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetEdgeMode), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetEdgeMode},
    {sipName_SetEditable, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetEditable), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetEditable},
    {sipName_SetEmptySelection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetEmptySelection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetEmptySelection},
    {sipName_SetEndAtLastLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetEndAtLastLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetEndAtLastLine},
    {sipName_SetExtraAscent, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetExtraAscent), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetExtraAscent},
    {sipName_SetExtraDescent, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetExtraDescent), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetExtraDescent},
    {sipName_SetFirstVisibleLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetFirstVisibleLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetFirstVisibleLine},
    {sipName_SetFoldExpanded, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetFoldExpanded), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetFoldExpanded},
    {sipName_SetFoldFlags, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetFoldFlags), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetFoldFlags},
    {sipName_SetFoldLevel, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetFoldLevel), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetFoldLevel},
    {sipName_SetFoldMarginColour, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetFoldMarginColour), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetFoldMarginColour},
    {sipName_SetFoldMarginHiColour, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetFoldMarginHiColour), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetFoldMarginHiColour},
    {sipName_SetFontQuality, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetFontQuality), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetFontQuality},
    {sipName_SetHScrollBar, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetHScrollBar), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetHScrollBar},
    {sipName_SetHighlightGuide, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetHighlightGuide), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetHighlightGuide},
    {sipName_SetHint, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetHint), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetHint},
    {sipName_SetHotspotActiveBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetHotspotActiveBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetHotspotActiveBackground},
    {sipName_SetHotspotActiveForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetHotspotActiveForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetHotspotActiveForeground},
    {sipName_SetHotspotActiveUnderline, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetHotspotActiveUnderline), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetHotspotActiveUnderline},
    {sipName_SetHotspotSingleLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetHotspotSingleLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetHotspotSingleLine},
    {sipName_SetIMEInteraction, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetIMEInteraction), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetIMEInteraction},
    {sipName_SetIdentifier, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetIdentifier), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetIdentifier},
    {sipName_SetIdentifiers, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetIdentifiers), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetIdentifiers},
    {sipName_SetIdleStyling, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetIdleStyling), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetIdleStyling},
    {sipName_SetIndent, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetIndent), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetIndent},
    {sipName_SetIndentationGuides, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetIndentationGuides), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetIndentationGuides},
    {sipName_SetIndicatorCurrent, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetIndicatorCurrent), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetIndicatorCurrent},
    {sipName_SetIndicatorValue, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetIndicatorValue), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetIndicatorValue},
    {sipName_SetInsertionPoint, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetInsertionPoint), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetInsertionPoint},
    {sipName_SetInsertionPointEnd, meth_wxStyledTextCtrl_SetInsertionPointEnd, METH_VARARGS, doc_wxStyledTextCtrl_SetInsertionPointEnd},
    {sipName_SetKeyWords, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetKeyWords), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetKeyWords},
    {sipName_SetLastKeydownProcessed, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetLastKeydownProcessed), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetLastKeydownProcessed},
    {sipName_SetLayoutCache, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetLayoutCache), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetLayoutCache},
    {sipName_SetLexer, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetLexer), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetLexer},
    {sipName_SetLexerLanguage, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetLexerLanguage), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetLexerLanguage},
    {sipName_SetLineEndTypesAllowed, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetLineEndTypesAllowed), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetLineEndTypesAllowed},
    {sipName_SetLineIndentation, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetLineIndentation), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetLineIndentation},
    {sipName_SetLineState, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetLineState), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetLineState},
    {sipName_SetMainSelection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMainSelection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMainSelection},
    {sipName_SetMarginBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginBackground},
    {sipName_SetMarginCount, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginCount), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginCount},
    {sipName_SetMarginCursor, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginCursor), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginCursor},
    {sipName_SetMarginLeft, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginLeft), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginLeft},
    {sipName_SetMarginMask, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginMask), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginMask},
    {sipName_SetMarginOptions, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginOptions), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginOptions},
    {sipName_SetMarginRight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginRight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginRight},
    {sipName_SetMarginSensitive, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginSensitive), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginSensitive},
    {sipName_SetMarginType, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginType), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginType},
    {sipName_SetMarginWidth, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMarginWidth), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMarginWidth},
    {sipName_SetMargins, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMargins), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMargins},
    {sipName_SetMaxLength, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMaxLength), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMaxLength},
    {sipName_SetModEventMask, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetModEventMask), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetModEventMask},
    {sipName_SetModified, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetModified), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetModified},
    {sipName_SetMouseDownCaptures, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMouseDownCaptures), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMouseDownCaptures},
    {sipName_SetMouseDwellTime, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMouseDwellTime), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMouseDwellTime},
    {sipName_SetMouseSelectionRectangularSwitch, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMouseSelectionRectangularSwitch), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMouseSelectionRectangularSwitch},
    {sipName_SetMouseWheelCaptures, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMouseWheelCaptures), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMouseWheelCaptures},
    {sipName_SetMultiPaste, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMultiPaste), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMultiPaste},
    {sipName_SetMultipleSelection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetMultipleSelection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetMultipleSelection},
    {sipName_SetOvertype, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetOvertype), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetOvertype},
    {sipName_SetPasteConvertEndings, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetPasteConvertEndings), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetPasteConvertEndings},
    {sipName_SetPhasesDraw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetPhasesDraw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetPhasesDraw},
    {sipName_SetPositionCacheSize, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetPositionCacheSize), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetPositionCacheSize},
    {sipName_SetPrintColourMode, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetPrintColourMode), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetPrintColourMode},
    {sipName_SetPrintMagnification, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetPrintMagnification), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetPrintMagnification},
    {sipName_SetPrintWrapMode, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetPrintWrapMode), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetPrintWrapMode},
    {sipName_SetProperty, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetProperty), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetProperty},
    {sipName_SetPunctuationChars, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetPunctuationChars), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetPunctuationChars},
    {sipName_SetReadOnly, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetReadOnly), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetReadOnly},
    {sipName_SetRectangularSelectionAnchor, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetRectangularSelectionAnchor), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetRectangularSelectionAnchor},
    {sipName_SetRectangularSelectionAnchorVirtualSpace, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetRectangularSelectionAnchorVirtualSpace), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetRectangularSelectionAnchorVirtualSpace},
    {sipName_SetRectangularSelectionCaret, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetRectangularSelectionCaret), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetRectangularSelectionCaret},
    {sipName_SetRectangularSelectionCaretVirtualSpace, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetRectangularSelectionCaretVirtualSpace), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetRectangularSelectionCaretVirtualSpace},
    {sipName_SetRectangularSelectionModifier, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetRectangularSelectionModifier), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetRectangularSelectionModifier},
    {sipName_SetRepresentation, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetRepresentation), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetRepresentation},
    {sipName_SetSTCCursor, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSTCCursor), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSTCCursor},
    {sipName_SetSTCFocus, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSTCFocus), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSTCFocus},
    {sipName_SetSavePoint, meth_wxStyledTextCtrl_SetSavePoint, METH_VARARGS, doc_wxStyledTextCtrl_SetSavePoint},
    {sipName_SetScrollWidth, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetScrollWidth), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetScrollWidth},
    {sipName_SetScrollWidthTracking, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetScrollWidthTracking), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetScrollWidthTracking},
    {sipName_SetSearchFlags, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSearchFlags), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSearchFlags},
    {sipName_SetSelAlpha, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelAlpha), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelAlpha},
    {sipName_SetSelBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelBackground},
    {sipName_SetSelEOLFilled, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelEOLFilled), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelEOLFilled},
    {sipName_SetSelForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelForeground},
    {sipName_SetSelection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelection},
    {sipName_SetSelectionEnd, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionEnd), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionEnd},
    {sipName_SetSelectionMode, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionMode), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionMode},
    {sipName_SetSelectionNAnchor, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionNAnchor), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionNAnchor},
    {sipName_SetSelectionNAnchorVirtualSpace, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionNAnchorVirtualSpace), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionNAnchorVirtualSpace},
    {sipName_SetSelectionNCaret, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionNCaret), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionNCaret},
    {sipName_SetSelectionNCaretVirtualSpace, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionNCaretVirtualSpace), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionNCaretVirtualSpace},
    {sipName_SetSelectionNEnd, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionNEnd), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionNEnd},
    {sipName_SetSelectionNStart, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionNStart), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionNStart},
    {sipName_SetSelectionStart, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetSelectionStart), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetSelectionStart},
    {sipName_SetStatus, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetStatus), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetStatus},
    {sipName_SetStyle, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetStyle), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetStyle},
    {sipName_SetStyleBits, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetStyleBits), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetStyleBits},
    {sipName_SetStyleBytes, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetStyleBytes), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetStyleBytes},
    {sipName_SetStyling, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetStyling), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetStyling},
    {sipName_SetTabDrawMode, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTabDrawMode), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTabDrawMode},
    {sipName_SetTabIndents, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTabIndents), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTabIndents},
    {sipName_SetTabWidth, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTabWidth), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTabWidth},
    {sipName_SetTargetEnd, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTargetEnd), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTargetEnd},
    {sipName_SetTargetRange, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTargetRange), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTargetRange},
    {sipName_SetTargetStart, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTargetStart), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTargetStart},
    {sipName_SetTechnology, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTechnology), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTechnology},
    {sipName_SetText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetText},
    {sipName_SetTextRaw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTextRaw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTextRaw},
    {sipName_SetTwoPhaseDraw, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetTwoPhaseDraw), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetTwoPhaseDraw},
    {sipName_SetUndoCollection, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetUndoCollection), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetUndoCollection},
    {sipName_SetUseAntiAliasing, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetUseAntiAliasing), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetUseAntiAliasing},
    {sipName_SetUseHorizontalScrollBar, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetUseHorizontalScrollBar), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetUseHorizontalScrollBar},
    {sipName_SetUseTabs, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetUseTabs), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetUseTabs},
    {sipName_SetUseVerticalScrollBar, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetUseVerticalScrollBar), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetUseVerticalScrollBar},
    {sipName_SetVScrollBar, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetVScrollBar), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetVScrollBar},
    {sipName_SetValue, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetValue), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetValue},
    {sipName_SetViewEOL, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetViewEOL), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetViewEOL},
    {sipName_SetViewWhiteSpace, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetViewWhiteSpace), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetViewWhiteSpace},
    {sipName_SetVirtualSpaceOptions, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetVirtualSpaceOptions), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetVirtualSpaceOptions},
    {sipName_SetVisiblePolicy, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetVisiblePolicy), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetVisiblePolicy},
    {sipName_SetWhitespaceBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWhitespaceBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWhitespaceBackground},
    {sipName_SetWhitespaceChars, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWhitespaceChars), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWhitespaceChars},
    {sipName_SetWhitespaceForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWhitespaceForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWhitespaceForeground},
    {sipName_SetWhitespaceSize, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWhitespaceSize), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWhitespaceSize},
    {sipName_SetWordChars, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWordChars), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWordChars},
    {sipName_SetWrapIndentMode, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWrapIndentMode), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWrapIndentMode},
    {sipName_SetWrapMode, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWrapMode), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWrapMode},
    {sipName_SetWrapStartIndent, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWrapStartIndent), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWrapStartIndent},
    {sipName_SetWrapVisualFlags, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWrapVisualFlags), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWrapVisualFlags},
    {sipName_SetWrapVisualFlagsLocation, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetWrapVisualFlagsLocation), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetWrapVisualFlagsLocation},
    {sipName_SetXCaretPolicy, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetXCaretPolicy), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetXCaretPolicy},
    {sipName_SetXOffset, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetXOffset), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetXOffset},
    {sipName_SetYCaretPolicy, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetYCaretPolicy), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetYCaretPolicy},
    {sipName_SetZoom, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_SetZoom), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_SetZoom},
    {sipName_ShowLines, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ShowLines), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ShowLines},
    {sipName_ShowPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ShowPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ShowPosition},
    {sipName_StartRecord, meth_wxStyledTextCtrl_StartRecord, METH_VARARGS, doc_wxStyledTextCtrl_StartRecord},
    {sipName_StartStyling, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StartStyling), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StartStyling},
    {sipName_StopRecord, meth_wxStyledTextCtrl_StopRecord, METH_VARARGS, doc_wxStyledTextCtrl_StopRecord},
    {sipName_StutteredPageDown, meth_wxStyledTextCtrl_StutteredPageDown, METH_VARARGS, doc_wxStyledTextCtrl_StutteredPageDown},
    {sipName_StutteredPageDownExtend, meth_wxStyledTextCtrl_StutteredPageDownExtend, METH_VARARGS, doc_wxStyledTextCtrl_StutteredPageDownExtend},
    {sipName_StutteredPageUp, meth_wxStyledTextCtrl_StutteredPageUp, METH_VARARGS, doc_wxStyledTextCtrl_StutteredPageUp},
    {sipName_StutteredPageUpExtend, meth_wxStyledTextCtrl_StutteredPageUpExtend, METH_VARARGS, doc_wxStyledTextCtrl_StutteredPageUpExtend},
    {sipName_StyleClearAll, meth_wxStyledTextCtrl_StyleClearAll, METH_VARARGS, doc_wxStyledTextCtrl_StyleClearAll},
    {sipName_StyleGetBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetBackground},
    {sipName_StyleGetBold, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetBold), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetBold},
    {sipName_StyleGetCase, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetCase), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetCase},
    {sipName_StyleGetChangeable, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetChangeable), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetChangeable},
    {sipName_StyleGetCharacterSet, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetCharacterSet), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetCharacterSet},
    {sipName_StyleGetEOLFilled, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetEOLFilled), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetEOLFilled},
    {sipName_StyleGetFaceName, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetFaceName), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetFaceName},
    {sipName_StyleGetFont, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetFont), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetFont},
    {sipName_StyleGetForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetForeground},
    {sipName_StyleGetHotSpot, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetHotSpot), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetHotSpot},
    {sipName_StyleGetItalic, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetItalic), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetItalic},
    {sipName_StyleGetSize, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetSize), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetSize},
    {sipName_StyleGetSizeFractional, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetSizeFractional), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetSizeFractional},
    {sipName_StyleGetUnderline, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetUnderline), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetUnderline},
    {sipName_StyleGetVisible, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetVisible), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetVisible},
    {sipName_StyleGetWeight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleGetWeight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleGetWeight},
    {sipName_StyleResetDefault, meth_wxStyledTextCtrl_StyleResetDefault, METH_VARARGS, doc_wxStyledTextCtrl_StyleResetDefault},
    {sipName_StyleSetBackground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetBackground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetBackground},
    {sipName_StyleSetBold, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetBold), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetBold},
    {sipName_StyleSetCase, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetCase), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetCase},
    {sipName_StyleSetChangeable, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetChangeable), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetChangeable},
    {sipName_StyleSetCharacterSet, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetCharacterSet), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetCharacterSet},
    {sipName_StyleSetEOLFilled, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetEOLFilled), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetEOLFilled},
    {sipName_StyleSetFaceName, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetFaceName), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetFaceName},
    {sipName_StyleSetFont, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetFont), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetFont},
    {sipName_StyleSetFontAttr, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetFontAttr), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetFontAttr},
    {sipName_StyleSetFontEncoding, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetFontEncoding), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetFontEncoding},
    {sipName_StyleSetForeground, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetForeground), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetForeground},
    {sipName_StyleSetHotSpot, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetHotSpot), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetHotSpot},
    {sipName_StyleSetItalic, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetItalic), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetItalic},
    {sipName_StyleSetSize, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetSize), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetSize},
    {sipName_StyleSetSizeFractional, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetSizeFractional), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetSizeFractional},
    {sipName_StyleSetSpec, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetSpec), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetSpec},
    {sipName_StyleSetUnderline, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetUnderline), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetUnderline},
    {sipName_StyleSetVisible, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetVisible), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetVisible},
    {sipName_StyleSetWeight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_StyleSetWeight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_StyleSetWeight},
    {sipName_SwapMainAnchorCaret, meth_wxStyledTextCtrl_SwapMainAnchorCaret, METH_VARARGS, doc_wxStyledTextCtrl_SwapMainAnchorCaret},
    {sipName_Tab, meth_wxStyledTextCtrl_Tab, METH_VARARGS, doc_wxStyledTextCtrl_Tab},
    {sipName_TargetFromSelection, meth_wxStyledTextCtrl_TargetFromSelection, METH_VARARGS, doc_wxStyledTextCtrl_TargetFromSelection},
    {sipName_TargetWholeDocument, meth_wxStyledTextCtrl_TargetWholeDocument, METH_VARARGS, doc_wxStyledTextCtrl_TargetWholeDocument},
    {sipName_TextHeight, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_TextHeight), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_TextHeight},
    {sipName_TextWidth, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_TextWidth), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_TextWidth},
    {sipName_ToggleCaretSticky, meth_wxStyledTextCtrl_ToggleCaretSticky, METH_VARARGS, doc_wxStyledTextCtrl_ToggleCaretSticky},
    {sipName_ToggleFold, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ToggleFold), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ToggleFold},
    {sipName_ToggleFoldShowText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_ToggleFoldShowText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_ToggleFoldShowText},
    {sipName_TryAfter, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_TryAfter), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_TryBefore, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_TryBefore), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {sipName_Undo, meth_wxStyledTextCtrl_Undo, METH_VARARGS, doc_wxStyledTextCtrl_Undo},
    {sipName_UpperCase, meth_wxStyledTextCtrl_UpperCase, METH_VARARGS, doc_wxStyledTextCtrl_UpperCase},
    {sipName_UsePopUp, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_UsePopUp), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_UsePopUp},
    {sipName_UserListShow, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_UserListShow), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_UserListShow},
    {sipName_VCHome, meth_wxStyledTextCtrl_VCHome, METH_VARARGS, doc_wxStyledTextCtrl_VCHome},
    {sipName_VCHomeDisplay, meth_wxStyledTextCtrl_VCHomeDisplay, METH_VARARGS, doc_wxStyledTextCtrl_VCHomeDisplay},
    {sipName_VCHomeDisplayExtend, meth_wxStyledTextCtrl_VCHomeDisplayExtend, METH_VARARGS, doc_wxStyledTextCtrl_VCHomeDisplayExtend},
    {sipName_VCHomeExtend, meth_wxStyledTextCtrl_VCHomeExtend, METH_VARARGS, doc_wxStyledTextCtrl_VCHomeExtend},
    {sipName_VCHomeRectExtend, meth_wxStyledTextCtrl_VCHomeRectExtend, METH_VARARGS, doc_wxStyledTextCtrl_VCHomeRectExtend},
    {sipName_VCHomeWrap, meth_wxStyledTextCtrl_VCHomeWrap, METH_VARARGS, doc_wxStyledTextCtrl_VCHomeWrap},
    {sipName_VCHomeWrapExtend, meth_wxStyledTextCtrl_VCHomeWrapExtend, METH_VARARGS, doc_wxStyledTextCtrl_VCHomeWrapExtend},
    {sipName_VerticalCentreCaret, meth_wxStyledTextCtrl_VerticalCentreCaret, METH_VARARGS, doc_wxStyledTextCtrl_VerticalCentreCaret},
    {sipName_VisibleFromDocLine, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_VisibleFromDocLine), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_VisibleFromDocLine},
    {sipName_WordEndPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_WordEndPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_WordEndPosition},
    {sipName_WordLeft, meth_wxStyledTextCtrl_WordLeft, METH_VARARGS, doc_wxStyledTextCtrl_WordLeft},
    {sipName_WordLeftEnd, meth_wxStyledTextCtrl_WordLeftEnd, METH_VARARGS, doc_wxStyledTextCtrl_WordLeftEnd},
    {sipName_WordLeftEndExtend, meth_wxStyledTextCtrl_WordLeftEndExtend, METH_VARARGS, doc_wxStyledTextCtrl_WordLeftEndExtend},
    {sipName_WordLeftExtend, meth_wxStyledTextCtrl_WordLeftExtend, METH_VARARGS, doc_wxStyledTextCtrl_WordLeftExtend},
    {sipName_WordPartLeft, meth_wxStyledTextCtrl_WordPartLeft, METH_VARARGS, doc_wxStyledTextCtrl_WordPartLeft},
    {sipName_WordPartLeftExtend, meth_wxStyledTextCtrl_WordPartLeftExtend, METH_VARARGS, doc_wxStyledTextCtrl_WordPartLeftExtend},
    {sipName_WordPartRight, meth_wxStyledTextCtrl_WordPartRight, METH_VARARGS, doc_wxStyledTextCtrl_WordPartRight},
    {sipName_WordPartRightExtend, meth_wxStyledTextCtrl_WordPartRightExtend, METH_VARARGS, doc_wxStyledTextCtrl_WordPartRightExtend},
    {sipName_WordRight, meth_wxStyledTextCtrl_WordRight, METH_VARARGS, doc_wxStyledTextCtrl_WordRight},
    {sipName_WordRightEnd, meth_wxStyledTextCtrl_WordRightEnd, METH_VARARGS, doc_wxStyledTextCtrl_WordRightEnd},
    {sipName_WordRightEndExtend, meth_wxStyledTextCtrl_WordRightEndExtend, METH_VARARGS, doc_wxStyledTextCtrl_WordRightEndExtend},
    {sipName_WordRightExtend, meth_wxStyledTextCtrl_WordRightExtend, METH_VARARGS, doc_wxStyledTextCtrl_WordRightExtend},
    {sipName_WordStartPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_WordStartPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_WordStartPosition},
    {sipName_WrapCount, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_WrapCount), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_WrapCount},
    {sipName_WriteText, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_WriteText), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_WriteText},
    {sipName_XYToPosition, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_XYToPosition), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_XYToPosition},
    {sipName_ZoomIn, meth_wxStyledTextCtrl_ZoomIn, METH_VARARGS, doc_wxStyledTextCtrl_ZoomIn},
    {sipName_ZoomOut, meth_wxStyledTextCtrl_ZoomOut, METH_VARARGS, doc_wxStyledTextCtrl_ZoomOut},
    {sipName_flush, meth_wxStyledTextCtrl_flush, METH_VARARGS, doc_wxStyledTextCtrl_flush},
    {sipName_write, SIP_MLMETH_CAST(meth_wxStyledTextCtrl_write), METH_VARARGS|METH_KEYWORDS, doc_wxStyledTextCtrl_write}
};

sipVariableDef variables_wxStyledTextCtrl[] = {
    {PropertyVariable, sipName_Zoom, &methods_wxStyledTextCtrl[369], &methods_wxStyledTextCtrl[696], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_XOffset, &methods_wxStyledTextCtrl[368], &methods_wxStyledTextCtrl[694], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WrapVisualFlagsLocation, &methods_wxStyledTextCtrl[367], &methods_wxStyledTextCtrl[692], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WrapVisualFlags, &methods_wxStyledTextCtrl[366], &methods_wxStyledTextCtrl[691], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WrapStartIndent, &methods_wxStyledTextCtrl[365], &methods_wxStyledTextCtrl[690], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WrapMode, &methods_wxStyledTextCtrl[364], &methods_wxStyledTextCtrl[689], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WrapIndentMode, &methods_wxStyledTextCtrl[363], &methods_wxStyledTextCtrl[688], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WordChars, &methods_wxStyledTextCtrl[362], &methods_wxStyledTextCtrl[687], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WhitespaceSize, &methods_wxStyledTextCtrl[361], &methods_wxStyledTextCtrl[686], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_WhitespaceChars, &methods_wxStyledTextCtrl[360], &methods_wxStyledTextCtrl[684], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_VirtualSpaceOptions, &methods_wxStyledTextCtrl[359], &methods_wxStyledTextCtrl[681], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ViewWhiteSpace, &methods_wxStyledTextCtrl[358], &methods_wxStyledTextCtrl[680], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ViewEOL, &methods_wxStyledTextCtrl[357], &methods_wxStyledTextCtrl[679], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Value, &methods_wxStyledTextCtrl[356], &methods_wxStyledTextCtrl[678], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_UseVerticalScrollBar, &methods_wxStyledTextCtrl[355], &methods_wxStyledTextCtrl[676], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_UseTabs, &methods_wxStyledTextCtrl[354], &methods_wxStyledTextCtrl[675], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_UseHorizontalScrollBar, &methods_wxStyledTextCtrl[353], &methods_wxStyledTextCtrl[674], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_UseAntiAliasing, &methods_wxStyledTextCtrl[352], &methods_wxStyledTextCtrl[673], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_UndoCollection, &methods_wxStyledTextCtrl[351], &methods_wxStyledTextCtrl[672], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TwoPhaseDraw, &methods_wxStyledTextCtrl[350], &methods_wxStyledTextCtrl[671], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TextRaw, &methods_wxStyledTextCtrl[349], &methods_wxStyledTextCtrl[670], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TextLength, &methods_wxStyledTextCtrl[346], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Text, &methods_wxStyledTextCtrl[345], &methods_wxStyledTextCtrl[669], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Technology, &methods_wxStyledTextCtrl[344], &methods_wxStyledTextCtrl[668], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TargetTextRaw, &methods_wxStyledTextCtrl[343], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TargetText, &methods_wxStyledTextCtrl[342], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TargetStart, &methods_wxStyledTextCtrl[341], &methods_wxStyledTextCtrl[667], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TargetEnd, &methods_wxStyledTextCtrl[340], &methods_wxStyledTextCtrl[665], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TabWidth, &methods_wxStyledTextCtrl[338], &methods_wxStyledTextCtrl[664], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TabIndents, &methods_wxStyledTextCtrl[337], &methods_wxStyledTextCtrl[663], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_TabDrawMode, &methods_wxStyledTextCtrl[336], &methods_wxStyledTextCtrl[662], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SubStyleBases, &methods_wxStyledTextCtrl[333], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_StyleBitsNeeded, &methods_wxStyledTextCtrl[330], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_StyleBits, &methods_wxStyledTextCtrl[329], &methods_wxStyledTextCtrl[659], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_StringSelection, &methods_wxStyledTextCtrl[326], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Status, &methods_wxStyledTextCtrl[325], &methods_wxStyledTextCtrl[657], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Selections, &methods_wxStyledTextCtrl[324], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionStart, &methods_wxStyledTextCtrl[323], &methods_wxStyledTextCtrl[656], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionMode, &methods_wxStyledTextCtrl[316], &methods_wxStyledTextCtrl[649], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionEnd, &methods_wxStyledTextCtrl[315], &methods_wxStyledTextCtrl[648], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectionEmpty, &methods_wxStyledTextCtrl[314], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectedTextRaw, &methods_wxStyledTextCtrl[312], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelectedText, &methods_wxStyledTextCtrl[311], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelEOLFilled, &methods_wxStyledTextCtrl[310], &methods_wxStyledTextCtrl[645], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SelAlpha, &methods_wxStyledTextCtrl[309], &methods_wxStyledTextCtrl[643], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_SearchFlags, &methods_wxStyledTextCtrl[308], &methods_wxStyledTextCtrl[642], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ScrollWidthTracking, &methods_wxStyledTextCtrl[307], &methods_wxStyledTextCtrl[641], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ScrollWidth, &methods_wxStyledTextCtrl[306], &methods_wxStyledTextCtrl[640], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_STCFocus, &methods_wxStyledTextCtrl[305], &methods_wxStyledTextCtrl[638], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_STCCursor, &methods_wxStyledTextCtrl[304], &methods_wxStyledTextCtrl[637], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RectangularSelectionModifier, &methods_wxStyledTextCtrl[302], &methods_wxStyledTextCtrl[635], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RectangularSelectionCaretVirtualSpace, &methods_wxStyledTextCtrl[301], &methods_wxStyledTextCtrl[634], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RectangularSelectionCaret, &methods_wxStyledTextCtrl[300], &methods_wxStyledTextCtrl[633], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RectangularSelectionAnchorVirtualSpace, &methods_wxStyledTextCtrl[299], &methods_wxStyledTextCtrl[632], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RectangularSelectionAnchor, &methods_wxStyledTextCtrl[298], &methods_wxStyledTextCtrl[631], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ReadOnly, &methods_wxStyledTextCtrl[297], &methods_wxStyledTextCtrl[630], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_RangePointer, &methods_wxStyledTextCtrl[296], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_PunctuationChars, &methods_wxStyledTextCtrl[294], &methods_wxStyledTextCtrl[629], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_PrintWrapMode, &methods_wxStyledTextCtrl[290], &methods_wxStyledTextCtrl[627], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_PrintMagnification, &methods_wxStyledTextCtrl[289], &methods_wxStyledTextCtrl[626], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_PrintColourMode, &methods_wxStyledTextCtrl[288], &methods_wxStyledTextCtrl[625], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_PositionCacheSize, &methods_wxStyledTextCtrl[286], &methods_wxStyledTextCtrl[624], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_PhasesDraw, &methods_wxStyledTextCtrl[285], &methods_wxStyledTextCtrl[623], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_PasteConvertEndings, &methods_wxStyledTextCtrl[284], &methods_wxStyledTextCtrl[622], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Overtype, &methods_wxStyledTextCtrl[283], &methods_wxStyledTextCtrl[621], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_NumberOfLines, &methods_wxStyledTextCtrl[282], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MultipleSelection, &methods_wxStyledTextCtrl[280], &methods_wxStyledTextCtrl[620], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MultiPaste, &methods_wxStyledTextCtrl[279], &methods_wxStyledTextCtrl[619], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MouseWheelCaptures, &methods_wxStyledTextCtrl[278], &methods_wxStyledTextCtrl[618], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MouseSelectionRectangularSwitch, &methods_wxStyledTextCtrl[277], &methods_wxStyledTextCtrl[617], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MouseDwellTime, &methods_wxStyledTextCtrl[276], &methods_wxStyledTextCtrl[616], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MouseDownCaptures, &methods_wxStyledTextCtrl[275], &methods_wxStyledTextCtrl[615], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Modify, &methods_wxStyledTextCtrl[274], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ModEventMask, &methods_wxStyledTextCtrl[273], &methods_wxStyledTextCtrl[613], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MaxLineState, &methods_wxStyledTextCtrl[272], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Margins, &methods_wxStyledTextCtrl[270], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MarginRight, &methods_wxStyledTextCtrl[266], &methods_wxStyledTextCtrl[607], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MarginOptions, &methods_wxStyledTextCtrl[265], &methods_wxStyledTextCtrl[606], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MarginLeft, &methods_wxStyledTextCtrl[263], &methods_wxStyledTextCtrl[604], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MarginCount, &methods_wxStyledTextCtrl[261], &methods_wxStyledTextCtrl[602], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MainSelection, &methods_wxStyledTextCtrl[259], &methods_wxStyledTextCtrl[600], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LineEndTypesSupported, &methods_wxStyledTextCtrl[249], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LineEndTypesAllowed, &methods_wxStyledTextCtrl[248], &methods_wxStyledTextCtrl[597], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LineEndTypesActive, &methods_wxStyledTextCtrl[247], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LineCount, &methods_wxStyledTextCtrl[245], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LexerLanguage, &methods_wxStyledTextCtrl[242], &methods_wxStyledTextCtrl[596], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Lexer, &methods_wxStyledTextCtrl[241], &methods_wxStyledTextCtrl[595], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Length, &methods_wxStyledTextCtrl[240], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LayoutCache, &methods_wxStyledTextCtrl[239], &methods_wxStyledTextCtrl[594], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LastPosition, &methods_wxStyledTextCtrl[238], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_LastKeydownProcessed, &methods_wxStyledTextCtrl[237], &methods_wxStyledTextCtrl[593], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_InsertionPoint, &methods_wxStyledTextCtrl[235], &methods_wxStyledTextCtrl[590], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_IndicatorValue, &methods_wxStyledTextCtrl[234], &methods_wxStyledTextCtrl[589], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_IndicatorCurrent, &methods_wxStyledTextCtrl[233], &methods_wxStyledTextCtrl[588], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_IndentationGuides, &methods_wxStyledTextCtrl[232], &methods_wxStyledTextCtrl[587], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Indent, &methods_wxStyledTextCtrl[231], &methods_wxStyledTextCtrl[586], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_IdleStyling, &methods_wxStyledTextCtrl[230], &methods_wxStyledTextCtrl[585], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Identifier, &methods_wxStyledTextCtrl[229], &methods_wxStyledTextCtrl[583], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_IMEInteraction, &methods_wxStyledTextCtrl[228], &methods_wxStyledTextCtrl[582], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_HotspotSingleLine, &methods_wxStyledTextCtrl[227], &methods_wxStyledTextCtrl[581], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_HotspotActiveUnderline, &methods_wxStyledTextCtrl[226], &methods_wxStyledTextCtrl[580], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_HotspotActiveForeground, &methods_wxStyledTextCtrl[225], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_HotspotActiveBackground, &methods_wxStyledTextCtrl[224], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Hint, &methods_wxStyledTextCtrl[223], &methods_wxStyledTextCtrl[577], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_HighlightGuide, &methods_wxStyledTextCtrl[222], &methods_wxStyledTextCtrl[576], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_GapPosition, &methods_wxStyledTextCtrl[221], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FontQuality, &methods_wxStyledTextCtrl[220], &methods_wxStyledTextCtrl[574], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_FirstVisibleLine, &methods_wxStyledTextCtrl[216], &methods_wxStyledTextCtrl[568], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ExtraDescent, &methods_wxStyledTextCtrl[215], &methods_wxStyledTextCtrl[567], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ExtraAscent, &methods_wxStyledTextCtrl[214], &methods_wxStyledTextCtrl[566], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_EndStyled, &methods_wxStyledTextCtrl[213], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_EndAtLastLine, &methods_wxStyledTextCtrl[212], &methods_wxStyledTextCtrl[565], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_EdgeMode, &methods_wxStyledTextCtrl[211], &methods_wxStyledTextCtrl[562], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_EdgeColumn, &methods_wxStyledTextCtrl[210], &methods_wxStyledTextCtrl[561], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_EdgeColour, &methods_wxStyledTextCtrl[209], &methods_wxStyledTextCtrl[560], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_EOLMode, &methods_wxStyledTextCtrl[208], &methods_wxStyledTextCtrl[559], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DocPointer, &methods_wxStyledTextCtrl[207], &methods_wxStyledTextCtrl[558], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DirectPointer, &methods_wxStyledTextCtrl[206], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DirectFunction, &methods_wxStyledTextCtrl[205], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_DefaultStyle, &methods_wxStyledTextCtrl[204], &methods_wxStyledTextCtrl[557], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CurrentPos, &methods_wxStyledTextCtrl[201], &methods_wxStyledTextCtrl[556], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CurrentLine, &methods_wxStyledTextCtrl[200], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CurLineRaw, &methods_wxStyledTextCtrl[199], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CurLine, &methods_wxStyledTextCtrl[198], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ControlCharSymbol, &methods_wxStyledTextCtrl[197], &methods_wxStyledTextCtrl[555], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CodePage, &methods_wxStyledTextCtrl[195], &methods_wxStyledTextCtrl[554], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CharacterPointer, &methods_wxStyledTextCtrl[193], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretWidth, &methods_wxStyledTextCtrl[191], &methods_wxStyledTextCtrl[552], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretStyle, &methods_wxStyledTextCtrl[190], &methods_wxStyledTextCtrl[551], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretSticky, &methods_wxStyledTextCtrl[189], &methods_wxStyledTextCtrl[550], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretPeriod, &methods_wxStyledTextCtrl[188], &methods_wxStyledTextCtrl[549], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretLineVisibleAlways, &methods_wxStyledTextCtrl[187], &methods_wxStyledTextCtrl[548], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretLineVisible, &methods_wxStyledTextCtrl[186], &methods_wxStyledTextCtrl[547], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretLineBackground, &methods_wxStyledTextCtrl[185], &methods_wxStyledTextCtrl[546], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretLineBackAlpha, &methods_wxStyledTextCtrl[184], &methods_wxStyledTextCtrl[545], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CaretForeground, &methods_wxStyledTextCtrl[183], &methods_wxStyledTextCtrl[544], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_BufferedDraw, &methods_wxStyledTextCtrl[182], &methods_wxStyledTextCtrl[543], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_BackSpaceUnIndents, &methods_wxStyledTextCtrl[181], &methods_wxStyledTextCtrl[542], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AutomaticFold, &methods_wxStyledTextCtrl[180], &methods_wxStyledTextCtrl[541], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Anchor, &methods_wxStyledTextCtrl[179], &methods_wxStyledTextCtrl[540], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AllLinesVisible, &methods_wxStyledTextCtrl[178], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AdditionalSelectionTyping, &methods_wxStyledTextCtrl[177], &methods_wxStyledTextCtrl[539], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AdditionalSelAlpha, &methods_wxStyledTextCtrl[176], &methods_wxStyledTextCtrl[536], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AdditionalCaretsVisible, &methods_wxStyledTextCtrl[175], &methods_wxStyledTextCtrl[535], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AdditionalCaretsBlink, &methods_wxStyledTextCtrl[174], &methods_wxStyledTextCtrl[534], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AdditionalCaretForeground, &methods_wxStyledTextCtrl[173], &methods_wxStyledTextCtrl[533], SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxStyledTextCtrl, "StyledTextCtrl(parent, id=ID_ANY, pos=DefaultPosition, size=DefaultSize, style=0, name=STCNameStr)\n"
"StyledTextCtrl()\n"
"\n"
"A wxWidgets implementation of the Scintilla source code editing\n"
"component.");


sipClassTypeDef sipTypeDef__stc_wxStyledTextCtrl = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxStyledTextCtrl,
        SIP_NULLPTR,
        SIP_NULLPTR
    },
    {
        sipNameNr_StyledTextCtrl,
        {0, 0, 1},
        788, methods_wxStyledTextCtrl,
        0, SIP_NULLPTR,
        146, variables_wxStyledTextCtrl,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxStyledTextCtrl,
    -1,
    -1,
    supers_wxStyledTextCtrl,
    SIP_NULLPTR,
    init_type_wxStyledTextCtrl,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    dealloc_wxStyledTextCtrl,
    SIP_NULLPTR,
    array_wxStyledTextCtrl,
    SIP_NULLPTR,
    release_wxStyledTextCtrl,
    cast_wxStyledTextCtrl,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
};
